
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">stocksub/pkg/config/config.go (100.0%)</option>
				
				<option value="file1">stocksub/pkg/limiter/error_classifier.go (92.7%)</option>
				
				<option value="file2">stocksub/pkg/limiter/intelligent_limiter.go (0.0%)</option>
				
				<option value="file3">stocksub/pkg/logger/logger.go (0.0%)</option>
				
				<option value="file4">stocksub/pkg/provider/tencent/client.go (0.0%)</option>
				
				<option value="file5">stocksub/pkg/provider/tencent/parser.go (15.9%)</option>
				
				<option value="file6">stocksub/pkg/subscriber/errors.go (100.0%)</option>
				
				<option value="file7">stocksub/pkg/subscriber/manager.go (0.0%)</option>
				
				<option value="file8">stocksub/pkg/subscriber/schema_validation.go (93.9%)</option>
				
				<option value="file9">stocksub/pkg/subscriber/serializer.go (79.0%)</option>
				
				<option value="file10">stocksub/pkg/subscriber/structured_data.go (92.4%)</option>
				
				<option value="file11">stocksub/pkg/subscriber/subscriber.go (0.0%)</option>
				
				<option value="file12">stocksub/pkg/subscriber/types.go (0.0%)</option>
				
				<option value="file13">stocksub/pkg/testkit/cache/disk.go (88.6%)</option>
				
				<option value="file14">stocksub/pkg/testkit/cache/layered.go (52.5%)</option>
				
				<option value="file15">stocksub/pkg/testkit/cache/memory.go (94.0%)</option>
				
				<option value="file16">stocksub/pkg/testkit/cache/policy.go (86.0%)</option>
				
				<option value="file17">stocksub/pkg/testkit/cache/remote.go (100.0%)</option>
				
				<option value="file18">stocksub/pkg/testkit/config/config.go (68.2%)</option>
				
				<option value="file19">stocksub/pkg/testkit/core/errors.go (10.0%)</option>
				
				<option value="file20">stocksub/pkg/testkit/helpers/resource_manager.go (80.2%)</option>
				
				<option value="file21">stocksub/pkg/testkit/providers/cached.go (51.4%)</option>
				
				<option value="file22">stocksub/pkg/testkit/providers/mock.go (79.9%)</option>
				
				<option value="file23">stocksub/pkg/testkit/storage/batch_writer.go (0.0%)</option>
				
				<option value="file24">stocksub/pkg/testkit/storage/csv.go (72.6%)</option>
				
				<option value="file25">stocksub/pkg/testkit/storage/memory.go (83.2%)</option>
				
				<option value="file26">stocksub/pkg/testkit/testkit.go (0.0%)</option>
				
				<option value="file27">stocksub/pkg/timing/market_time.go (88.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "errors"
        "time"
)

// Config 主配置结构
type Config struct {
        // 提供商配置
        Provider ProviderConfig `json:"provider"`

        // 订阅器配置
        Subscriber SubscriberConfig `json:"subscriber"`

        // 日志配置
        Logger LoggerConfig `json:"logger"`
}

// ProviderConfig 数据提供商配置
type ProviderConfig struct {
        Name       string        `json:"name"`        // 提供商名称 ("tencent")
        Timeout    time.Duration `json:"timeout"`     // 请求超时时间
        MaxRetries int           `json:"max_retries"` // 最大重试次数
        RateLimit  time.Duration `json:"rate_limit"`  // 请求间隔限制
        UserAgent  string        `json:"user_agent"`  // 用户代理
        BatchSize  int           `json:"batch_size"`  // 批处理大小
}

// SubscriberConfig 订阅器配置
type SubscriberConfig struct {
        MaxSubscriptions   int           `json:"max_subscriptions"`    // 最大订阅数
        DefaultInterval    time.Duration `json:"default_interval"`     // 默认订阅间隔
        MinInterval        time.Duration `json:"min_interval"`         // 最小订阅间隔
        MaxInterval        time.Duration `json:"max_interval"`         // 最大订阅间隔
        EventChannelBuffer int           `json:"event_channel_buffer"` // 事件通道缓冲区大小
}

// LoggerConfig 日志配置
type LoggerConfig struct {
        Level      string `json:"level"`       // 日志级别 (debug, info, warn, error)
        Output     string `json:"output"`      // 输出方式 (console, file)
        Filename   string `json:"filename"`    // 日志文件名
        MaxSize    int    `json:"max_size"`    // 最大文件大小(MB)
        MaxBackups int    `json:"max_backups"` // 最大备份数
        MaxAge     int    `json:"max_age"`     // 最大保存天数
}

// Default 返回默认配置
func Default() *Config <span class="cov10" title="15">{
        return &amp;Config{
                Provider: ProviderConfig{
                        Name:       "tencent",
                        Timeout:    15 * time.Second,
                        MaxRetries: 3,
                        RateLimit:  200 * time.Millisecond,
                        UserAgent:  "StockSub/1.0",
                        BatchSize:  50,
                },
                Subscriber: SubscriberConfig{
                        MaxSubscriptions:   100,
                        DefaultInterval:    5 * time.Second,
                        MinInterval:        1 * time.Second,
                        MaxInterval:        1 * time.Hour,
                        EventChannelBuffer: 1000,
                },
                Logger: LoggerConfig{
                        Level:      "info",
                        Output:     "console",
                        Filename:   "stocksub.log",
                        MaxSize:    10,
                        MaxBackups: 5,
                        MaxAge:     30,
                },
        }
}</span>

// Validate 验证配置
func (c *Config) Validate() error <span class="cov9" title="14">{
        if c.Provider.Name == "" </span><span class="cov1" title="1">{
                return errors.New("provider name cannot be empty")
        }</span>

        <span class="cov9" title="13">if c.Provider.Timeout &lt;= 0 </span><span class="cov3" title="2">{
                return errors.New("provider timeout must be positive")
        }</span>

        <span class="cov8" title="11">if c.Provider.MaxRetries &lt; 0 </span><span class="cov1" title="1">{
                return errors.New("provider max_retries cannot be negative")
        }</span>

        <span class="cov8" title="10">if c.Provider.RateLimit &lt; 0 </span><span class="cov1" title="1">{
                return errors.New("provider rate_limit cannot be negative")
        }</span>

        <span class="cov8" title="9">if c.Subscriber.MaxSubscriptions &lt;= 0 </span><span class="cov3" title="2">{
                return errors.New("max_subscriptions must be positive")
        }</span>

        <span class="cov7" title="7">if c.Subscriber.MinInterval &lt;= 0 </span><span class="cov3" title="2">{
                return errors.New("min_interval must be positive")
        }</span>

        <span class="cov6" title="5">if c.Subscriber.MaxInterval &lt;= c.Subscriber.MinInterval </span><span class="cov3" title="2">{
                return errors.New("max_interval must be greater than min_interval")
        }</span>

        <span class="cov4" title="3">if c.Subscriber.EventChannelBuffer &lt;= 0 </span><span class="cov3" title="2">{
                return errors.New("event_channel_buffer must be positive")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// SetProviderTimeout 设置提供商超时时间
func (c *Config) SetProviderTimeout(timeout time.Duration) *Config <span class="cov1" title="1">{
        c.Provider.Timeout = timeout
        return c
}</span>

// SetRateLimit 设置请求频率限制
func (c *Config) SetRateLimit(limit time.Duration) *Config <span class="cov1" title="1">{
        c.Provider.RateLimit = limit
        return c
}</span>

// SetDefaultInterval 设置默认订阅间隔
func (c *Config) SetDefaultInterval(interval time.Duration) *Config <span class="cov1" title="1">{
        c.Subscriber.DefaultInterval = interval
        return c
}</span>

// SetMaxSubscriptions 设置最大订阅数
func (c *Config) SetMaxSubscriptions(max int) *Config <span class="cov1" title="1">{
        c.Subscriber.MaxSubscriptions = max
        return c
}</span>

// SetLogLevel 设置日志级别
func (c *Config) SetLogLevel(level string) *Config <span class="cov1" title="1">{
        c.Logger.Level = level
        return c
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package limiter

import (
        "strings"
        "time"
)

// ErrorLevel 定义错误的严重级别
type ErrorLevel int

const (
        LevelFatal   ErrorLevel = iota // 致命级，立即终止
        LevelNetwork                   // 网络错误，可重试
        LevelInvalid                   // 无效参数，可忽略或特殊处理
        LevelUnknown                   // 未知错误
)

const (
        MaxRetries = 3               // 最大重试次数
        RetryBase1 = 1 * time.Minute // 第一次重试等待时间
        RetryBase2 = 3 * time.Minute // 第二次重试等待时间
        RetryBase3 = 5 * time.Minute // 第三次重试等待时间
)

// ErrorClassifier 负责根据错误类型进行分类
type ErrorClassifier struct {
        // 可以扩展添加自定义规则
}

// NewErrorClassifier 创建新的错误分类器
func NewErrorClassifier() *ErrorClassifier <span class="cov5" title="4">{
        return &amp;ErrorClassifier{}
}</span>

// Classify 根据错误内容分类错误级别
func (c *ErrorClassifier) Classify(err error) ErrorLevel <span class="cov10" title="14">{
        if err == nil </span><span class="cov1" title="1">{
                return LevelUnknown
        }</span>

        <span class="cov9" title="13">msg := strings.ToLower(err.Error())

        // 致命级错误 - 立即终止
        switch </span>{
        case strings.Contains(msg, "connection refused"):<span class="cov1" title="1">
                return LevelFatal</span>
        case strings.Contains(msg, "connection reset") &amp;&amp; (!strings.Contains(msg, "read tcp") &amp;&amp; !strings.Contains(msg, "write tcp")):<span class="cov1" title="1">
                return LevelFatal</span> // 只有直接连接重置才是致命错误，TCP读写重置是网络错误
        case strings.Contains(msg, "nosuchhost"),
                strings.Contains(msg, "dial tcp"),
                strings.Contains(msg, "dial udp"):<span class="cov1" title="1">
                return LevelFatal</span>
        case strings.Contains(msg, "forbidden") &amp;&amp;
                strings.Contains(msg, "403"):<span class="cov1" title="1">
                return LevelFatal</span>
        }

        // 网络错误 - 可重试
        <span class="cov8" title="9">switch </span>{
        case strings.Contains(msg, "timeout"):<span class="cov1" title="1">
                return LevelNetwork</span>
        case strings.Contains(msg, "network is unreachable"):<span class="cov1" title="1">
                return LevelNetwork</span>
        case strings.Contains(msg, "temporary failure"):<span class="cov1" title="1">
                return LevelNetwork</span>
        case strings.Contains(msg, "read tcp") &amp;&amp; strings.Contains(msg, "connection reset"):<span class="cov1" title="1">
                return LevelNetwork</span> // 读TCP连接重置也算网络错误，而不是致命错误
        case strings.Contains(msg, "write tcp"):<span class="cov1" title="1">
                return LevelNetwork</span>
        }

        // 无效参数 - 通常可忽略
        <span class="cov5" title="4">switch </span>{
        case strings.Contains(msg, "invalid argument"):<span class="cov1" title="1">
                return LevelInvalid</span>
        case strings.Contains(msg, "bad request"):<span class="cov1" title="1">
                return LevelInvalid</span>
        case strings.Contains(msg, "not found") &amp;&amp; strings.Contains(msg, "404"):<span class="cov1" title="1">
                return LevelInvalid</span>
        }

        // 其他错误归类为未知
        <span class="cov1" title="1">return LevelUnknown</span>
}

// GetRetryStrategy 根据错误级别提供重试策略
func (c *ErrorClassifier) GetRetryStrategy(level ErrorLevel, attempt int) (shouldRetry bool, waitDuration time.Duration) <span class="cov8" title="10">{
        switch level </span>{
        case LevelFatal:<span class="cov3" title="2">
                // 致命级错误，不尝试重试
                return false, 0</span>

        case LevelNetwork:<span class="cov5" title="4">
                if attempt &gt;= MaxRetries </span><span class="cov1" title="1">{
                        return false, 0
                }</span>

                // 根据尝试次数返回递增的等待时间
                <span class="cov4" title="3">switch attempt </span>{
                case 0:<span class="cov1" title="1">
                        return true, RetryBase1</span>
                case 1:<span class="cov1" title="1">
                        return true, RetryBase2</span>
                case 2:<span class="cov1" title="1">
                        return true, RetryBase3</span>
                default:<span class="cov0" title="0">
                        return true, RetryBase3</span>
                }

        case LevelInvalid, LevelUnknown:<span class="cov5" title="4">
                // 无效参数或未知错误，不重试
                return false, 0</span>

        default:<span class="cov0" title="0">
                return false, 0</span>
        }
}

// IsRetryAllowedInTime 检查重试是否在有效时间内
func (c *ErrorClassifier) IsRetryAllowedInTime(nextRetryTime time.Time, tradingEnd time.Time) bool <span class="cov7" title="6">{
        // 重试时间必须在交易结束前
        buffer := 30 * time.Second // 30秒缓冲时间
        return nextRetryTime.Before(tradingEnd.Add(-buffer))
}</span>

// GetRetryMessage 获取重试提示信息
func (c *ErrorClassifier) GetRetryMessage(level ErrorLevel, attempt int, nextWait time.Duration) string <span class="cov8" title="10">{
        switch level </span>{
        case LevelFatal:<span class="cov3" title="2">
                return "致命错误，立即终止操作"</span>
        case LevelNetwork:<span class="cov5" title="4">
                if attempt &gt;= MaxRetries </span><span class="cov1" title="1">{
                        return "网络错误已达到最大重试次数，终止此次操作"
                }</span>
                <span class="cov4" title="3">return "网络错误，等待重试..."</span>
        case LevelInvalid:<span class="cov3" title="2">
                return "参数无效，跳过重试"</span>
        case LevelUnknown:<span class="cov3" title="2">
                return "未知错误，跳过重试"</span>
        default:<span class="cov0" title="0">
                return "错误处理中..."</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package limiter

import (
        "context"
        "errors"
        "stocksub/pkg/timing"
        "sync"
        "time"
)

// IntelligentLimiter 智能限制器 - 统筹管理整个API批量调用的熔断策略
type IntelligentLimiter struct {
        mu              sync.RWMutex
        classifier      *ErrorClassifier
        marketTime      *timing.MarketTime
        currentBatch    []string  // 当前批次处理的symbols
        retryCount      int       // 重试计数
        lastError       error     // 最后发生的错误
        consecutiveSame int       // 连续相同数据计数
        lastData        string    // 最后获取的数据指纹
        isInitialized   bool      // 是否已初始化 batch
        tradingEnd      time.Time // 交易结束时间

        // 统计信息
        totalRequests   int64
        totalErrors     int64
        lastRequestTime time.Time

        // 安全开关
        forceStopFlag bool // 强制停止标志
}

// NewIntelligentLimiter 创建新的智能熔断器
func NewIntelligentLimiter(marketTime *timing.MarketTime) *IntelligentLimiter <span class="cov0" title="0">{
        return &amp;IntelligentLimiter{
                classifier:      NewErrorClassifier(),
                marketTime:      marketTime,
                consecutiveSame: 0,
                lastData:        "",
                currentBatch:    []string{},
                isInitialized:   false,
        }
}</span>

// InitializeBatch 初始化批次信息
func (l *IntelligentLimiter) InitializeBatch(symbols []string) <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()

        l.currentBatch = symbols
        l.retryCount = 0
        l.lastError = nil
        l.consecutiveSame = 0
        l.lastData = ""
        l.isInitialized = true
        l.forceStopFlag = false
        l.tradingEnd = l.marketTime.GetTradingEndTime()

        // 预检查时间有效性
        if !l.marketTime.IsTradingTime() </span><span class="cov0" title="0">{
                l.forceStopFlag = true
                l.lastError = errors.New("当前不在交易时段内，自动停止")
        }</span>
}

// ShouldProceed 判断是否可以继续进行API调用
func (l *IntelligentLimiter) ShouldProceed(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        l.mu.RLock()
        defer l.mu.RUnlock()

        if !l.isInitialized </span><span class="cov0" title="0">{
                return false, errors.New("熔断器尚未初始化（请先调用InitializeBatch）")
        }</span>

        // 强制停止标志
        <span class="cov0" title="0">if l.forceStopFlag </span><span class="cov0" title="0">{
                return false, l.lastError
        }</span>

        // 交易时间检查
        <span class="cov0" title="0">if !l.marketTime.IsTradingTime() </span><span class="cov0" title="0">{
                return false, errors.New("交易时段已结束，停止监控")
        }</span>

        // 重试次数检查
        <span class="cov0" title="0">if l.retryCount &gt;= MaxRetries &amp;&amp; l.lastError != nil </span><span class="cov0" title="0">{
                return false, errors.New("已达到最大重试次数，停止此次操作")
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

// RecordResult 记录批处理结果，供熔断器判断下一步行动
func (l *IntelligentLimiter) RecordResult(err error, data []string) (
        shouldContinue bool,
        waitingDuration time.Duration,
        finalError error) <span class="cov0" title="0">{

        l.mu.Lock()
        defer l.mu.Unlock()

        l.lastRequestTime = time.Now()
        l.totalRequests++

        // 成功情况
        if err == nil </span><span class="cov0" title="0">{
                l.totalErrors = 0
                l.lastError = nil

                // 始终记录数据指纹，但只在收盘后才检查一致性
                if len(data) &gt; 0 </span><span class="cov0" title="0">{
                        dataFingerprint := l.generateDataFingerprint(data)

                        // 收盘后检查数据一致性（避免数据延迟问题）
                        if l.marketTime.IsAfterTradingEnd() </span><span class="cov0" title="0">{
                                if dataFingerprint == l.lastData </span><span class="cov0" title="0">{
                                        l.consecutiveSame++
                                        if l.consecutiveSame &gt;= 5 </span><span class="cov0" title="0">{
                                                // 数据已稳定5次，可以终止
                                                return false, 0, errors.New("收盘后数据已稳定，终止收集")
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        l.consecutiveSame = 1
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // 交易时段内，只更新数据不检查一致性
                                if dataFingerprint != l.lastData </span><span class="cov0" title="0">{
                                        l.consecutiveSame = 1
                                }</span> else<span class="cov0" title="0"> {
                                        l.consecutiveSame++
                                }</span>
                        }

                        <span class="cov0" title="0">l.lastData = dataFingerprint</span>
                }

                <span class="cov0" title="0">return true, 0, nil</span>
        }

        // 错误情况处理
        <span class="cov0" title="0">l.totalErrors++
        l.lastError = err

        // 错误分级
        level := l.classifier.Classify(err)

        switch level </span>{
        case LevelFatal:<span class="cov0" title="0"> // 致命级错误
                l.forceStopFlag = true
                return false, 0, errors.New("致命错误: " + err.Error())</span>

        case LevelNetwork:<span class="cov0" title="0"> // 网络错误，进行重试
                shouldRetry, waitDuration := l.classifier.GetRetryStrategy(level, l.retryCount)

                if !shouldRetry </span><span class="cov0" title="0">{
                        return false, 0, errors.New("网络错误重试次数耗尽: " + err.Error())
                }</span>

                // 检查重试时间是否在有效范围内
                <span class="cov0" title="0">nextRetryTime := l.marketTime.Now().Add(waitDuration)
                if !l.classifier.IsRetryAllowedInTime(nextRetryTime, l.tradingEnd) </span><span class="cov0" title="0">{
                        return false, 0, errors.New("重试时间超出交易时段，终止操作")
                }</span>

                <span class="cov0" title="0">l.retryCount++
                return false, waitDuration, nil</span>

        case LevelInvalid, LevelUnknown:<span class="cov0" title="0">
                // 无效参数或未知错误，不重试
                return false, 0, errors.New("不可重试错误: " + err.Error())</span>

        default:<span class="cov0" title="0">
                return false, 0, errors.New("未知错误类型: " + err.Error())</span>
        }
}

// generateDataFingerprint 为数据生成简单的指纹标识
func (l *IntelligentLimiter) generateDataFingerprint(data []string) string <span class="cov0" title="0">{
        // 简单的数据指纹生成 - 基于字符串内容
        if len(data) == 0 </span><span class="cov0" title="0">{
                return "empty"
        }</span>

        // 这里使用字符串拼接作为简单指纹
        // 在生产环境中可以改进为更复杂的校验
        <span class="cov0" title="0">fingerprint := ""
        for _, item := range data </span><span class="cov0" title="0">{
                if len(item) &gt; 5 </span><span class="cov0" title="0">{
                        fingerprint += item[:5] // 取前5个字符
                }</span> else<span class="cov0" title="0"> {
                        fingerprint += item
                }</span>
        }

        <span class="cov0" title="0">if len(fingerprint) &gt; 50 </span><span class="cov0" title="0">{
                return fingerprint[:50]
        }</span>
        <span class="cov0" title="0">return fingerprint</span>
}

// GetStatus 获取熔断器当前状态
func (l *IntelligentLimiter) GetStatus() map[string]interface{} <span class="cov0" title="0">{
        l.mu.RLock()
        defer l.mu.RUnlock()

        return map[string]interface{}{
                "is_initialized":       l.isInitialized,
                "current_batch":        len(l.currentBatch),
                "retry_count":          l.retryCount,
                "has_last_error":       l.lastError != nil,
                "consecutive_same":     l.consecutiveSame,
                "force_stop":           l.forceStopFlag,
                "last_request_time":    l.lastRequestTime,
                "in_trading_time":      l.marketTime.IsTradingTime(),
                "is_close_to_end":      l.marketTime.IsCloseToEnd(),
                "is_after_trading_end": l.marketTime.IsAfterTradingEnd(),
                "total_requests":       l.totalRequests,
                "estimated_end":        l.marketTime.GetTradingEndTime(),
        }
}</span>

// IsSafeToContinue 检查是否安全继续
func (l *IntelligentLimiter) IsSafeToContinue() bool <span class="cov0" title="0">{
        l.mu.RLock()
        defer l.mu.RUnlock()

        if !l.isInitialized </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return !l.forceStopFlag &amp;&amp; l.marketTime.IsTradingTime()</span>
}

// Reset 重置熔断器状态（测试用）
func (l *IntelligentLimiter) Reset() <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()

        l.retryCount = 0
        l.lastError = nil
        l.consecutiveSame = 0
        l.lastData = ""
        l.forceStopFlag = false
        l.totalRequests = 0
        l.totalErrors = 0
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package logger

import (
        "os"
        "strings"

        "github.com/sirupsen/logrus"
)

var (
        // Logger 全局日志实例
        Logger *logrus.Logger
)

// Config 日志配置
type Config struct {
        Level  string `json:"level"`  // debug, info, warn, error
        Format string `json:"format"` // text, json
}

// Init 初始化日志器
func Init(config Config) <span class="cov0" title="0">{
        Logger = logrus.New()

        // 设置日志级别
        level, err := logrus.ParseLevel(config.Level)
        if err != nil </span><span class="cov0" title="0">{
                level = logrus.InfoLevel
        }</span>
        <span class="cov0" title="0">Logger.SetLevel(level)

        // 设置格式
        if config.Format == "json" </span><span class="cov0" title="0">{
                Logger.SetFormatter(&amp;logrus.JSONFormatter{
                        TimestampFormat: "2006-01-02 15:04:05.000",
                })
        }</span> else<span class="cov0" title="0"> {
                Logger.SetFormatter(&amp;logrus.TextFormatter{
                        TimestampFormat: "2006-01-02 15:04:05.000",
                        FullTimestamp:   true,
                        ForceColors:     true,
                })
        }</span>

        <span class="cov0" title="0">Logger.SetOutput(os.Stdout)</span>
}

// InitFromEnv 从环境变量初始化日志器
func InitFromEnv() <span class="cov0" title="0">{
        level := os.Getenv("LOG_LEVEL")
        if level == "" </span><span class="cov0" title="0">{
                if os.Getenv("DEBUG") == "1" </span><span class="cov0" title="0">{
                        level = "debug"
                }</span> else<span class="cov0" title="0"> {
                        level = "info"
                }</span>
        }

        <span class="cov0" title="0">format := os.Getenv("LOG_FORMAT")
        if format == "" </span><span class="cov0" title="0">{
                format = "text"
        }</span>

        <span class="cov0" title="0">Init(Config{
                Level:  level,
                Format: format,
        })</span>
}

// GetLogger 获取日志器实例
func GetLogger() *logrus.Logger <span class="cov0" title="0">{
        if Logger == nil </span><span class="cov0" title="0">{
                InitFromEnv()
        }</span>
        <span class="cov0" title="0">return Logger</span>
}

// WithComponent 创建带组件名的日志器
func WithComponent(component string) *logrus.Entry <span class="cov0" title="0">{
        return GetLogger().WithField("component", component)
}</span>

// Debug 调试日志
func Debug(args ...interface{}) <span class="cov0" title="0">{
        GetLogger().Debug(args...)
}</span>

// Debugf 格式化调试日志
func Debugf(format string, args ...interface{}) <span class="cov0" title="0">{
        GetLogger().Debugf(format, args...)
}</span>

// Info 信息日志
func Info(args ...interface{}) <span class="cov0" title="0">{
        GetLogger().Info(args...)
}</span>

// Infof 格式化信息日志
func Infof(format string, args ...interface{}) <span class="cov0" title="0">{
        GetLogger().Infof(format, args...)
}</span>

// Warn 警告日志
func Warn(args ...interface{}) <span class="cov0" title="0">{
        GetLogger().Warn(args...)
}</span>

// Warnf 格式化警告日志
func Warnf(format string, args ...interface{}) <span class="cov0" title="0">{
        GetLogger().Warnf(format, args...)
}</span>

// Error 错误日志
func Error(args ...interface{}) <span class="cov0" title="0">{
        GetLogger().Error(args...)
}</span>

// Errorf 格式化错误日志
func Errorf(format string, args ...interface{}) <span class="cov0" title="0">{
        GetLogger().Errorf(format, args...)
}</span>

// SetLevel 设置日志级别
func SetLevel(level string) <span class="cov0" title="0">{
        l, err := logrus.ParseLevel(strings.ToLower(level))
        if err != nil </span><span class="cov0" title="0">{
                l = logrus.InfoLevel
        }</span>
        <span class="cov0" title="0">GetLogger().SetLevel(l)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package tencent

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "os"
        "strings"
        "sync"
        "time"

        "stocksub/pkg/logger"
        "stocksub/pkg/subscriber"

        "github.com/sirupsen/logrus"
)

// Provider 腾讯数据提供商
type Provider struct {
        httpClient  *http.Client
        lastRequest time.Time
        requestMu   sync.Mutex
        rateLimit   time.Duration
        maxRetries  int
        userAgent   string
        log         *logrus.Entry
}

// NewProvider 创建腾讯数据提供商
func NewProvider() *Provider <span class="cov0" title="0">{
        return &amp;Provider{
                httpClient: &amp;http.Client{
                        Transport: &amp;http.Transport{
                                MaxIdleConns:        100,
                                MaxIdleConnsPerHost: 10,
                                IdleConnTimeout:     30 * time.Second,
                                DisableKeepAlives:   false,
                                MaxConnsPerHost:     10,
                        },
                        Timeout: 15 * time.Second,
                },
                rateLimit:  200 * time.Millisecond,
                maxRetries: 3,
                userAgent:  "StockSub/1.0",
                log:        logger.WithComponent("TencentProvider"),
        }
}</span>

// Name 返回提供商名称
func (p *Provider) Name() string <span class="cov0" title="0">{
        return "tencent"
}</span>

// FetchData 获取股票数据
func (p *Provider) FetchData(ctx context.Context, symbols []string) ([]subscriber.StockData, error) <span class="cov0" title="0">{
        result, _, err := p.FetchDataWithRaw(ctx, symbols)
        return result, err
}</span>

// FetchDataWithRaw 获取股票数据和原始响应数据
func (p *Provider) FetchDataWithRaw(ctx context.Context, symbols []string) ([]subscriber.StockData, string, error) <span class="cov0" title="0">{
        debugMode := os.Getenv("DEBUG") == "1"

        if len(symbols) == 0 </span><span class="cov0" title="0">{
                return []subscriber.StockData{}, "", nil
        }</span>

        <span class="cov0" title="0">if debugMode </span><span class="cov0" title="0">{
                p.log.Debugf("Starting FetchDataWithRaw for symbols: %v", symbols)
        }</span>

        // 限流控制
        <span class="cov0" title="0">if err := p.enforceRateLimit(); err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov0" title="0">url := p.buildURL(symbols)
        if debugMode </span><span class="cov0" title="0">{
                p.log.Debugf("Request URL: %s", url)
        }</span>

        <span class="cov0" title="0">var lastErr error
        for i := 0; i &lt; p.maxRetries; i++ </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        if debugMode </span><span class="cov0" title="0">{
                                p.log.Debugf("Retry attempt %d/%d", i+1, p.maxRetries)
                        }</span>
                        <span class="cov0" title="0">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return nil, "", ctx.Err()</span>
                        case &lt;-time.After(time.Duration(i) * time.Second):<span class="cov0" title="0"></span>
                        }
                }

                <span class="cov0" title="0">requestStart := time.Now()
                req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        lastErr = fmt.Errorf("create request failed: %w", err)
                        if debugMode </span><span class="cov0" title="0">{
                                p.log.Errorf("Request creation failed: %v", lastErr)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">req.Header.Set("User-Agent", p.userAgent)

                resp, err := p.httpClient.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        lastErr = fmt.Errorf("HTTP request failed: %w", err)
                        if debugMode </span><span class="cov0" title="0">{
                                p.log.Errorf("HTTP request failed after %v: %v", time.Since(requestStart), lastErr)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
                resp.Body.Close()

                if err != nil </span><span class="cov0" title="0">{
                        lastErr = fmt.Errorf("read response failed: %w", err)
                        if debugMode </span><span class="cov0" title="0">{
                                p.log.Errorf("Response read failed: %v", lastErr)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">requestDuration := time.Since(requestStart)
                if debugMode </span><span class="cov0" title="0">{
                        p.log.Debugf("HTTP request completed in %v, status: %d, body length: %d",
                                requestDuration, resp.StatusCode, len(body))
                }</span>

                <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                        lastErr = fmt.Errorf("HTTP status error: %d", resp.StatusCode)
                        if debugMode </span><span class="cov0" title="0">{
                                p.log.Errorf("HTTP status error: %d", resp.StatusCode)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">if len(body) == 0 </span><span class="cov0" title="0">{
                        lastErr = fmt.Errorf("empty response")
                        if debugMode </span><span class="cov0" title="0">{
                                p.log.Warnf("Empty response received")
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">rawData := string(body)

                if debugMode </span><span class="cov0" title="0">{
                        p.log.Debugf("Parsing response data...")
                }</span>
                <span class="cov0" title="0">parseStart := time.Now()
                result := parseTencentData(rawData)
                parseTime := time.Since(parseStart)

                if debugMode </span><span class="cov0" title="0">{
                        p.log.Infof("Parsing completed in %v, parsed %d records", parseTime, len(result))
                }</span>

                <span class="cov0" title="0">return result, rawData, nil</span>
        }

        <span class="cov0" title="0">return nil, "", fmt.Errorf("failed after %d retries: %v", p.maxRetries, lastErr)</span>
}

// IsSymbolSupported 检查是否支持该股票代码
func (p *Provider) IsSymbolSupported(symbol string) bool <span class="cov0" title="0">{
        if symbol == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        // A股上证
        <span class="cov0" title="0">if len(symbol) == 6 &amp;&amp; (strings.HasPrefix(symbol, "6")) </span><span class="cov0" title="0">{
                return true
        }</span>

        // A股深证
        <span class="cov0" title="0">if len(symbol) == 6 &amp;&amp; (strings.HasPrefix(symbol, "0") ||
                strings.HasPrefix(symbol, "300")) </span><span class="cov0" title="0">{
                return true
        }</span>

        // A股北交所
        <span class="cov0" title="0">if len(symbol) == 6 &amp;&amp; (strings.HasPrefix(symbol, "43") ||
                strings.HasPrefix(symbol, "82") || strings.HasPrefix(symbol, "83") ||
                strings.HasPrefix(symbol, "87") || strings.HasPrefix(symbol, "920")) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// GetRateLimit 获取请求限制信息
func (p *Provider) GetRateLimit() time.Duration <span class="cov0" title="0">{
        return p.rateLimit
}</span>

// SetRateLimit 设置请求频率限制
func (p *Provider) SetRateLimit(limit time.Duration) <span class="cov0" title="0">{
        p.rateLimit = limit
}</span>

// SetMaxRetries 设置最大重试次数
func (p *Provider) SetMaxRetries(retries int) <span class="cov0" title="0">{
        p.maxRetries = retries
}</span>

// SetTimeout 设置超时时间
func (p *Provider) SetTimeout(timeout time.Duration) <span class="cov0" title="0">{
        p.httpClient.Timeout = timeout
}</span>

// enforceRateLimit 执行频率限制
func (p *Provider) enforceRateLimit() error <span class="cov0" title="0">{
        p.requestMu.Lock()
        defer p.requestMu.Unlock()

        elapsed := time.Since(p.lastRequest)
        if elapsed &lt; p.rateLimit &amp;&amp; !p.lastRequest.IsZero() </span><span class="cov0" title="0">{
                waitTime := p.rateLimit - elapsed
                time.Sleep(waitTime)
        }</span>
        <span class="cov0" title="0">p.lastRequest = time.Now()

        return nil</span>
}

// buildURL 构建腾讯行情URL
func (p *Provider) buildURL(symbols []string) string <span class="cov0" title="0">{
        var parts []string
        for _, symbol := range symbols </span><span class="cov0" title="0">{
                prefix := p.getMarketPrefix(symbol)
                parts = append(parts, prefix+symbol)
        }</span>

        <span class="cov0" title="0">return "http://qt.gtimg.cn/q=" + strings.Join(parts, ",")</span>
}

// getMarketPrefix 根据股票代码获取市场前缀
func (p *Provider) getMarketPrefix(symbol string) string <span class="cov0" title="0">{
        switch </span>{
        case strings.HasPrefix(symbol, "6") || strings.HasPrefix(symbol, "5"):<span class="cov0" title="0">
                return "sh"</span>
        case strings.HasPrefix(symbol, "0") || strings.HasPrefix(symbol, "3"):<span class="cov0" title="0">
                return "sz"</span>
        case strings.HasPrefix(symbol, "4") || strings.HasPrefix(symbol, "8"):<span class="cov0" title="0">
                return "bj"</span>
        default:<span class="cov0" title="0">
                return "sh"</span> // 默认使用上海市场前缀
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package tencent

import (
        "io"
        "strconv"
        "strings"
        "time"

        "stocksub/pkg/subscriber"

        "golang.org/x/text/encoding/simplifiedchinese"
        "golang.org/x/text/transform"
)

// gbkToUtf8 将GBK编码转换为UTF-8
func gbkToUtf8(gbkStr string) string <span class="cov0" title="0">{
        if gbkStr == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">reader := transform.NewReader(strings.NewReader(gbkStr), simplifiedchinese.GBK.NewDecoder())
        data, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                return gbkStr
        }</span>

        <span class="cov0" title="0">return string(data)</span>
}

// parseTencentData 解析腾讯返回的数据
func parseTencentData(data string) []subscriber.StockData <span class="cov0" title="0">{
        if data == "" </span><span class="cov0" title="0">{
                return []subscriber.StockData{}
        }</span>

        <span class="cov0" title="0">data = strings.TrimSpace(data)
        stocks := strings.Split(data, ";")
        results := make([]subscriber.StockData, 0, len(stocks))

        for _, stock := range stocks </span><span class="cov0" title="0">{
                stock = strings.TrimSpace(stock)
                if stock == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">equalIndex := strings.Index(stock, "=")
                if equalIndex == -1 || equalIndex+1 &gt;= len(stock) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">dataPart := stock[equalIndex+1:]
                dataPart = strings.Trim(dataPart, "\"")
                fields := strings.Split(dataPart, "~")

                if len(fields) &lt; 50 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">stockData := subscriber.StockData{
                        // 基本信息
                        Symbol:        extractSymbol(fields[2]),
                        Name:          gbkToUtf8(fields[1]),
                        Price:         parseFloat(fields[3]),
                        Change:        parseFloat(fields[31]),
                        ChangePercent: parseFloat(fields[32]),
                        MarketCode:    parseInt(fields[0]), // 市场分类代码

                        // 交易数据
                        Volume:    parseInt(fields[6]),       // 成交量(手)
                        Turnover:  parseTurnover(fields[35]), // 从最新价/成交量(手)/成交额(元)格式中提取成交额
                        Open:      parseFloat(fields[5]),
                        High:      parseFloat(fields[33]),
                        Low:       parseFloat(fields[34]),
                        PrevClose: parseFloat(fields[4]),

                        // 5档买卖盘数据
                        BidPrice1:  parseFloat(fields[9]),
                        BidVolume1: parseInt(fields[10]), // 买一量(手)
                        BidPrice2:  parseFloat(fields[11]),
                        BidVolume2: parseInt(fields[12]), // 买二量(手)
                        BidPrice3:  parseFloat(fields[13]),
                        BidVolume3: parseInt(fields[14]), // 买三量(手)
                        BidPrice4:  parseFloat(fields[15]),
                        BidVolume4: parseInt(fields[16]), // 买四量(手)
                        BidPrice5:  parseFloat(fields[17]),
                        BidVolume5: parseInt(fields[18]), // 买五量(手)
                        AskPrice1:  parseFloat(fields[19]),
                        AskVolume1: parseInt(fields[20]), // 卖一量(手)
                        AskPrice2:  parseFloat(fields[21]),
                        AskVolume2: parseInt(fields[22]), // 卖二量(手)
                        AskPrice3:  parseFloat(fields[23]),
                        AskVolume3: parseInt(fields[24]), // 卖三量(手)
                        AskPrice4:  parseFloat(fields[25]),
                        AskVolume4: parseInt(fields[26]), // 卖四量(手)
                        AskPrice5:  parseFloat(fields[27]),
                        AskVolume5: parseInt(fields[28]), // 卖五量(手)

                        // 内外盘数据
                        OuterDisc: parseInt(fields[7]), // 外盘(手)
                        InnerDisc: parseInt(fields[8]), // 内盘(手)

                        // 财务指标
                        TurnoverRate: parseFloat(fields[38]), // 换手率
                        PE:           parseFloat(fields[39]), // 市盈率
                        PB:           parseFloat(fields[46]), // 市净率
                        Amplitude:    parseFloat(fields[43]), // 振幅
                        Circulation:  parseFloat(fields[44]), // 流通市值(亿)
                        MarketValue:  parseFloat(fields[45]), // 总市值(亿)
                        LimitUp:      parseFloat(fields[47]), // 涨停价
                        LimitDown:    parseFloat(fields[48]), // 跌停价

                        // 时间信息
                        Timestamp: parseTime(fields[30]),
                }

                // 单位转换（A股数据从手转换为股）
                // fields[0]: 1-科创板+上海主板, 51-创业板+深圳主板, 62-北交所
                // 所有A股市场：成交量和买卖盘口数据都需要从手转换为股
                // stockData.Volume *= 100
                // stockData.BidVolume1 *= 100
                // stockData.BidVolume2 *= 100
                // stockData.BidVolume3 *= 100
                // stockData.BidVolume4 *= 100
                // stockData.BidVolume5 *= 100
                // stockData.AskVolume1 *= 100
                // stockData.AskVolume2 *= 100
                // stockData.AskVolume3 *= 100
                // stockData.AskVolume4 *= 100
                // stockData.AskVolume5 *= 100
                // stockData.InnerDisc *= 100
                // stockData.OuterDisc *= 100

                results = append(results, stockData)</span>
        }

        <span class="cov0" title="0">return results</span>
}

// extractSymbol 从股票代码中提取纯符号
func extractSymbol(rawSymbol string) string <span class="cov0" title="0">{
        rawSymbol = strings.TrimPrefix(rawSymbol, "sh")
        rawSymbol = strings.TrimPrefix(rawSymbol, "sz")
        rawSymbol = strings.TrimPrefix(rawSymbol, "bj")

        if dotIndex := strings.Index(rawSymbol, "."); dotIndex != -1 </span><span class="cov0" title="0">{
                rawSymbol = rawSymbol[:dotIndex]
        }</span>

        <span class="cov0" title="0">return rawSymbol</span>
}

// parseFloat 安全解析浮点数
func parseFloat(s string) float64 <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">val, err := strconv.ParseFloat(s, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return val</span>
}

// parseInt 安全解析整数
func parseInt(s string) int64 <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">val, err := strconv.ParseInt(s, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return val</span>
}

// parseTime 解析时间戳
func parseTime(timeStr string) time.Time <span class="cov10" title="5">{
        if len(timeStr) &lt; 12 </span><span class="cov4" title="2">{
                return time.Now()
        }</span>

        <span class="cov7" title="3">var layout string
        if len(timeStr) == 14 </span><span class="cov1" title="1">{
                layout = "20060102150405"
        }</span> else<span class="cov4" title="2"> if len(timeStr) == 12 </span><span class="cov1" title="1">{
                layout = "200601021504"
        }</span> else<span class="cov1" title="1"> {
                return time.Now()
        }</span>

        <span class="cov4" title="2">t, err := time.ParseInLocation(layout, timeStr, time.Local)
        if err != nil </span><span class="cov0" title="0">{
                return time.Now()
        }</span>

        <span class="cov4" title="2">return t</span>
}

// parseTurnover 从复合字段中提取成交额
func parseTurnover(s string) float64 <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">parts := strings.Split(s, "/")
        if len(parts) &gt;= 3 </span><span class="cov0" title="0">{
                val, err := strconv.ParseFloat(parts[2], 64)
                if err != nil </span><span class="cov0" title="0">{
                        return 0
                }</span>
                <span class="cov0" title="0">return val</span>
        }

        <span class="cov0" title="0">val, err := strconv.ParseFloat(s, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return val</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package subscriber

// ErrorCode 错误代码类型
type ErrorCode string

// 错误代码常量
const (
        ErrInvalidFieldType      ErrorCode = "INVALID_FIELD_TYPE"
        ErrRequiredFieldMissing  ErrorCode = "REQUIRED_FIELD_MISSING"
        ErrFieldValidationFailed ErrorCode = "FIELD_VALIDATION_FAILED"
        ErrSchemaNotFound        ErrorCode = "SCHEMA_NOT_FOUND"
        ErrCSVHeaderMismatch     ErrorCode = "CSV_HEADER_MISMATCH"
        ErrFieldNotFound         ErrorCode = "FIELD_NOT_FOUND"
)

// StructuredDataError 结构化数据相关错误
type StructuredDataError struct {
        Code    ErrorCode `json:"code"`
        Field   string    `json:"field"`
        Message string    `json:"message"`
        Cause   error     `json:"cause,omitempty"`
}

// Error 实现 error 接口
func (e *StructuredDataError) Error() string <span class="cov6" title="8">{
        if e.Field != "" </span><span class="cov4" title="4">{
                return string(e.Code) + ": " + e.Field + " - " + e.Message
        }</span>
        <span class="cov4" title="4">return string(e.Code) + ": " + e.Message</span>
}

// NewStructuredDataError 创建新的结构化数据错误
func NewStructuredDataError(code ErrorCode, field, message string) *StructuredDataError <span class="cov10" title="41">{
        return &amp;StructuredDataError{
                Code:    code,
                Field:   field,
                Message: message,
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package subscriber

import (
        "context"
        "fmt"
        "log"
        "sync"
        "time"
)

// Manager 订阅管理器，提供高级订阅管理功能
type Manager struct {
        subscriber *DefaultSubscriber
        config     *ManagerConfig
        stats      *Statistics
        statsMu    sync.RWMutex
}

// ManagerConfig 管理器配置
type ManagerConfig struct {
        AutoRestart         bool          // 自动重启失败的订阅
        HealthCheckInterval time.Duration // 健康检查间隔
        MaxFailures         int           // 最大失败次数
        FailureWindow       time.Duration // 失败窗口时间
}

// Statistics 统计信息
type Statistics struct {
        TotalSubscriptions  int                  `json:"total_subscriptions"`
        ActiveSubscriptions int                  `json:"active_subscriptions"`
        TotalDataPoints     int64                `json:"total_data_points"`
        TotalErrors         int64                `json:"total_errors"`
        SubscriptionStats   map[string]*SubStats `json:"subscription_stats"`
        ProviderStats       *ProviderStats       `json:"provider_stats"`
        StartTime           time.Time            `json:"start_time"`
        LastUpdateTime      time.Time            `json:"last_update_time"`
}

// SubStats 单个订阅统计
type SubStats struct {
        Symbol          string        `json:"symbol"`
        SubscribedAt    time.Time     `json:"subscribed_at"`
        LastDataTime    time.Time     `json:"last_data_time"`
        DataPointCount  int64         `json:"data_point_count"`
        ErrorCount      int64         `json:"error_count"`
        AverageInterval time.Duration `json:"average_interval"`
        LastError       string        `json:"last_error,omitempty"`
        LastErrorTime   time.Time     `json:"last_error_time,omitempty"`
        IsHealthy       bool          `json:"is_healthy"`
}

// ProviderStats 提供商统计
type ProviderStats struct {
        Name            string        `json:"name"`
        TotalRequests   int64         `json:"total_requests"`
        SuccessfulReqs  int64         `json:"successful_requests"`
        FailedRequests  int64         `json:"failed_requests"`
        AverageLatency  time.Duration `json:"average_latency"`
        LastRequestTime time.Time     `json:"last_request_time"`
}

// NewManager 创建订阅管理器
func NewManager(subscriber *DefaultSubscriber) *Manager <span class="cov0" title="0">{
        config := &amp;ManagerConfig{
                AutoRestart:         true,
                HealthCheckInterval: 30 * time.Second,
                MaxFailures:         5,
                FailureWindow:       5 * time.Minute,
        }

        stats := &amp;Statistics{
                SubscriptionStats: make(map[string]*SubStats),
                ProviderStats:     &amp;ProviderStats{},
                StartTime:         time.Now(),
        }

        return &amp;Manager{
                subscriber: subscriber,
                config:     config,
                stats:      stats,
        }
}</span>

// Start 启动管理器
func (m *Manager) Start(ctx context.Context) error <span class="cov0" title="0">{
        // 启动订阅器
        if err := m.subscriber.Start(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start subscriber: %w", err)
        }</span>

        // 启动统计收集
        <span class="cov0" title="0">go m.runStatisticsCollector(ctx)

        // 启动健康检查
        go m.runHealthChecker(ctx)

        // 启动事件处理
        go m.runEventProcessor(ctx)

        log.Printf("[Manager] Started with config: AutoRestart=%v, HealthCheckInterval=%v",
                m.config.AutoRestart, m.config.HealthCheckInterval)

        return nil</span>
}

// Stop 停止管理器
func (m *Manager) Stop() error <span class="cov0" title="0">{
        return m.subscriber.Stop()
}</span>

// Subscribe 订阅股票（增强版）
func (m *Manager) Subscribe(symbol string, interval time.Duration, callback CallbackFunc) error <span class="cov0" title="0">{
        err := m.subscriber.Subscribe(symbol, interval, callback)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 初始化统计信息
        <span class="cov0" title="0">m.statsMu.Lock()
        m.stats.SubscriptionStats[symbol] = &amp;SubStats{
                Symbol:       symbol,
                SubscribedAt: time.Now(),
                IsHealthy:    true,
        }
        m.stats.TotalSubscriptions++
        m.stats.ActiveSubscriptions++
        m.statsMu.Unlock()

        log.Printf("[Manager] Successfully subscribed to %s with interval %v", symbol, interval)
        return nil</span>
}

// Unsubscribe 取消订阅（增强版）
func (m *Manager) Unsubscribe(symbol string) error <span class="cov0" title="0">{
        err := m.subscriber.Unsubscribe(symbol)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 清理统计信息
        <span class="cov0" title="0">m.statsMu.Lock()
        delete(m.stats.SubscriptionStats, symbol)
        if m.stats.ActiveSubscriptions &gt; 0 </span><span class="cov0" title="0">{
                m.stats.ActiveSubscriptions--
        }</span>
        <span class="cov0" title="0">m.statsMu.Unlock()

        log.Printf("[Manager] Successfully unsubscribed from %s", symbol)
        return nil</span>
}

// SubscribeBatch 批量订阅
func (m *Manager) SubscribeBatch(requests []SubscribeRequest) error <span class="cov0" title="0">{
        var errors []error

        for _, req := range requests </span><span class="cov0" title="0">{
                if err := m.Subscribe(req.Symbol, req.Interval, req.Callback); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("failed to subscribe %s: %w", req.Symbol, err))
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("batch subscription failed: %v", errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UnsubscribeBatch 批量取消订阅
func (m *Manager) UnsubscribeBatch(symbols []string) error <span class="cov0" title="0">{
        var errors []error

        for _, symbol := range symbols </span><span class="cov0" title="0">{
                if err := m.Unsubscribe(symbol); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("failed to unsubscribe %s: %w", symbol, err))
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("batch unsubscription failed: %v", errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetStatistics 获取统计信息
func (m *Manager) GetStatistics() Statistics <span class="cov0" title="0">{
        m.statsMu.RLock()
        defer m.statsMu.RUnlock()

        // 深拷贝统计信息
        stats := *m.stats
        stats.SubscriptionStats = make(map[string]*SubStats)
        for k, v := range m.stats.SubscriptionStats </span><span class="cov0" title="0">{
                statsCopy := *v
                stats.SubscriptionStats[k] = &amp;statsCopy
        }</span>

        <span class="cov0" title="0">if m.stats.ProviderStats != nil </span><span class="cov0" title="0">{
                providerStats := *m.stats.ProviderStats
                stats.ProviderStats = &amp;providerStats
        }</span>

        <span class="cov0" title="0">return stats</span>
}

// GetSubscriptions 获取订阅列表
func (m *Manager) GetSubscriptions() []Subscription <span class="cov0" title="0">{
        return m.subscriber.GetSubscriptions()
}</span>

// runStatisticsCollector 运行统计收集器
func (m *Manager) runStatisticsCollector(ctx context.Context) <span class="cov0" title="0">{
        ticker := time.NewTicker(5 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        m.updateStatistics()</span>
                }
        }
}

// runHealthChecker 运行健康检查
func (m *Manager) runHealthChecker(ctx context.Context) <span class="cov0" title="0">{
        ticker := time.NewTicker(m.config.HealthCheckInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        m.performHealthCheck()</span>
                }
        }
}

// runEventProcessor 运行事件处理器
func (m *Manager) runEventProcessor(ctx context.Context) <span class="cov0" title="0">{
        eventChan := m.subscriber.GetEventChannel()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case event, ok := &lt;-eventChan:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">m.processEvent(event)</span>
                }
        }
}

// processEvent 处理事件
func (m *Manager) processEvent(event UpdateEvent) <span class="cov0" title="0">{
        m.statsMu.Lock()
        defer m.statsMu.Unlock()

        stats, exists := m.stats.SubscriptionStats[event.Symbol]
        if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">switch event.Type </span>{
        case EventTypeData:<span class="cov0" title="0">
                stats.DataPointCount++
                stats.LastDataTime = event.Time
                stats.IsHealthy = true
                m.stats.TotalDataPoints++</span>

        case EventTypeError:<span class="cov0" title="0">
                stats.ErrorCount++
                stats.IsHealthy = false
                if event.Error != nil </span><span class="cov0" title="0">{
                        stats.LastError = event.Error.Error()
                        stats.LastErrorTime = event.Time
                }</span>
                <span class="cov0" title="0">m.stats.TotalErrors++

                // 自动重启逻辑
                if m.config.AutoRestart &amp;&amp; stats.ErrorCount &gt;= int64(m.config.MaxFailures) </span><span class="cov0" title="0">{
                        go m.attemptRestart(event.Symbol)
                }</span>
        }

        <span class="cov0" title="0">m.stats.LastUpdateTime = event.Time</span>
}

// updateStatistics 更新统计信息
func (m *Manager) updateStatistics() <span class="cov0" title="0">{
        subscriptions := m.subscriber.GetSubscriptions()

        m.statsMu.Lock()
        m.stats.ActiveSubscriptions = len(subscriptions)
        m.statsMu.Unlock()
}</span>

// performHealthCheck 执行健康检查
func (m *Manager) performHealthCheck() <span class="cov0" title="0">{
        m.statsMu.RLock()
        unhealthySymbols := make([]string, 0)

        for symbol, stats := range m.stats.SubscriptionStats </span><span class="cov0" title="0">{
                // 检查是否长时间没有数据更新
                if time.Since(stats.LastDataTime) &gt; 2*m.config.HealthCheckInterval </span><span class="cov0" title="0">{
                        stats.IsHealthy = false
                        unhealthySymbols = append(unhealthySymbols, symbol)
                }</span>
        }
        <span class="cov0" title="0">m.statsMu.RUnlock()

        if len(unhealthySymbols) &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("[Manager] Health check found %d unhealthy subscriptions: %v",
                        len(unhealthySymbols), unhealthySymbols)
        }</span>
}

// attemptRestart 尝试重启订阅
func (m *Manager) attemptRestart(symbol string) <span class="cov0" title="0">{
        log.Printf("[Manager] Attempting to restart subscription for %s", symbol)

        // 获取当前订阅信息
        subscriptions := m.subscriber.GetSubscriptions()
        var targetSub *Subscription
        for _, sub := range subscriptions </span><span class="cov0" title="0">{
                if sub.Symbol == symbol </span><span class="cov0" title="0">{
                        targetSub = &amp;sub
                        break</span>
                }
        }

        <span class="cov0" title="0">if targetSub == nil </span><span class="cov0" title="0">{
                log.Printf("[Manager] Cannot restart %s: subscription not found", symbol)
                return
        }</span>

        // 取消并重新订阅
        <span class="cov0" title="0">if err := m.subscriber.Unsubscribe(symbol); err != nil </span><span class="cov0" title="0">{
                log.Printf("[Manager] Failed to unsubscribe %s for restart: %v", symbol, err)
                return
        }</span>

        <span class="cov0" title="0">time.Sleep(1 * time.Second) // 短暂等待

        if err := m.subscriber.Subscribe(symbol, targetSub.Interval, targetSub.Callback); err != nil </span><span class="cov0" title="0">{
                log.Printf("[Manager] Failed to restart subscription for %s: %v", symbol, err)
                return
        }</span>

        // 重置错误计数
        <span class="cov0" title="0">m.statsMu.Lock()
        if stats, exists := m.stats.SubscriptionStats[symbol]; exists </span><span class="cov0" title="0">{
                stats.ErrorCount = 0
                stats.IsHealthy = true
                stats.LastError = ""
        }</span>
        <span class="cov0" title="0">m.statsMu.Unlock()

        log.Printf("[Manager] Successfully restarted subscription for %s", symbol)</span>
}

// SubscribeRequest 订阅请求
type SubscribeRequest struct {
        Symbol   string
        Interval time.Duration
        Callback CallbackFunc
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package subscriber

import (
        "fmt"
        "math"
        "strings"
        "time"
)

// isValidFieldType 验证字段类型是否匹配
func isValidFieldType(value interface{}, expectedType FieldType) bool <span class="cov10" title="313">{
        if value == nil </span><span class="cov6" title="42">{
                return true // nil 值总是有效的（可选字段）
        }</span>

        <span class="cov9" title="271">switch expectedType </span>{
        case FieldTypeString:<span class="cov7" title="72">
                _, ok := value.(string)
                return ok</span>
        case FieldTypeInt:<span class="cov7" title="51">
                switch value.(type) </span>{
                case int, int8, int16, int32, int64:<span class="cov7" title="49">
                        return true</span>
                default:<span class="cov2" title="2">
                        return false</span>
                }
        case FieldTypeFloat64:<span class="cov8" title="115">
                switch value.(type) </span>{
                case float32, float64:<span class="cov8" title="111">
                        return true</span>
                default:<span class="cov3" title="4">
                        return false</span>
                }
        case FieldTypeBool:<span class="cov2" title="3">
                _, ok := value.(bool)
                return ok</span>
        case FieldTypeTime:<span class="cov6" title="30">
                _, ok := value.(time.Time)
                return ok</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// ValidateSchema 验证数据模式定义的完整性
func ValidateSchema(schema *DataSchema) error <span class="cov4" title="11">{
        if schema == nil </span><span class="cov1" title="1">{
                return NewStructuredDataError(ErrSchemaNotFound, "", "schema cannot be nil")
        }</span>

        <span class="cov4" title="10">if schema.Name == "" </span><span class="cov2" title="2">{
                return NewStructuredDataError(ErrSchemaNotFound, "", "schema name cannot be empty")
        }</span>

        <span class="cov4" title="8">if len(schema.Fields) == 0 </span><span class="cov1" title="1">{
                return NewStructuredDataError(ErrSchemaNotFound, "", "schema must have at least one field")
        }</span>

        // 验证字段顺序是否包含所有字段
        <span class="cov4" title="7">if len(schema.FieldOrder) &gt; 0 </span><span class="cov4" title="7">{
                fieldOrderMap := make(map[string]bool)
                for _, fieldName := range schema.FieldOrder </span><span class="cov9" title="176">{
                        fieldOrderMap[fieldName] = true
                        if _, exists := schema.Fields[fieldName]; !exists </span><span class="cov1" title="1">{
                                return NewStructuredDataError(ErrFieldNotFound, fieldName, "field in order not found in schema fields")
                        }</span>
                }

                // 检查是否有字段没有在顺序中
                <span class="cov3" title="6">for fieldName := range schema.Fields </span><span class="cov9" title="175">{
                        if !fieldOrderMap[fieldName] </span><span class="cov1" title="1">{
                                return NewStructuredDataError(ErrFieldNotFound, fieldName, "field not specified in field order")
                        }</span>
                }
        }

        // 验证每个字段定义
        <span class="cov3" title="5">for fieldName, fieldDef := range schema.Fields </span><span class="cov9" title="173">{
                if err := ValidateFieldDefinition(fieldName, fieldDef); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov3" title="5">return nil</span>
}

// ValidateFieldDefinition 验证字段定义的正确性
func ValidateFieldDefinition(fieldName string, fieldDef *FieldDefinition) error <span class="cov9" title="222">{
        if fieldDef == nil </span><span class="cov1" title="1">{
                return NewStructuredDataError(ErrFieldNotFound, fieldName, "field definition cannot be nil")
        }</span>

        <span class="cov9" title="221">if fieldDef.Name == "" </span><span class="cov1" title="1">{
                return NewStructuredDataError(ErrInvalidFieldType, fieldName, "field name cannot be empty")
        }</span>

        <span class="cov9" title="220">if fieldDef.Name != fieldName </span><span class="cov1" title="1">{
                return NewStructuredDataError(ErrInvalidFieldType, fieldName, "field name mismatch")
        }</span>

        // 验证字段类型
        <span class="cov9" title="219">if fieldDef.Type &lt; FieldTypeString || fieldDef.Type &gt; FieldTypeTime </span><span class="cov1" title="1">{
                return NewStructuredDataError(ErrInvalidFieldType, fieldName, "invalid field type")
        }</span>

        // 验证默认值类型
        <span class="cov9" title="218">if fieldDef.DefaultValue != nil </span><span class="cov1" title="1">{
                if !isValidFieldType(fieldDef.DefaultValue, fieldDef.Type) </span><span class="cov1" title="1">{
                        return NewStructuredDataError(ErrInvalidFieldType, fieldName, "default value type mismatch")
                }</span>
        }

        // 验证必填字段是否有默认值
        <span class="cov9" title="217">if fieldDef.Required &amp;&amp; fieldDef.DefaultValue == nil </span>{<span class="cov5" title="22">
                // 注意：必填字段可以没有默认值，这样可以强制用户提供值
        }</span>

        <span class="cov9" title="217">return nil</span>
}

// ValidateFieldValue 验证单个字段值
func ValidateFieldValue(fieldName string, value interface{}, fieldDef *FieldDefinition) error <span class="cov8" title="146">{
        if fieldDef == nil </span><span class="cov1" title="1">{
                return NewStructuredDataError(ErrFieldNotFound, fieldName, "field definition not found")
        }</span>

        // 检查必填字段
        <span class="cov8" title="145">if fieldDef.Required &amp;&amp; value == nil </span><span class="cov2" title="2">{
                return NewStructuredDataError(ErrRequiredFieldMissing, fieldName, "required field missing")
        }</span>

        // 如果值为 nil 且不是必填字段，则有效
        <span class="cov8" title="143">if value == nil </span><span class="cov8" title="104">{
                return nil
        }</span>

        // 类型验证
        <span class="cov6" title="39">if !isValidFieldType(value, fieldDef.Type) </span><span class="cov1" title="1">{
                return NewStructuredDataError(ErrInvalidFieldType, fieldName, fmt.Sprintf("expected %s, got %T", fieldDef.Type.String(), value))
        }</span>

        // 范围验证（数值类型）
        <span class="cov6" title="38">if err := validateValueRange(fieldName, value, fieldDef); err != nil </span><span class="cov4" title="10">{
                return err
        }</span>

        // 自定义验证
        <span class="cov6" title="28">if fieldDef.Validator != nil </span><span class="cov0" title="0">{
                if err := fieldDef.Validator(value); err != nil </span><span class="cov0" title="0">{
                        return NewStructuredDataError(ErrFieldValidationFailed, fieldName, err.Error())
                }</span>
        }

        <span class="cov6" title="28">return nil</span>
}

// validateValueRange 验证数值范围（可扩展用于不同字段类型的范围验证）
func validateValueRange(fieldName string, value interface{}, fieldDef *FieldDefinition) error <span class="cov6" title="38">{
        switch fieldDef.Type </span>{
        case FieldTypeFloat64:<span class="cov4" title="12">
                if f, ok := value.(float64); ok </span><span class="cov4" title="12">{
                        // 检查是否为 NaN 或无穷大
                        if math.IsNaN(f) || math.IsInf(f, 0) </span><span class="cov2" title="2">{
                                return NewStructuredDataError(ErrInvalidFieldType, fieldName, "value cannot be NaN or Infinity")
                        }</span>
                        // 可以添加更多的范围检查
                        <span class="cov4" title="10">if fieldName == "price" &amp;&amp; f &lt; 0 </span><span class="cov2" title="2">{
                                return NewStructuredDataError(ErrFieldValidationFailed, fieldName, "price cannot be negative")
                        }</span>
                }
        case FieldTypeInt:<span class="cov3" title="4">
                // 可以添加整数范围验证
                if fieldName == "volume" || strings.Contains(fieldName, "volume") </span><span class="cov3" title="4">{
                        var intVal int64
                        switch v := value.(type) </span>{
                        case int:<span class="cov2" title="2">
                                intVal = int64(v)</span>
                        case int64:<span class="cov2" title="2">
                                intVal = v</span>
                        case int32:<span class="cov0" title="0">
                                intVal = int64(v)</span>
                        }
                        <span class="cov3" title="4">if intVal &lt; 0 </span><span class="cov2" title="2">{
                                return NewStructuredDataError(ErrFieldValidationFailed, fieldName, "volume cannot be negative")
                        }</span>
                }
        case FieldTypeString:<span class="cov5" title="18">
                if str, ok := value.(string); ok </span><span class="cov5" title="18">{
                        // 字符串长度验证
                        if fieldName == "symbol" &amp;&amp; (len(str) &lt; 2 || len(str) &gt; 10) </span><span class="cov2" title="3">{
                                return NewStructuredDataError(ErrFieldValidationFailed, fieldName, "symbol length must be between 2 and 10 characters")
                        }</span>
                        <span class="cov5" title="15">if fieldName == "name" &amp;&amp; len(str) &gt; 50 </span><span class="cov1" title="1">{
                                return NewStructuredDataError(ErrFieldValidationFailed, fieldName, "name cannot exceed 50 characters")
                        }</span>
                }
        }

        <span class="cov6" title="28">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package subscriber

import (
        "bytes"
        "encoding/csv"
        "encoding/json"
        "fmt"
        "strconv"
        "strings"
        "time"
)

// SerializationFormat 序列化格式
type SerializationFormat int

const (
        FormatCSV SerializationFormat = iota
        FormatJSON
)

// String returns the string representation of SerializationFormat
func (sf SerializationFormat) String() string <span class="cov2" title="3">{
        switch sf </span>{
        case FormatCSV:<span class="cov1" title="1">
                return "csv"</span>
        case FormatJSON:<span class="cov1" title="1">
                return "json"</span>
        default:<span class="cov1" title="1">
                return "unknown"</span>
        }
}

// StructuredDataSerializer 结构化数据序列化器
type StructuredDataSerializer struct {
        format   SerializationFormat
        timezone *time.Location // 时区设置，默认为上海时区
}

// NewStructuredDataSerializer 创建新的结构化数据序列化器
func NewStructuredDataSerializer(format SerializationFormat) *StructuredDataSerializer <span class="cov5" title="17">{
        // 设置上海时区
        shanghaiTZ, err := time.LoadLocation("Asia/Shanghai")
        if err != nil </span><span class="cov0" title="0">{
                // 如果加载失败，使用 UTC+8
                shanghaiTZ = time.FixedZone("CST", 8*3600)
        }</span>

        <span class="cov5" title="17">return &amp;StructuredDataSerializer{
                format:   format,
                timezone: shanghaiTZ,
        }</span>
}

// Serialize 将 StructuredData 序列化为字节数组
func (s *StructuredDataSerializer) Serialize(data interface{}) ([]byte, error) <span class="cov4" title="6">{
        switch s.format </span>{
        case FormatCSV:<span class="cov3" title="4">
                return s.serializeToCSV(data)</span>
        case FormatJSON:<span class="cov2" title="2">
                return s.serializeToJSON(data)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported serialization format: %v", s.format)</span>
        }
}

// Deserialize 将字节数组反序列化为 StructuredData
func (s *StructuredDataSerializer) Deserialize(data []byte, target interface{}) error <span class="cov3" title="4">{
        switch s.format </span>{
        case FormatCSV:<span class="cov2" title="3">
                return s.deserializeFromCSV(data, target)</span>
        case FormatJSON:<span class="cov1" title="1">
                return s.deserializeFromJSON(data, target)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported deserialization format: %v", s.format)</span>
        }
}

// MimeType 返回此序列化器对应的MIME类型
func (s *StructuredDataSerializer) MimeType() string <span class="cov2" title="2">{
        switch s.format </span>{
        case FormatCSV:<span class="cov1" title="1">
                return "text/csv"</span>
        case FormatJSON:<span class="cov1" title="1">
                return "application/json"</span>
        default:<span class="cov0" title="0">
                return "application/octet-stream"</span>
        }
}

// serializeToCSV 序列化为CSV格式
func (s *StructuredDataSerializer) serializeToCSV(data interface{}) ([]byte, error) <span class="cov3" title="4">{
        sd, ok := data.(*StructuredData)
        if !ok </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("data must be *StructuredData, got %T", data)
        }</span>

        <span class="cov2" title="3">var buf bytes.Buffer
        writer := csv.NewWriter(&amp;buf)

        // 生成CSV表头
        headers := s.generateCSVHeaders(sd.Schema)
        if err := writer.Write(headers); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write CSV headers: %w", err)
        }</span>

        // 生成数据行
        <span class="cov2" title="3">record := s.generateCSVRecord(sd)
        if err := writer.Write(record); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write CSV record: %w", err)
        }</span>

        <span class="cov2" title="3">writer.Flush()
        if err := writer.Error(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CSV writer error: %w", err)
        }</span>

        <span class="cov2" title="3">return buf.Bytes(), nil</span>
}

// serializeToJSON 序列化为JSON格式
func (s *StructuredDataSerializer) serializeToJSON(data interface{}) ([]byte, error) <span class="cov2" title="2">{
        sd, ok := data.(*StructuredData)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("data must be *StructuredData, got %T", data)
        }</span>

        // 创建JSON兼容的结构
        <span class="cov2" title="2">jsonData := map[string]interface{}{
                "schema":    sd.Schema,
                "values":    sd.Values,
                "timestamp": sd.Timestamp.In(s.timezone).Format("2006-01-02 15:04:05"),
        }

        return json.Marshal(jsonData)</span>
}

// deserializeFromCSV 从CSV格式反序列化
func (s *StructuredDataSerializer) deserializeFromCSV(data []byte, target interface{}) error <span class="cov2" title="3">{
        sd, ok := target.(*StructuredData)
        if !ok </span><span class="cov1" title="1">{
                return fmt.Errorf("target must be *StructuredData, got %T", target)
        }</span>

        <span class="cov2" title="2">reader := csv.NewReader(bytes.NewReader(data))
        records, err := reader.ReadAll()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read CSV data: %w", err)
        }</span>

        <span class="cov2" title="2">if len(records) &lt; 2 </span><span class="cov1" title="1">{
                return fmt.Errorf("CSV data must contain at least header and one data row")
        }</span>

        <span class="cov1" title="1">headers := records[0]
        dataRow := records[1]

        if len(headers) != len(dataRow) </span><span class="cov0" title="0">{
                return fmt.Errorf("header count (%d) does not match data count (%d)", len(headers), len(dataRow))
        }</span>

        // 解析表头，提取字段名并验证
        <span class="cov1" title="1">fieldMapping, err := s.parseAndValidateCSVHeaders(headers, sd.Schema)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 解析数据行
        <span class="cov1" title="1">for i, fieldName := range fieldMapping </span><span class="cov7" title="43">{
                if fieldName == "" </span><span class="cov0" title="0">{
                        continue</span> // 跳过无法识别的字段
                }

                <span class="cov7" title="43">fieldDef := sd.Schema.Fields[fieldName]
                value, err := s.parseCSVValue(dataRow[i], fieldDef.Type)
                if err != nil </span><span class="cov0" title="0">{
                        return NewStructuredDataError(ErrInvalidFieldType, fieldName, fmt.Sprintf("failed to parse value '%s': %v", dataRow[i], err))
                }</span>

                <span class="cov7" title="43">if err := sd.SetField(fieldName, value); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// deserializeFromJSON 从JSON格式反序列化
func (s *StructuredDataSerializer) deserializeFromJSON(data []byte, target interface{}) error <span class="cov1" title="1">{
        sd, ok := target.(*StructuredData)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("target must be *StructuredData, got %T", target)
        }</span>

        <span class="cov1" title="1">var jsonData map[string]interface{}
        if err := json.Unmarshal(data, &amp;jsonData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal JSON: %w", err)
        }</span>

        // 解析schema
        <span class="cov1" title="1">if schemaData, exists := jsonData["schema"]; exists </span><span class="cov1" title="1">{
                schemaBytes, err := json.Marshal(schemaData)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal schema: %w", err)
                }</span>
                <span class="cov1" title="1">if err := json.Unmarshal(schemaBytes, &amp;sd.Schema); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to unmarshal schema: %w", err)
                }</span>
        }

        // 解析values
        <span class="cov1" title="1">if valuesData, exists := jsonData["values"]; exists </span><span class="cov1" title="1">{
                if values, ok := valuesData.(map[string]interface{}); ok </span><span class="cov1" title="1">{
                        sd.Values = values
                }</span>
        }

        // 解析timestamp
        <span class="cov1" title="1">if timestampData, exists := jsonData["timestamp"]; exists </span><span class="cov1" title="1">{
                if timestampStr, ok := timestampData.(string); ok </span><span class="cov1" title="1">{
                        if timestamp, err := time.ParseInLocation("2006-01-02 15:04:05", timestampStr, s.timezone); err == nil </span><span class="cov1" title="1">{
                                sd.Timestamp = timestamp
                        }</span>
                }
        }

        <span class="cov1" title="1">return nil</span>
}

// generateCSVHeaders 生成CSV表头（包含中文描述）
func (s *StructuredDataSerializer) generateCSVHeaders(schema *DataSchema) []string <span class="cov3" title="5">{
        headers := make([]string, len(schema.FieldOrder))

        for i, fieldName := range schema.FieldOrder </span><span class="cov9" title="172">{
                fieldDef, exists := schema.Fields[fieldName]
                if !exists </span><span class="cov0" title="0">{
                        headers[i] = fieldName
                        continue</span>
                }

                // 格式：中文描述(英文字段名)
                <span class="cov9" title="172">if fieldDef.Description != "" </span><span class="cov9" title="172">{
                        headers[i] = fmt.Sprintf("%s(%s)", fieldDef.Description, fieldName)
                }</span> else<span class="cov0" title="0"> {
                        headers[i] = fieldName
                }</span>
        }

        <span class="cov3" title="5">return headers</span>
}

// generateCSVRecord 生成CSV数据行
func (s *StructuredDataSerializer) generateCSVRecord(sd *StructuredData) []string <span class="cov4" title="6">{
        record := make([]string, len(sd.Schema.FieldOrder))

        for i, fieldName := range sd.Schema.FieldOrder </span><span class="cov10" title="215">{
                value, err := sd.GetField(fieldName)
                if err != nil || value == nil </span><span class="cov9" title="183">{
                        record[i] = ""
                        continue</span>
                }

                <span class="cov6" title="32">fieldDef := sd.Schema.Fields[fieldName]
                record[i] = s.formatCSVValue(value, fieldDef.Type)</span>
        }

        <span class="cov4" title="6">return record</span>
}

// formatCSVValue 格式化CSV值
func (s *StructuredDataSerializer) formatCSVValue(value interface{}, fieldType FieldType) string <span class="cov6" title="32">{
        if value == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov6" title="32">switch fieldType </span>{
        case FieldTypeString:<span class="cov4" title="10">
                if str, ok := value.(string); ok </span><span class="cov4" title="10">{
                        return str
                }</span>
        case FieldTypeInt:<span class="cov3" title="4">
                switch v := value.(type) </span>{
                case int:<span class="cov0" title="0">
                        return strconv.Itoa(v)</span>
                case int32:<span class="cov0" title="0">
                        return strconv.FormatInt(int64(v), 10)</span>
                case int64:<span class="cov3" title="4">
                        return strconv.FormatInt(v, 10)</span>
                }
        case FieldTypeFloat64:<span class="cov5" title="13">
                switch v := value.(type) </span>{
                case float32:<span class="cov0" title="0">
                        return strconv.FormatFloat(float64(v), 'f', 2, 32)</span>
                case float64:<span class="cov5" title="13">
                        return strconv.FormatFloat(v, 'f', 2, 64)</span>
                }
        case FieldTypeBool:<span class="cov0" title="0">
                if b, ok := value.(bool); ok </span><span class="cov0" title="0">{
                        return strconv.FormatBool(b)
                }</span>
        case FieldTypeTime:<span class="cov3" title="5">
                if t, ok := value.(time.Time); ok </span><span class="cov3" title="5">{
                        // 使用上海时区格式化时间：YYYY-MM-DD HH:mm:ss
                        return t.In(s.timezone).Format("2006-01-02 15:04:05")
                }</span>
        }

        <span class="cov0" title="0">return fmt.Sprintf("%v", value)</span>
}

// parseCSVHeaders 解析CSV表头，提取字段名
func (s *StructuredDataSerializer) parseCSVHeaders(headers []string) []string <span class="cov5" title="11">{
        fieldNames := make([]string, len(headers))

        for i, header := range headers </span><span class="cov8" title="74">{
                // 解析格式：中文描述(英文字段名) 或 英文字段名
                if strings.Contains(header, "(") &amp;&amp; strings.Contains(header, ")") </span><span class="cov7" title="65">{
                        // 提取括号内的字段名
                        start := strings.LastIndex(header, "(")
                        end := strings.LastIndex(header, ")")
                        if start &lt; end &amp;&amp; start &gt;= 0 &amp;&amp; end &gt;= 0 </span><span class="cov7" title="65">{
                                fieldNames[i] = header[start+1 : end]
                        }</span> else<span class="cov0" title="0"> {
                                fieldNames[i] = header
                        }</span>
                } else<span class="cov4" title="9"> {
                        fieldNames[i] = header
                }</span>
        }

        <span class="cov5" title="11">return fieldNames</span>
}

// parseAndValidateCSVHeaders 解析并验证CSV表头
func (s *StructuredDataSerializer) parseAndValidateCSVHeaders(headers []string, schema *DataSchema) ([]string, error) <span class="cov4" title="8">{
        fieldNames := s.parseCSVHeaders(headers)

        // 验证字段是否存在于schema中，并提供详细的错误信息
        var unknownFields []string
        var validFields []string

        for i, fieldName := range fieldNames </span><span class="cov7" title="65">{
                if fieldName == "" </span><span class="cov1" title="1">{
                        validFields = append(validFields, "")
                        continue</span>
                }

                <span class="cov7" title="64">if _, exists := schema.Fields[fieldName]; !exists </span><span class="cov2" title="2">{
                        unknownFields = append(unknownFields, fmt.Sprintf("'%s' (from header '%s')", fieldName, headers[i]))
                        validFields = append(validFields, "")
                }</span> else<span class="cov7" title="62"> {
                        validFields = append(validFields, fieldName)
                }</span>
        }

        // 如果有未知字段，返回详细错误信息
        <span class="cov4" title="8">if len(unknownFields) &gt; 0 </span><span class="cov2" title="2">{
                availableFields := make([]string, 0, len(schema.Fields))
                for fieldName := range schema.Fields </span><span class="cov8" title="86">{
                        availableFields = append(availableFields, fieldName)
                }</span>

                <span class="cov2" title="2">return nil, NewStructuredDataError(
                        ErrCSVHeaderMismatch,
                        "",
                        fmt.Sprintf("unknown fields in CSV header: %s. Available fields: %s",
                                strings.Join(unknownFields, ", "),
                                strings.Join(availableFields, ", ")))</span>
        }

        <span class="cov4" title="6">return validFields, nil</span>
}

// parseCSVValue 解析CSV值
func (s *StructuredDataSerializer) parseCSVValue(value string, fieldType FieldType) (interface{}, error) <span class="cov7" title="65">{
        if value == "" </span><span class="cov7" title="36">{
                return nil, nil
        }</span>

        <span class="cov6" title="29">switch fieldType </span>{
        case FieldTypeString:<span class="cov4" title="10">
                return value, nil</span>
        case FieldTypeInt:<span class="cov3" title="4">
                return strconv.ParseInt(value, 10, 64)</span>
        case FieldTypeFloat64:<span class="cov4" title="10">
                return strconv.ParseFloat(value, 64)</span>
        case FieldTypeBool:<span class="cov0" title="0">
                return strconv.ParseBool(value)</span>
        case FieldTypeTime:<span class="cov3" title="5">
                // 解析上海时区时间：YYYY-MM-DD HH:mm:ss
                return time.ParseInLocation("2006-01-02 15:04:05", value, s.timezone)</span>
        default:<span class="cov0" title="0">
                return value, nil</span>
        }
}

// DeserializeMultiple 批量反序列化多个 StructuredData
func (s *StructuredDataSerializer) DeserializeMultiple(data []byte, schema *DataSchema) ([]*StructuredData, error) <span class="cov4" title="7">{
        switch s.format </span>{
        case FormatCSV:<span class="cov4" title="6">
                return s.deserializeMultipleFromCSV(data, schema)</span>
        case FormatJSON:<span class="cov1" title="1">
                return s.deserializeMultipleFromJSON(data, schema)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported deserialization format: %v", s.format)</span>
        }
}

// deserializeMultipleFromCSV 从CSV格式批量反序列化
func (s *StructuredDataSerializer) deserializeMultipleFromCSV(data []byte, schema *DataSchema) ([]*StructuredData, error) <span class="cov4" title="6">{
        reader := csv.NewReader(bytes.NewReader(data))
        records, err := reader.ReadAll()
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to read CSV data: %w", err)
        }</span>

        <span class="cov3" title="5">if len(records) &lt; 2 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("CSV data must contain at least header and one data row")
        }</span>

        <span class="cov3" title="4">headers := records[0]
        dataRows := records[1:]

        // 解析表头，提取字段名并验证
        fieldMapping, err := s.parseAndValidateCSVHeaders(headers, schema)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // 批量解析数据行
        <span class="cov2" title="3">result := make([]*StructuredData, 0, len(dataRows))
        for rowIndex, dataRow := range dataRows </span><span class="cov3" title="5">{
                if len(headers) != len(dataRow) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("row %d: header count (%d) does not match data count (%d)",
                                rowIndex+2, len(headers), len(dataRow))
                }</span>

                <span class="cov3" title="5">sd := NewStructuredData(schema)

                // 解析当前行的数据
                for i, fieldName := range fieldMapping </span><span class="cov6" title="22">{
                        if fieldName == "" </span><span class="cov0" title="0">{
                                continue</span> // 跳过无法识别的字段
                        }

                        <span class="cov6" title="22">fieldDef := schema.Fields[fieldName]
                        value, err := s.parseCSVValue(dataRow[i], fieldDef.Type)
                        if err != nil </span><span class="cov1" title="1">{
                                return nil, NewStructuredDataError(ErrInvalidFieldType, fieldName,
                                        fmt.Sprintf("row %d: failed to parse value '%s': %v", rowIndex+2, dataRow[i], err))
                        }</span>

                        <span class="cov6" title="21">if err := sd.SetField(fieldName, value); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("row %d: %w", rowIndex+2, err)
                        }</span>
                }

                <span class="cov3" title="4">result = append(result, sd)</span>
        }

        <span class="cov2" title="2">return result, nil</span>
}

// deserializeMultipleFromJSON 从JSON格式批量反序列化
func (s *StructuredDataSerializer) deserializeMultipleFromJSON(data []byte, schema *DataSchema) ([]*StructuredData, error) <span class="cov1" title="1">{
        var jsonDataList []map[string]interface{}
        if err := json.Unmarshal(data, &amp;jsonDataList); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal JSON array: %w", err)
        }</span>

        <span class="cov1" title="1">result := make([]*StructuredData, 0, len(jsonDataList))
        for i, jsonData := range jsonDataList </span><span class="cov2" title="2">{
                sd := NewStructuredData(schema)

                // 解析values
                if valuesData, exists := jsonData["values"]; exists </span><span class="cov2" title="2">{
                        if values, ok := valuesData.(map[string]interface{}); ok </span><span class="cov2" title="2">{
                                for fieldName, value := range values </span><span class="cov4" title="8">{
                                        if err := sd.SetField(fieldName, value); err != nil </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("item %d: failed to set field %s: %w", i, fieldName, err)
                                        }</span>
                                }
                        }
                }

                // 解析timestamp
                <span class="cov2" title="2">if timestampData, exists := jsonData["timestamp"]; exists </span><span class="cov2" title="2">{
                        if timestampStr, ok := timestampData.(string); ok </span><span class="cov2" title="2">{
                                if timestamp, err := time.ParseInLocation("2006-01-02 15:04:05", timestampStr, s.timezone); err == nil </span><span class="cov2" title="2">{
                                        sd.Timestamp = timestamp
                                        // 同时设置到Values中，因为timestamp是必填字段
                                        if err := sd.SetField("timestamp", timestamp); err != nil </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("item %d: failed to set timestamp field: %w", i, err)
                                        }</span>
                                }
                        }
                }

                // 验证数据完整性
                <span class="cov2" title="2">if err := sd.ValidateData(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("item %d: %w", i, err)
                }</span>

                <span class="cov2" title="2">result = append(result, sd)</span>
        }

        <span class="cov1" title="1">return result, nil</span>
}

// SerializeMultiple 批量序列化多个 StructuredData
func (s *StructuredDataSerializer) SerializeMultiple(dataList []*StructuredData) ([]byte, error) <span class="cov2" title="2">{
        if len(dataList) == 0 </span><span class="cov0" title="0">{
                return []byte{}, nil
        }</span>

        <span class="cov2" title="2">switch s.format </span>{
        case FormatCSV:<span class="cov2" title="2">
                return s.serializeMultipleToCSV(dataList)</span>
        case FormatJSON:<span class="cov0" title="0">
                return s.serializeMultipleToJSON(dataList)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported serialization format: %v", s.format)</span>
        }
}

// serializeMultipleToCSV 批量序列化为CSV格式
func (s *StructuredDataSerializer) serializeMultipleToCSV(dataList []*StructuredData) ([]byte, error) <span class="cov2" title="2">{
        if len(dataList) == 0 </span><span class="cov0" title="0">{
                return []byte{}, nil
        }</span>

        <span class="cov2" title="2">var buf bytes.Buffer
        writer := csv.NewWriter(&amp;buf)

        // 使用第一个数据的schema生成表头
        firstData := dataList[0]
        headers := s.generateCSVHeaders(firstData.Schema)
        if err := writer.Write(headers); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write CSV headers: %w", err)
        }</span>

        // 写入所有数据行
        <span class="cov2" title="2">for _, sd := range dataList </span><span class="cov3" title="4">{
                // 验证schema一致性
                if sd.Schema.Name != firstData.Schema.Name </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("inconsistent schema: expected %s, got %s", firstData.Schema.Name, sd.Schema.Name)
                }</span>

                <span class="cov2" title="3">record := s.generateCSVRecord(sd)
                if err := writer.Write(record); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to write CSV record: %w", err)
                }</span>
        }

        <span class="cov1" title="1">writer.Flush()
        if err := writer.Error(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CSV writer error: %w", err)
        }</span>

        <span class="cov1" title="1">return buf.Bytes(), nil</span>
}

// serializeMultipleToJSON 批量序列化为JSON格式
func (s *StructuredDataSerializer) serializeMultipleToJSON(dataList []*StructuredData) ([]byte, error) <span class="cov0" title="0">{
        jsonDataList := make([]map[string]interface{}, len(dataList))

        for i, sd := range dataList </span><span class="cov0" title="0">{
                jsonDataList[i] = map[string]interface{}{
                        "schema":    sd.Schema,
                        "values":    sd.Values,
                        "timestamp": sd.Timestamp.In(s.timezone).Format("2006-01-02 15:04:05"),
                }
        }</span>

        <span class="cov0" title="0">return json.Marshal(jsonDataList)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package subscriber

import (
        "fmt"
        "time"
)

// FieldType 支持的字段类型
type FieldType int

const (
        FieldTypeString FieldType = iota
        FieldTypeInt
        FieldTypeFloat64
        FieldTypeBool
        FieldTypeTime
)

// String returns the string representation of FieldType
func (ft FieldType) String() string <span class="cov4" title="9">{
        switch ft </span>{
        case FieldTypeString:<span class="cov2" title="2">
                return "string"</span>
        case FieldTypeInt:<span class="cov2" title="2">
                return "int"</span>
        case FieldTypeFloat64:<span class="cov2" title="2">
                return "float64"</span>
        case FieldTypeBool:<span class="cov1" title="1">
                return "bool"</span>
        case FieldTypeTime:<span class="cov1" title="1">
                return "time"</span>
        default:<span class="cov1" title="1">
                return "unknown"</span>
        }
}

// FieldDefinition 字段定义
type FieldDefinition struct {
        Name         string                  `json:"name"`          // 字段名（英文）
        Type         FieldType               `json:"type"`          // 字段类型
        Description  string                  `json:"description"`   // 中文描述
        Comment      string                  `json:"comment"`       // 中文字段备注（可选）
        Required     bool                    `json:"required"`      // 是否必填
        DefaultValue interface{}             `json:"default_value"` // 默认值
        Validator    func(interface{}) error `json:"-"`             // 验证函数（不序列化）
}

// DataSchema 数据模式定义
type DataSchema struct {
        Name        string                      `json:"name"`        // 模式名称
        Description string                      `json:"description"` // 模式描述
        Fields      map[string]*FieldDefinition `json:"fields"`      // 字段定义
        FieldOrder  []string                    `json:"field_order"` // 字段顺序（用于CSV输出）
}

// StructuredData 结构化数据，支持动态字段和元数据
type StructuredData struct {
        Schema    *DataSchema            `json:"schema"`    // 数据模式定义
        Values    map[string]interface{} `json:"values"`    // 字段值存储
        Timestamp time.Time              `json:"timestamp"` // 数据时间戳
}

// NewStructuredData 创建新的结构化数据实例
func NewStructuredData(schema *DataSchema) *StructuredData <span class="cov6" title="34">{
        return &amp;StructuredData{
                Schema:    schema,
                Values:    make(map[string]interface{}),
                Timestamp: time.Now(),
        }
}</span>

// SetField 设置字段值（类型安全）
func (sd *StructuredData) SetField(fieldName string, value interface{}) error <span class="cov9" title="233">{
        fieldDef, exists := sd.Schema.Fields[fieldName]
        if !exists </span><span class="cov1" title="1">{
                return NewStructuredDataError(ErrFieldNotFound, fieldName, "field not found in schema")
        }</span>

        // 类型验证
        <span class="cov9" title="232">if !isValidFieldType(value, fieldDef.Type) </span><span class="cov1" title="1">{
                return NewStructuredDataError(ErrInvalidFieldType, fieldName, "invalid field type")
        }</span>

        // 自定义验证
        <span class="cov9" title="231">if fieldDef.Validator != nil </span><span class="cov0" title="0">{
                if err := fieldDef.Validator(value); err != nil </span><span class="cov0" title="0">{
                        return NewStructuredDataError(ErrFieldValidationFailed, fieldName, err.Error())
                }</span>
        }

        <span class="cov9" title="231">sd.Values[fieldName] = value
        return nil</span>
}

// GetField 获取字段值（类型安全）
func (sd *StructuredData) GetField(fieldName string) (interface{}, error) <span class="cov10" title="324">{
        fieldDef, exists := sd.Schema.Fields[fieldName]
        if !exists </span><span class="cov1" title="1">{
                return nil, NewStructuredDataError(ErrFieldNotFound, fieldName, "field not found in schema")
        }</span>

        <span class="cov9" title="323">value, exists := sd.Values[fieldName]
        if !exists </span><span class="cov9" title="222">{
                // 返回默认值
                if fieldDef.DefaultValue != nil </span><span class="cov0" title="0">{
                        return fieldDef.DefaultValue, nil
                }</span>
                <span class="cov9" title="222">if fieldDef.Required </span><span class="cov1" title="1">{
                        return nil, NewStructuredDataError(ErrRequiredFieldMissing, fieldName, "required field missing")
                }</span>
                <span class="cov9" title="221">return nil, nil</span>
        }

        <span class="cov8" title="101">return value, nil</span>
}

// ValidateData 验证数据完整性
func (sd *StructuredData) ValidateData() error <span class="cov3" title="6">{
        for fieldName, fieldDef := range sd.Schema.Fields </span><span class="cov9" title="192">{
                value, exists := sd.Values[fieldName]

                // 检查必填字段
                if fieldDef.Required &amp;&amp; !exists </span><span class="cov1" title="1">{
                        return NewStructuredDataError(ErrRequiredFieldMissing, fieldName, "required field missing")
                }</span>

                // 类型验证
                <span class="cov9" title="191">if exists &amp;&amp; !isValidFieldType(value, fieldDef.Type) </span><span class="cov1" title="1">{
                        return NewStructuredDataError(ErrInvalidFieldType, fieldName, "invalid field type")
                }</span>

                // 自定义验证
                <span class="cov9" title="190">if exists &amp;&amp; fieldDef.Validator != nil </span><span class="cov0" title="0">{
                        if err := fieldDef.Validator(value); err != nil </span><span class="cov0" title="0">{
                                return NewStructuredDataError(ErrFieldValidationFailed, fieldName, err.Error())
                        }</span>
                }
        }
        <span class="cov3" title="4">return nil</span>
}

// StockDataSchema 预定义的股票数据模式
var StockDataSchema = &amp;DataSchema{
        Name:        "stock_data",
        Description: "股票行情数据",
        Fields: map[string]*FieldDefinition{
                // 基本信息
                "symbol": {
                        Name:        "symbol",
                        Type:        FieldTypeString,
                        Description: "股票代码",
                        Comment:     "如600000、000001等",
                        Required:    true,
                },
                "name": {
                        Name:        "name",
                        Type:        FieldTypeString,
                        Description: "股票名称",
                        Comment:     "股票的中文名称",
                        Required:    true,
                },
                "price": {
                        Name:        "price",
                        Type:        FieldTypeFloat64,
                        Description: "当前价格",
                        Comment:     "最新成交价格",
                        Required:    true,
                },
                "change": {
                        Name:        "change",
                        Type:        FieldTypeFloat64,
                        Description: "涨跌额",
                        Comment:     "相对昨收价的涨跌金额",
                },
                "change_percent": {
                        Name:        "change_percent",
                        Type:        FieldTypeFloat64,
                        Description: "涨跌幅(%)",
                        Comment:     "涨跌幅百分比",
                },
                "market_code": {
                        Name:        "market_code",
                        Type:        FieldTypeInt,
                        Description: "市场分类代码",
                        Comment:     "交易所市场代码",
                },
                // 交易数据
                "volume": {
                        Name:        "volume",
                        Type:        FieldTypeInt,
                        Description: "成交量",
                        Comment:     "累计成交股数",
                },
                "turnover": {
                        Name:        "turnover",
                        Type:        FieldTypeFloat64,
                        Description: "成交额(元)",
                        Comment:     "累计成交金额",
                },
                "open": {
                        Name:        "open",
                        Type:        FieldTypeFloat64,
                        Description: "开盘价",
                        Comment:     "当日开盘价格",
                },
                "high": {
                        Name:        "high",
                        Type:        FieldTypeFloat64,
                        Description: "最高价",
                        Comment:     "当日最高成交价",
                },
                "low": {
                        Name:        "low",
                        Type:        FieldTypeFloat64,
                        Description: "最低价",
                        Comment:     "当日最低成交价",
                },
                "prev_close": {
                        Name:        "prev_close",
                        Type:        FieldTypeFloat64,
                        Description: "昨收价",
                        Comment:     "前一交易日收盘价",
                },
                // 5档买卖盘数据
                "bid_price1": {
                        Name:        "bid_price1",
                        Type:        FieldTypeFloat64,
                        Description: "买一价",
                        Comment:     "买盘第一档价格",
                },
                "bid_volume1": {
                        Name:        "bid_volume1",
                        Type:        FieldTypeInt,
                        Description: "买一量",
                        Comment:     "买盘第一档数量",
                },
                "bid_price2": {
                        Name:        "bid_price2",
                        Type:        FieldTypeFloat64,
                        Description: "买二价",
                        Comment:     "买盘第二档价格",
                },
                "bid_volume2": {
                        Name:        "bid_volume2",
                        Type:        FieldTypeInt,
                        Description: "买二量",
                        Comment:     "买盘第二档数量",
                },
                "bid_price3": {
                        Name:        "bid_price3",
                        Type:        FieldTypeFloat64,
                        Description: "买三价",
                        Comment:     "买盘第三档价格",
                },
                "bid_volume3": {
                        Name:        "bid_volume3",
                        Type:        FieldTypeInt,
                        Description: "买三量",
                        Comment:     "买盘第三档数量",
                },
                "bid_price4": {
                        Name:        "bid_price4",
                        Type:        FieldTypeFloat64,
                        Description: "买四价",
                        Comment:     "买盘第四档价格",
                },
                "bid_volume4": {
                        Name:        "bid_volume4",
                        Type:        FieldTypeInt,
                        Description: "买四量",
                        Comment:     "买盘第四档数量",
                },
                "bid_price5": {
                        Name:        "bid_price5",
                        Type:        FieldTypeFloat64,
                        Description: "买五价",
                        Comment:     "买盘第五档价格",
                },
                "bid_volume5": {
                        Name:        "bid_volume5",
                        Type:        FieldTypeInt,
                        Description: "买五量",
                        Comment:     "买盘第五档数量",
                },
                "ask_price1": {
                        Name:        "ask_price1",
                        Type:        FieldTypeFloat64,
                        Description: "卖一价",
                        Comment:     "卖盘第一档价格",
                },
                "ask_volume1": {
                        Name:        "ask_volume1",
                        Type:        FieldTypeInt,
                        Description: "卖一量",
                        Comment:     "卖盘第一档数量",
                },
                "ask_price2": {
                        Name:        "ask_price2",
                        Type:        FieldTypeFloat64,
                        Description: "卖二价",
                        Comment:     "卖盘第二档价格",
                },
                "ask_volume2": {
                        Name:        "ask_volume2",
                        Type:        FieldTypeInt,
                        Description: "卖二量",
                        Comment:     "卖盘第二档数量",
                },
                "ask_price3": {
                        Name:        "ask_price3",
                        Type:        FieldTypeFloat64,
                        Description: "卖三价",
                        Comment:     "卖盘第三档价格",
                },
                "ask_volume3": {
                        Name:        "ask_volume3",
                        Type:        FieldTypeInt,
                        Description: "卖三量",
                        Comment:     "卖盘第三档数量",
                },
                "ask_price4": {
                        Name:        "ask_price4",
                        Type:        FieldTypeFloat64,
                        Description: "卖四价",
                        Comment:     "卖盘第四档价格",
                },
                "ask_volume4": {
                        Name:        "ask_volume4",
                        Type:        FieldTypeInt,
                        Description: "卖四量",
                        Comment:     "卖盘第四档数量",
                },
                "ask_price5": {
                        Name:        "ask_price5",
                        Type:        FieldTypeFloat64,
                        Description: "卖五价",
                        Comment:     "卖盘第五档价格",
                },
                "ask_volume5": {
                        Name:        "ask_volume5",
                        Type:        FieldTypeInt,
                        Description: "卖五量",
                        Comment:     "卖盘第五档数量",
                },
                // 内外盘数据
                "inner_disc": {
                        Name:        "inner_disc",
                        Type:        FieldTypeInt,
                        Description: "内盘",
                        Comment:     "主动卖出成交量",
                },
                "outer_disc": {
                        Name:        "outer_disc",
                        Type:        FieldTypeInt,
                        Description: "外盘",
                        Comment:     "主动买入成交量",
                },
                // 财务指标
                "turnover_rate": {
                        Name:        "turnover_rate",
                        Type:        FieldTypeFloat64,
                        Description: "换手率",
                        Comment:     "成交量占流通股本的比例",
                },
                "pe": {
                        Name:        "pe",
                        Type:        FieldTypeFloat64,
                        Description: "市盈率",
                        Comment:     "股价与每股收益的比率",
                },
                "pb": {
                        Name:        "pb",
                        Type:        FieldTypeFloat64,
                        Description: "市净率",
                        Comment:     "股价与每股净资产的比率",
                },
                "amplitude": {
                        Name:        "amplitude",
                        Type:        FieldTypeFloat64,
                        Description: "振幅",
                        Comment:     "最高价与最低价的差值占昨收价的比例",
                },
                "circulation": {
                        Name:        "circulation",
                        Type:        FieldTypeFloat64,
                        Description: "流通市值(亿元)",
                        Comment:     "流通股本的市场价值",
                },
                "market_value": {
                        Name:        "market_value",
                        Type:        FieldTypeFloat64,
                        Description: "总市值(亿元)",
                        Comment:     "总股本的市场价值",
                },
                "limit_up": {
                        Name:        "limit_up",
                        Type:        FieldTypeFloat64,
                        Description: "涨停价",
                        Comment:     "当日涨停价格",
                },
                "limit_down": {
                        Name:        "limit_down",
                        Type:        FieldTypeFloat64,
                        Description: "跌停价",
                        Comment:     "当日跌停价格",
                },
                // 时间信息
                "timestamp": {
                        Name:        "timestamp",
                        Type:        FieldTypeTime,
                        Description: "数据时间",
                        Comment:     "数据获取时间戳",
                        Required:    true,
                },
        },
        FieldOrder: []string{
                "symbol", "name", "price", "change", "change_percent", "market_code",
                "volume", "turnover", "open", "high", "low", "prev_close",
                "bid_price1", "bid_volume1", "bid_price2", "bid_volume2", "bid_price3", "bid_volume3",
                "bid_price4", "bid_volume4", "bid_price5", "bid_volume5",
                "ask_price1", "ask_volume1", "ask_price2", "ask_volume2", "ask_price3", "ask_volume3",
                "ask_price4", "ask_volume4", "ask_price5", "ask_volume5",
                "inner_disc", "outer_disc",
                "turnover_rate", "pe", "pb", "amplitude", "circulation", "market_value",
                "limit_up", "limit_down", "timestamp",
        },
}

// StockDataToStructuredData 将 StockData 转换为 StructuredData
func StockDataToStructuredData(stockData StockData) (*StructuredData, error) <span class="cov2" title="2">{
        sd := NewStructuredData(StockDataSchema)
        sd.Timestamp = stockData.Timestamp

        // 设置所有字段值
        fieldMappings := map[string]interface{}{
                "symbol":         stockData.Symbol,
                "name":           stockData.Name,
                "price":          stockData.Price,
                "change":         stockData.Change,
                "change_percent": stockData.ChangePercent,
                "market_code":    stockData.MarketCode,
                "volume":         stockData.Volume,
                "turnover":       stockData.Turnover,
                "open":           stockData.Open,
                "high":           stockData.High,
                "low":            stockData.Low,
                "prev_close":     stockData.PrevClose,
                "bid_price1":     stockData.BidPrice1,
                "bid_volume1":    stockData.BidVolume1,
                "bid_price2":     stockData.BidPrice2,
                "bid_volume2":    stockData.BidVolume2,
                "bid_price3":     stockData.BidPrice3,
                "bid_volume3":    stockData.BidVolume3,
                "bid_price4":     stockData.BidPrice4,
                "bid_volume4":    stockData.BidVolume4,
                "bid_price5":     stockData.BidPrice5,
                "bid_volume5":    stockData.BidVolume5,
                "ask_price1":     stockData.AskPrice1,
                "ask_volume1":    stockData.AskVolume1,
                "ask_price2":     stockData.AskPrice2,
                "ask_volume2":    stockData.AskVolume2,
                "ask_price3":     stockData.AskPrice3,
                "ask_volume3":    stockData.AskVolume3,
                "ask_price4":     stockData.AskPrice4,
                "ask_volume4":    stockData.AskVolume4,
                "ask_price5":     stockData.AskPrice5,
                "ask_volume5":    stockData.AskVolume5,
                "inner_disc":     stockData.InnerDisc,
                "outer_disc":     stockData.OuterDisc,
                "turnover_rate":  stockData.TurnoverRate,
                "pe":             stockData.PE,
                "pb":             stockData.PB,
                "amplitude":      stockData.Amplitude,
                "circulation":    stockData.Circulation,
                "market_value":   stockData.MarketValue,
                "limit_up":       stockData.LimitUp,
                "limit_down":     stockData.LimitDown,
                "timestamp":      stockData.Timestamp,
        }

        // 设置字段值
        for fieldName, value := range fieldMappings </span><span class="cov7" title="86">{
                if err := sd.SetField(fieldName, value); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov2" title="2">return sd, nil</span>
}

// StructuredDataToStockData 将 StructuredData 转换为 StockData
func StructuredDataToStockData(sd *StructuredData) (*StockData, error) <span class="cov2" title="3">{
        if sd.Schema.Name != "stock_data" </span><span class="cov1" title="1">{
                return nil, NewStructuredDataError(ErrSchemaNotFound, "", "schema is not stock_data")
        }</span>

        <span class="cov2" title="2">stockData := &amp;StockData{}

        // 获取字段值的辅助函数
        getString := func(fieldName string) string </span><span class="cov3" title="4">{
                if value, err := sd.GetField(fieldName); err == nil &amp;&amp; value != nil </span><span class="cov3" title="4">{
                        if str, ok := value.(string); ok </span><span class="cov3" title="4">{
                                return str
                        }</span>
                }
                <span class="cov0" title="0">return ""</span>
        }

        <span class="cov2" title="2">getFloat64 := func(fieldName string) float64 </span><span class="cov7" title="52">{
                if value, err := sd.GetField(fieldName); err == nil &amp;&amp; value != nil </span><span class="cov6" title="28">{
                        if f, ok := value.(float64); ok </span><span class="cov6" title="28">{
                                return f
                        }</span>
                }
                <span class="cov5" title="24">return 0</span>
        }

        <span class="cov2" title="2">getInt64 := func(fieldName string) int64 </span><span class="cov6" title="28">{
                if value, err := sd.GetField(fieldName); err == nil &amp;&amp; value != nil </span><span class="cov5" title="15">{
                        switch v := value.(type) </span>{
                        case int64:<span class="cov5" title="15">
                                return v</span>
                        case int:<span class="cov0" title="0">
                                return int64(v)</span>
                        case int32:<span class="cov0" title="0">
                                return int64(v)</span>
                        }
                }
                <span class="cov4" title="13">return 0</span>
        }

        <span class="cov2" title="2">getTime := func(fieldName string) time.Time </span><span class="cov2" title="2">{
                if value, err := sd.GetField(fieldName); err == nil &amp;&amp; value != nil </span><span class="cov2" title="2">{
                        if t, ok := value.(time.Time); ok </span><span class="cov2" title="2">{
                                return t
                        }</span>
                }
                <span class="cov0" title="0">return time.Time{}</span>
        }

        // 填充 StockData 字段
        <span class="cov2" title="2">stockData.Symbol = getString("symbol")
        stockData.Name = getString("name")
        stockData.Price = getFloat64("price")
        stockData.Change = getFloat64("change")
        stockData.ChangePercent = getFloat64("change_percent")
        stockData.MarketCode = getInt64("market_code")
        stockData.Volume = getInt64("volume")
        stockData.Turnover = getFloat64("turnover")
        stockData.Open = getFloat64("open")
        stockData.High = getFloat64("high")
        stockData.Low = getFloat64("low")
        stockData.PrevClose = getFloat64("prev_close")
        stockData.BidPrice1 = getFloat64("bid_price1")
        stockData.BidVolume1 = getInt64("bid_volume1")
        stockData.BidPrice2 = getFloat64("bid_price2")
        stockData.BidVolume2 = getInt64("bid_volume2")
        stockData.BidPrice3 = getFloat64("bid_price3")
        stockData.BidVolume3 = getInt64("bid_volume3")
        stockData.BidPrice4 = getFloat64("bid_price4")
        stockData.BidVolume4 = getInt64("bid_volume4")
        stockData.BidPrice5 = getFloat64("bid_price5")
        stockData.BidVolume5 = getInt64("bid_volume5")
        stockData.AskPrice1 = getFloat64("ask_price1")
        stockData.AskVolume1 = getInt64("ask_volume1")
        stockData.AskPrice2 = getFloat64("ask_price2")
        stockData.AskVolume2 = getInt64("ask_volume2")
        stockData.AskPrice3 = getFloat64("ask_price3")
        stockData.AskVolume3 = getInt64("ask_volume3")
        stockData.AskPrice4 = getFloat64("ask_price4")
        stockData.AskVolume4 = getInt64("ask_volume4")
        stockData.AskPrice5 = getFloat64("ask_price5")
        stockData.AskVolume5 = getInt64("ask_volume5")
        stockData.InnerDisc = getInt64("inner_disc")
        stockData.OuterDisc = getInt64("outer_disc")
        stockData.TurnoverRate = getFloat64("turnover_rate")
        stockData.PE = getFloat64("pe")
        stockData.PB = getFloat64("pb")
        stockData.Amplitude = getFloat64("amplitude")
        stockData.Circulation = getFloat64("circulation")
        stockData.MarketValue = getFloat64("market_value")
        stockData.LimitUp = getFloat64("limit_up")
        stockData.LimitDown = getFloat64("limit_down")
        stockData.Timestamp = getTime("timestamp")

        return stockData, nil</span>
}

// SetFieldSafe 安全地设置字段值，包含完整的验证
func (sd *StructuredData) SetFieldSafe(fieldName string, value interface{}) error <span class="cov5" title="16">{
        fieldDef, exists := sd.Schema.Fields[fieldName]
        if !exists </span><span class="cov1" title="1">{
                return NewStructuredDataError(ErrFieldNotFound, fieldName, "field not found in schema")
        }</span>

        // 完整的字段值验证
        <span class="cov5" title="15">if err := ValidateFieldValue(fieldName, value, fieldDef); err != nil </span><span class="cov2" title="2">{
                return err
        }</span>

        <span class="cov4" title="13">sd.Values[fieldName] = value
        return nil</span>
}

// ValidateDataComplete 完整的数据验证（比 ValidateData 更严格）
func (sd *StructuredData) ValidateDataComplete() error <span class="cov3" title="4">{
        // 首先验证模式
        if err := ValidateSchema(sd.Schema); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // 验证所有字段值
        <span class="cov2" title="3">for fieldName, fieldDef := range sd.Schema.Fields </span><span class="cov8" title="115">{
                value := sd.Values[fieldName]
                if err := ValidateFieldValue(fieldName, value, fieldDef); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }

        // 检查是否有多余的字段
        <span class="cov2" title="2">for fieldName := range sd.Values </span><span class="cov3" title="5">{
                if _, exists := sd.Schema.Fields[fieldName]; !exists </span><span class="cov1" title="1">{
                        return NewStructuredDataError(ErrFieldNotFound, fieldName, "unknown field in data")
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// GetFieldSafe 安全地获取字段值，包含类型转换
func (sd *StructuredData) GetFieldSafe(fieldName string, targetType FieldType) (interface{}, error) <span class="cov3" title="5">{
        fieldDef, exists := sd.Schema.Fields[fieldName]
        if !exists </span><span class="cov1" title="1">{
                return nil, NewStructuredDataError(ErrFieldNotFound, fieldName, "field not found in schema")
        }</span>

        <span class="cov3" title="4">value, exists := sd.Values[fieldName]
        if !exists </span><span class="cov2" title="2">{
                // 返回默认值
                if fieldDef.DefaultValue != nil </span><span class="cov0" title="0">{
                        return fieldDef.DefaultValue, nil
                }</span>
                <span class="cov2" title="2">if fieldDef.Required </span><span class="cov1" title="1">{
                        return nil, NewStructuredDataError(ErrRequiredFieldMissing, fieldName, "required field missing")
                }</span>
                <span class="cov1" title="1">return nil, nil</span>
        }

        // 类型匹配检查
        <span class="cov2" title="2">if targetType != fieldDef.Type </span><span class="cov1" title="1">{
                return nil, NewStructuredDataError(ErrInvalidFieldType, fieldName, fmt.Sprintf("field type is %s, requested %s", fieldDef.Type.String(), targetType.String()))
        }</span>

        <span class="cov1" title="1">return value, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package subscriber

import (
        "context"
        "fmt"
        "sync"
        "time"

        "stocksub/pkg/logger"

        "github.com/sirupsen/logrus"
)

// DefaultSubscriber 默认订阅器实现
type DefaultSubscriber struct {
        provider      Provider
        subscriptions map[string]*Subscription
        subsMu        sync.RWMutex
        eventChan     chan UpdateEvent
        ctx           context.Context
        cancel        context.CancelFunc
        wg            sync.WaitGroup
        maxSubs       int
        minInterval   time.Duration
        maxInterval   time.Duration
        log           *logrus.Entry
}

// NewSubscriber 创建新的订阅器
func NewSubscriber(provider Provider) *DefaultSubscriber <span class="cov0" title="0">{
        return &amp;DefaultSubscriber{
                provider:      provider,
                subscriptions: make(map[string]*Subscription),
                eventChan:     make(chan UpdateEvent, 1000),
                maxSubs:       100,
                minInterval:   1 * time.Second,
                maxInterval:   1 * time.Hour,
                log:           logger.WithComponent("Subscriber"),
        }
}</span>

// Subscribe 订阅股票
func (s *DefaultSubscriber) Subscribe(symbol string, interval time.Duration, callback CallbackFunc) error <span class="cov0" title="0">{
        if symbol == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("symbol cannot be empty")
        }</span>

        <span class="cov0" title="0">if callback == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("callback cannot be nil")
        }</span>

        <span class="cov0" title="0">if interval &lt; s.minInterval </span><span class="cov0" title="0">{
                return fmt.Errorf("interval too short, minimum is %v", s.minInterval)
        }</span>

        <span class="cov0" title="0">if interval &gt; s.maxInterval </span><span class="cov0" title="0">{
                return fmt.Errorf("interval too long, maximum is %v", s.maxInterval)
        }</span>

        <span class="cov0" title="0">if !s.provider.IsSymbolSupported(symbol) </span><span class="cov0" title="0">{
                return fmt.Errorf("symbol %s is not supported by provider %s", symbol, s.provider.Name())
        }</span>

        <span class="cov0" title="0">s.subsMu.Lock()
        defer s.subsMu.Unlock()

        if len(s.subscriptions) &gt;= s.maxSubs </span><span class="cov0" title="0">{
                return fmt.Errorf("maximum subscriptions (%d) reached", s.maxSubs)
        }</span>

        // 如果已存在订阅，更新它
        <span class="cov0" title="0">if existing, exists := s.subscriptions[symbol]; exists </span><span class="cov0" title="0">{
                existing.Interval = interval
                existing.Callback = callback
                existing.Active = true
                s.log.Infof("Updated subscription for %s with interval %v", symbol, interval)
        }</span> else<span class="cov0" title="0"> {
                s.subscriptions[symbol] = &amp;Subscription{
                        Symbol:   symbol,
                        Interval: interval,
                        Callback: callback,
                        Active:   true,
                }
                s.log.Infof("Added subscription for %s with interval %v", symbol, interval)
        }</span>

        // 发送订阅成功事件
        <span class="cov0" title="0">select </span>{
        case s.eventChan &lt;- UpdateEvent{
                Type:   EventTypeSubscribed,
                Symbol: symbol,
                Time:   time.Now(),
        }:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                s.log.Infof("Warning: event channel full, dropping subscription event for %s", symbol)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Unsubscribe 取消订阅
func (s *DefaultSubscriber) Unsubscribe(symbol string) error <span class="cov0" title="0">{
        s.subsMu.Lock()
        defer s.subsMu.Unlock()

        if _, exists := s.subscriptions[symbol]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("no subscription found for symbol %s", symbol)
        }</span>

        <span class="cov0" title="0">delete(s.subscriptions, symbol)
        s.log.Infof("Removed subscription for %s", symbol)

        // 发送取消订阅事件
        select </span>{
        case s.eventChan &lt;- UpdateEvent{
                Type:   EventTypeUnsubscribed,
                Symbol: symbol,
                Time:   time.Now(),
        }:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                s.log.Infof("Warning: event channel full, dropping unsubscription event for %s", symbol)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Start 启动订阅器
func (s *DefaultSubscriber) Start(ctx context.Context) error <span class="cov0" title="0">{
        s.ctx, s.cancel = context.WithCancel(ctx)

        s.wg.Add(1)
        go s.runSubscriptions()

        s.log.Infof("Started with provider: %s", s.provider.Name())
        return nil
}</span>

// Stop 停止订阅器
func (s *DefaultSubscriber) Stop() error <span class="cov0" title="0">{
        if s.cancel != nil </span><span class="cov0" title="0">{
                s.cancel()
        }</span>
        <span class="cov0" title="0">s.wg.Wait()
        close(s.eventChan)
        s.log.Infof("Stopped")
        return nil</span>
}

func (s *DefaultSubscriber) GetSubscriptions() []Subscription <span class="cov0" title="0">{
        // 获取读锁：允许多个 goroutine 同时读取，但阻止写操作
        // 这确保在遍历 subscriptions map 时不会发生并发修改
        s.subsMu.RLock()
        // defer 确保函数退出时释放读锁，即使发生 panic 也能正确释放
        defer s.subsMu.RUnlock()

        // 预分配切片容量：使用 make([]Subscription, 0, len(s.subscriptions))
        // - 初始长度为 0，避免创建零值元素
        // - 容量为当前订阅数量，避免后续 append 操作引起的动态扩容
        // - 这是 Go 中高效切片操作的最佳实践
        subs := make([]Subscription, 0, len(s.subscriptions))

        // 遍历所有订阅：range 操作在读锁保护下是安全的
        // 注意：这里遍历的是 map 的值，Go 的 map 遍历顺序是随机的
        for _, sub := range s.subscriptions </span><span class="cov0" title="0">{
                // 值复制：append(subs, *sub) 创建 Subscription 结构体的副本
                // 使用指针解引用 (*sub) 而不是直接传递指针，原因：
                // 1. 防止外部代码通过返回的指针修改内部状态
                // 2. 避免内存泄漏（外部持有内部指针可能阻止 GC）
                // 3. 提供快照语义：返回调用时刻的状态副本
                subs = append(subs, *sub)
        }</span>

        // 返回订阅副本切片：外部可以安全地遍历、排序或修改返回的切片
        // 而不会影响订阅器的内部状态
        <span class="cov0" title="0">return subs</span>
}

// SetProvider 设置数据提供商
func (s *DefaultSubscriber) SetProvider(provider Provider) <span class="cov0" title="0">{
        s.provider = provider
        s.log.Infof("Provider changed to: %s", provider.Name())
}</span>

// GetEventChannel 获取事件通道
func (s *DefaultSubscriber) GetEventChannel() &lt;-chan UpdateEvent <span class="cov0" title="0">{
        return s.eventChan
}</span>

// SetMaxSubscriptions 设置最大订阅数
func (s *DefaultSubscriber) SetMaxSubscriptions(max int) <span class="cov0" title="0">{
        s.maxSubs = max
}</span>

// SetIntervalLimits 设置订阅间隔限制
func (s *DefaultSubscriber) SetIntervalLimits(min, max time.Duration) <span class="cov0" title="0">{
        s.minInterval = min
        s.maxInterval = max
}</span>

// runSubscriptions 是订阅服务的核心运行方法，负责管理所有股票数据的订阅和更新
func (s *DefaultSubscriber) runSubscriptions() <span class="cov0" title="0">{
        // defer 关键字：确保函数退出时执行 s.wg.Done()
        // WaitGroup 是 Go 的同步原语，用于等待一组 goroutine 完成
        // Done() 方法会将计数器减1，告知主程序此 goroutine 已完成
        defer s.wg.Done()

        s.log.Infof("runSubscriptions started")

        // time.NewTicker 创建一个定时器，每1秒触发一次
        // Ticker 是 Go 中用于定期执行任务的机制，类似于定时器
        // 这里使用1秒固定间隔作为检查周期，而不是每个订阅的具体间隔
        ticker := time.NewTicker(1 * time.Second) // 使用固定的1秒间隔

        // defer 确保函数退出时停止 ticker，防止 goroutine 泄漏
        // 这是 Go 中资源管理的最佳实践
        defer ticker.Stop()

        // map 数据结构：记录每个股票代码的最后获取时间
        // key: 股票代码(string), value: 最后获取时间(time.Time)
        lastFetchTime := make(map[string]time.Time)

        s.log.Infof("Starting main subscription loop with 1s ticker")

        // 无限循环：这是 Go 中事件驱动编程的常见模式
        for </span><span class="cov0" title="0">{
                // select 语句：Go 的多路复用机制，类似于 switch 但用于 channel 操作
                // 它会阻塞等待，直到某个 case 可以执行
                select </span>{
                // 监听上下文取消信号
                // context.Context 是 Go 中用于控制 goroutine 生命周期的标准方式
                // s.ctx.Done() 返回一个 channel，当上下文被取消时会关闭
                case &lt;-s.ctx.Done():<span class="cov0" title="0">
                        s.log.Infof("Context done, stopping subscription loop")
                        return</span> // 退出函数，结束此 goroutine

                // 监听定时器触发
                // ticker.C 是一个 time channel，每1秒会收到一个时间值
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // time.Now() 获取当前时间
                        now := time.Now()
                        s.log.Debugf("Ticker fired at %v", now.Format("15:04:05.000"))

                        // === 核心业务逻辑：检查哪些订阅需要更新数据 ===

                        // sync.RWMutex 读写锁：允许多个读操作并发，但写操作独占
                        // RLock() 获取读锁，用于安全地遍历 subscriptions map
                        s.subsMu.RLock()

                        // 声明切片存储需要获取数据的股票代码
                        // []string 是字符串切片，Go 中的动态数组
                        var symbolsToFetch []string

                        // range 遍历 map：for key, value := range map
                        // s.subscriptions 存储所有的订阅信息
                        for symbol, sub := range s.subscriptions </span><span class="cov0" title="0">{
                                // 检查订阅是否激活
                                if !sub.Active </span><span class="cov0" title="0">{
                                        continue</span> // 跳过未激活的订阅
                                }

                                // 检查是否需要获取新数据
                                <span class="cov0" title="0">lastFetch, exists := lastFetchTime[symbol]

                                // 条件判断：
                                // 1. 如果从未获取过数据 (!exists)
                                // 2. 或者距离上次获取的时间 &gt;= 订阅间隔 (now.Sub(lastFetch) &gt;= sub.Interval)
                                // 则需要获取新数据
                                if !exists || now.Sub(lastFetch) &gt;= sub.Interval </span><span class="cov0" title="0">{
                                        // append() 是 Go 内置函数，用于向切片添加元素
                                        symbolsToFetch = append(symbolsToFetch, symbol)
                                        // 更新最后获取时间 ??
                                        lastFetchTime[symbol] = now
                                }</span>
                        }
                        // RUnlock() 释放读锁，允许其他 goroutine 进行读写操作
                        <span class="cov0" title="0">s.subsMu.RUnlock()

                        // 如果有需要获取数据的股票
                        if len(symbolsToFetch) &gt; 0 </span><span class="cov0" title="0">{
                                s.log.Infof("Need to fetch data for symbols: %v", symbolsToFetch)

                                // go 关键字：启动新的 goroutine（轻量级线程）
                                // 这是 Go 的核心特性 - 并发编程
                                // 异步执行数据获取，不阻塞主循环
                                go s.fetchAndNotify(symbolsToFetch)
                        }</span> else<span class="cov0" title="0"> {
                                s.log.Infof("No symbols need updating at this time")
                        }</span>
                }
        }
}

// fetchAndNotify 获取股票数据并通知相关订阅者
//
// 功能说明：
//
//        这是订阅系统的核心数据处理方法，负责：
//        1. 调用数据提供商 API 批量获取多个股票的实时数据
//        2. 将获取的数据分发给对应的订阅回调函数
//        3. 处理数据获取和回调执行过程中的各种错误情况
//        4. 通过事件通道发送相应的事件通知
//
// 参数说明：
//
//        symbols []string - 需要获取数据的股票代码列表，格式如 ["600000", "000001", "300750"]
//
// 设计要点：
//   - 使用超时控制防止 API 调用无限等待
//   - 批量获取减少 API 调用次数，提高效率
//   - 异步回调避免阻塞主订阅循环
//   - 错误隔离确保单个股票的错误不影响其他股票
func (s *DefaultSubscriber) fetchAndNotify(symbols []string) <span class="cov0" title="0">{
        s.log.Infof("Starting fetchAndNotify for symbols: %v", symbols)

        // === 第一步：设置超时上下文 ===
        // context.WithTimeout 创建一个带超时的上下文，继承自 s.ctx
        // 30秒超时是为了防止 API 调用无限等待，保证系统响应性
        // 如果数据提供商响应慢或网络有问题，会在30秒后自动取消请求
        ctx, cancel := context.WithTimeout(s.ctx, 30*time.Second)
        // defer 确保函数退出时取消上下文，释放相关资源
        // 这是 Go 中资源管理的最佳实践
        defer cancel()

        // === 第二步：调用数据提供商 API 获取数据 ===
        // 记录开始时间，用于计算 API 调用耗时（性能监控）
        start := time.Now()

        // 调用提供商的 FetchData 方法批量获取股票数据
        // 这里是多态调用：s.provider 实现了 Provider 接口
        // 具体可能是 TencentProvider、YahooProvider 等不同实现
        data, err := s.provider.FetchData(ctx, symbols)

        // 计算 API 调用总耗时，用于性能分析和调试
        elapsed := time.Since(start)

        // === 第三步：处理 API 调用错误 ===
        if err != nil </span><span class="cov0" title="0">{
                // 记录错误日志，包含耗时信息便于分析超时问题
                s.log.Infof("Fetch data error after %v: %v", elapsed, err)

                // 错误传播：为每个请求的股票代码发送错误通知
                // 这确保了所有等待数据的订阅者都能收到错误信息
                // 而不是静默失败
                for _, symbol := range symbols </span><span class="cov0" title="0">{
                        s.notifyError(symbol, err)
                }</span>
                <span class="cov0" title="0">return</span> // 提前返回，不继续处理数据
        }

        // 记录成功日志，包含性能信息：耗时、数据条数、请求股票数
        // 这对于监控系统性能和排查问题很有帮助
        <span class="cov0" title="0">s.log.Infof("Fetch data completed in %v, received %d records for %d symbols", elapsed, len(data), len(symbols))

        // === 第四步：组织数据结构 ===
        // 将切片数据转换为 map 结构，key 是股票代码，value 是股票数据
        // 这样可以通过 O(1) 时间复杂度快速查找特定股票的数据
        // 而不需要遍历整个切片（O(n) 复杂度）
        dataMap := make(map[string]StockData)
        for _, stock := range data </span><span class="cov0" title="0">{
                // 使用股票代码作为 key 建立索引
                dataMap[stock.Symbol] = stock
        }</span>

        // === 第五步：分发数据给订阅者 ===
        // 获取读锁，保护对 subscriptions map 的并发访问
        // 这里只需要读锁因为我们只是读取订阅信息，不修改
        <span class="cov0" title="0">s.subsMu.RLock()

        // 遍历本次请求的所有股票代码
        for _, symbol := range symbols </span><span class="cov0" title="0">{
                // 检查该股票是否还有活跃的订阅
                // 订阅可能在数据获取期间被取消，所以需要重新检查
                if sub, exists := s.subscriptions[symbol]; exists &amp;&amp; sub.Active </span><span class="cov0" title="0">{
                        // 检查是否获取到了该股票的数据
                        if stockData, found := dataMap[symbol]; found </span><span class="cov0" title="0">{
                                // 异步调用回调函数，避免阻塞当前处理流程
                                // 使用 goroutine 确保：
                                // 1. 回调函数执行时间长不会影响其他股票的处理
                                // 2. 回调函数中的 panic 不会影响当前 goroutine
                                // 3. 多个股票的回调可以并发执行，提高效率
                                go s.notifyCallback(sub, stockData)
                        }</span> else<span class="cov0" title="0"> {
                                // 数据缺失处理：API 返回成功但没有包含某个股票的数据
                                // 这种情况可能发生在：
                                // - 股票代码错误或已停牌
                                // - 数据提供商暂时无法获取该股票数据
                                // - API 响应格式异常
                                go s.notifyError(symbol, fmt.Errorf("no data received for symbol %s", symbol))
                        }</span>
                }
                // 如果订阅不存在或已停用，则跳过该股票
                // 这是正常情况，不需要记录错误
        }

        // 释放读锁，允许其他 goroutine 进行读写操作
        <span class="cov0" title="0">s.subsMu.RUnlock()</span>
}

// notifyCallback 通知回调函数
// 功能：
//   - 对订阅 sub 执行其回调函数 Callback，传入最新的数据 data。
//   - 保证回调执行的健壮性：从 panic 中恢复并记录日志；如果回调返回 error，记录并通过事件通道发出错误事件。
//   - 在回调完成后，尝试通过事件通道发出一条数据更新事件（非阻塞发送，通道满则丢弃以避免阻塞业务线程）。
//
// 设计要点：
//  1. panic 恢复：任何第三方/业务回调都可能产生 panic；使用 defer + recover 保证不会影响订阅循环或其他 goroutine。
//  2. 错误分流：回调返回的 error 会被转化为 EventTypeError 事件发送（非阻塞），便于统一上报与监控。
//  3. 事件发送策略：采用 select 非阻塞写入 eventChan。若通道已满，优先保证主流程不卡顿，因此静默丢弃。
//     如需“必达”语义，应在上层增加更大的缓冲/专用事件处理器/或重试与丢弃统计。
//  4. 时序说明：本方法通常在独立 goroutine 中调用（见 fetchAndNotify 中的 go s.notifyCallback），
//     因此内部不得产生长时间阻塞操作（例如：同步写满通道）。
func (s *DefaultSubscriber) notifyCallback(sub *Subscription, data StockData) <span class="cov0" title="0">{
        // 1) 保护区：确保回调产生的任何 panic 不会蔓延至系统其他部分
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        // 这里使用 Infof 记录；若需更高告警等级，可在日志配置中调整
                        s.log.Infof("Callback panic for %s: %v", sub.Symbol, r)
                }</span>
        }()

        // 2) 执行业务回调：回调若返回错误，既记录日志也发出错误事件，便于上层统一感知
        // 注意：这里不对错误进行重试，由上层策略（如 Manager）或回调方自行决定
        <span class="cov0" title="0">if err := sub.Callback(data); err != nil </span><span class="cov0" title="0">{
                s.log.Infof("Callback error for %s: %v", sub.Symbol, err)
                // 非阻塞错误通知：若通道满则丢弃，避免阻塞当前 goroutine
                s.notifyError(sub.Symbol, err)
        }</span>

        // 3) 发送数据更新事件：
        //    - 无论回调是否返回错误，都会尝试发送数据事件（便于消费者同时获得数据与错误上下文）
        //    - 非阻塞发送：当 eventChan 已满时直接丢弃，保障系统整体吞吐不被背压影响
        <span class="cov0" title="0">select </span>{
        case s.eventChan &lt;- UpdateEvent{
                Type:   EventTypeData, // 事件类型：数据更新
                Symbol: sub.Symbol,    // 标的代码
                Data:   &amp;data,         // 本次推送的数据（指针，避免大对象复制）
                Time:   time.Now(),    // 事件时间戳（用于下游统计/排序）
        }:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
                // 事件通道满，丢弃事件（如需观测丢弃比例，可在此处增加计数器或 debug 日志）
        }
}

// notifyError 通知错误
func (s *DefaultSubscriber) notifyError(symbol string, err error) <span class="cov0" title="0">{
        select </span>{
        case s.eventChan &lt;- UpdateEvent{
                Type:   EventTypeError,
                Symbol: symbol,
                Error:  err,
                Time:   time.Now(),
        }:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
                // 事件通道满，丢弃事件
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package subscriber

import (
        "context"
        "encoding/json"
        "time"
)

// StockData 股票数据结构
type StockData struct {
        // 基本信息
        Symbol        string  `json:"symbol"`         // 股票代码
        Name          string  `json:"name"`           // 股票名称
        Price         float64 `json:"price"`          // 当前价格
        Change        float64 `json:"change"`         // 涨跌额
        ChangePercent float64 `json:"change_percent"` // 涨跌幅
        MarketCode    int64   `json:"market_code"`    // 市场分类代码

        // 交易数据
        Volume    int64   `json:"volume"`     // 成交量
        Turnover  float64 `json:"turnover"`   // 成交额(元)
        Open      float64 `json:"open"`       // 开盘价
        High      float64 `json:"high"`       // 最高价
        Low       float64 `json:"low"`        // 最低价
        PrevClose float64 `json:"prev_close"` // 昨收价

        // 5档买卖盘数据
        BidPrice1  float64 `json:"bid_price1"`  // 买一价
        BidVolume1 int64   `json:"bid_volume1"` // 买一量
        BidPrice2  float64 `json:"bid_price2"`  // 买二价
        BidVolume2 int64   `json:"bid_volume2"` // 买二量
        BidPrice3  float64 `json:"bid_price3"`  // 买三价
        BidVolume3 int64   `json:"bid_volume3"` // 买三量
        BidPrice4  float64 `json:"bid_price4"`  // 买四价
        BidVolume4 int64   `json:"bid_volume4"` // 买四量
        BidPrice5  float64 `json:"bid_price5"`  // 买五价
        BidVolume5 int64   `json:"bid_volume5"` // 买五量
        AskPrice1  float64 `json:"ask_price1"`  // 卖一价
        AskVolume1 int64   `json:"ask_volume1"` // 卖一量
        AskPrice2  float64 `json:"ask_price2"`  // 卖二价
        AskVolume2 int64   `json:"ask_volume2"` // 卖二量
        AskPrice3  float64 `json:"ask_price3"`  // 卖三价
        AskVolume3 int64   `json:"ask_volume3"` // 卖三量
        AskPrice4  float64 `json:"ask_price4"`  // 卖四价
        AskVolume4 int64   `json:"ask_volume4"` // 卖四量
        AskPrice5  float64 `json:"ask_price5"`  // 卖五价
        AskVolume5 int64   `json:"ask_volume5"` // 卖五量

        // 内外盘数据
        InnerDisc int64 `json:"inner_disc"` // 内盘
        OuterDisc int64 `json:"outer_disc"` // 外盘

        // 财务指标
        TurnoverRate float64 `json:"turnover_rate"` // 换手率
        PE           float64 `json:"pe"`            // 市盈率
        PB           float64 `json:"pb"`            // 市净率
        Amplitude    float64 `json:"amplitude"`     // 振幅
        Circulation  float64 `json:"circulation"`   // 流通市值(亿元)
        MarketValue  float64 `json:"market_value"`  // 总市值(亿元)
        LimitUp      float64 `json:"limit_up"`      // 涨停价
        LimitDown    float64 `json:"limit_down"`    // 跌停价

        // 时间信息
        Timestamp time.Time `json:"timestamp"` // 时间戳
}

// Subscription 订阅信息
type Subscription struct {
        Symbol   string        // 股票代码
        Interval time.Duration // 订阅间隔
        Callback CallbackFunc  // 回调函数
        Active   bool          // 是否激活
}

// CallbackFunc 数据回调函数类型
type CallbackFunc func(data StockData) error

// UpdateEvent 更新事件
type UpdateEvent struct {
        Type   EventType  `json:"type"`
        Symbol string     `json:"symbol"`
        Data   *StockData `json:"data,omitempty"`
        Error  error      `json:"error,omitempty"`
        Time   time.Time  `json:"timestamp"`
}

// EventType 事件类型
type EventType int

const (
        EventTypeData         EventType = iota // 数据更新
        EventTypeError                         // 错误事件
        EventTypeSubscribed                    // 订阅成功
        EventTypeUnsubscribed                  // 取消订阅
)

// Provider 数据提供商接口
type Provider interface {
        // Name 提供商名称
        Name() string

        // FetchData 获取股票数据
        FetchData(ctx context.Context, symbols []string) ([]StockData, error)

        // IsSymbolSupported 检查是否支持该股票代码
        IsSymbolSupported(symbol string) bool

        // GetRateLimit 获取请求限制信息
        GetRateLimit() time.Duration
}

// Subscriber 订阅器接口
type Subscriber interface {
        // Subscribe 订阅股票
        Subscribe(symbol string, interval time.Duration, callback CallbackFunc) error

        // Unsubscribe 取消订阅
        Unsubscribe(symbol string) error

        // Start 启动订阅器
        Start(ctx context.Context) error

        // Stop 停止订阅器
        Stop() error

        // GetSubscriptions 获取当前订阅列表
        GetSubscriptions() []Subscription

        // SetProvider 设置数据提供商
        SetProvider(provider Provider)
}

// MarshalStockData a helper to marshal stock data to json
func MarshalStockData(sd StockData) ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(sd)
}</span>

// UnmarshalStockData a helper to unmarshal stock data from json
func UnmarshalStockData(data []byte, sd *StockData) error <span class="cov0" title="0">{
        return json.Unmarshal(data, sd)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package cache

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "sync"
        "time"

        "stocksub/pkg/testkit/core"
)

// DiskCacheConfig 磁盘缓存配置
type DiskCacheConfig struct {
        BaseDir         string        `yaml:"base_dir"`         // 缓存文件基础目录
        MaxSize         int64         `yaml:"max_size"`         // 最大缓存条目数
        DefaultTTL      time.Duration `yaml:"default_ttl"`      // 默认生存时间
        CleanupInterval time.Duration `yaml:"cleanup_interval"` // 清理间隔
        FilePrefix      string        `yaml:"file_prefix"`      // 缓存文件前缀
}

// DiskCache 磁盘缓存实现
type DiskCache struct {
        mu        sync.RWMutex
        config    DiskCacheConfig
        stats     core.CacheStats
        entries   map[string]diskCacheEntry
        cacheDir  string
        closeChan chan struct{}
        closed    bool // 缓存是否已关闭
}

// diskCacheEntry 磁盘缓存条目
// 包含内存中的元数据和指向磁盘文件的引用
type diskCacheEntry struct {
        Key        string    // 缓存键
        Filepath   string    // 磁盘文件路径
        ExpireTime time.Time // 过期时间
        AccessTime time.Time // 最后访问时间
        CreateTime time.Time // 创建时间
        HitCount   int64     // 命中次数
        Size       int64     // 数据大小（字节）
}

// NewDiskCache 创建磁盘缓存实例
func NewDiskCache(config DiskCacheConfig) (*DiskCache, error) <span class="cov5" title="11">{
        if config.BaseDir == "" </span><span class="cov0" title="0">{
                config.BaseDir = os.TempDir()
        }</span>
        <span class="cov5" title="11">if config.FilePrefix == "" </span><span class="cov0" title="0">{
                config.FilePrefix = "stocksub_disk_cache"
        }</span>

        <span class="cov5" title="11">cacheDir := filepath.Join(config.BaseDir, config.FilePrefix)
        if err := os.MkdirAll(cacheDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("创建缓存目录失败: %w", err)
        }</span>

        <span class="cov5" title="11">dc := &amp;DiskCache{
                config:    config,
                entries:   make(map[string]diskCacheEntry),
                cacheDir:  cacheDir,
                closeChan: make(chan struct{}),
                stats: core.CacheStats{
                        MaxSize: config.MaxSize,
                        TTL:     config.DefaultTTL,
                },
        }

        // 启动定期清理协程
        if config.CleanupInterval &gt; 0 </span><span class="cov1" title="1">{
                go dc.cleanupWorker()
        }</span>

        // 加载现有的缓存元数据
        <span class="cov5" title="11">if err := dc.loadMetadata(); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("加载缓存元数据失败: %w", err)
        }</span>

        <span class="cov5" title="10">return dc, nil</span>
}

// Get 从磁盘缓存获取数据
func (dc *DiskCache) Get(ctx context.Context, key string) (interface{}, error) <span class="cov6" title="15">{
        dc.mu.RLock()
        if dc.closed </span><span class="cov1" title="1">{
                dc.mu.RUnlock()
                return nil, fmt.Errorf("cache is closed")
        }</span>
        <span class="cov6" title="14">entry, exists := dc.entries[key]
        dc.mu.RUnlock()

        if !exists </span><span class="cov4" title="6">{
                dc.stats.MissCount++
                return nil, core.NewTestKitError(core.ErrCacheMiss, "cache miss")
        }</span>

        // 检查是否过期
        <span class="cov4" title="8">if time.Now().After(entry.ExpireTime) </span><span class="cov1" title="1">{
                dc.mu.Lock()
                delete(dc.entries, key)
                dc.stats.MissCount++
                dc.stats.Size--
                dc.mu.Unlock()

                // 异步删除磁盘文件
                go os.Remove(entry.Filepath)
                return nil, core.NewTestKitError(core.ErrCacheMiss, "cache expired")
        }</span>

        // 从磁盘读取数据
        <span class="cov4" title="7">data, err := dc.readFromDisk(entry.Filepath)
        if err != nil </span><span class="cov0" title="0">{
                dc.stats.MissCount++
                return nil, fmt.Errorf("读取缓存数据失败: %w", err)
        }</span>

        // 更新访问统计
        <span class="cov4" title="7">dc.mu.Lock()
        entry.AccessTime = time.Now()
        entry.HitCount++
        dc.entries[key] = entry
        dc.stats.HitCount++
        dc.mu.Unlock()

        return data, nil</span>
}

// Set 向磁盘缓存设置数据
func (dc *DiskCache) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error <span class="cov10" title="114">{
        dc.mu.Lock()
        defer dc.mu.Unlock()

        if dc.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("cache is closed")
        }</span>

        <span class="cov10" title="114">if ttl &lt;= 0 </span><span class="cov9" title="106">{
                ttl = dc.config.DefaultTTL
        }</span>

        <span class="cov10" title="114">expireTime := time.Now().Add(ttl)

        // 序列化数据
        dataBytes, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("序列化数据失败: %w", err)
        }</span>

        // 生成唯一文件名
        <span class="cov10" title="114">filename := fmt.Sprintf("%s_%d.json", dc.config.FilePrefix, time.Now().UnixNano())
        filepath := filepath.Join(dc.cacheDir, filename)

        // 写入磁盘
        if err := dc.writeToDisk(filepath, dataBytes); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("写入磁盘失败: %w", err)
        }</span>

        // 检查是否超过最大大小
        <span class="cov10" title="114">if int64(len(dc.entries)) &gt;= dc.config.MaxSize &amp;&amp; dc.config.MaxSize &gt; 0 </span><span class="cov1" title="1">{
                // 基于访问时间的淘汰策略：删除最久未访问的条目
                var oldestKey string
                var oldestTime time.Time
                for k, e := range dc.entries </span><span class="cov2" title="2">{
                        if oldestTime.IsZero() || e.AccessTime.Before(oldestTime) </span><span class="cov2" title="2">{
                                oldestKey = k
                                oldestTime = e.AccessTime
                        }</span>
                }
                <span class="cov1" title="1">if oldestKey != "" </span><span class="cov1" title="1">{
                        oldEntry := dc.entries[oldestKey]
                        delete(dc.entries, oldestKey)
                        dc.stats.Size--
                        // 同步删除磁盘文件以避免死锁
                        os.Remove(oldEntry.Filepath)
                }</span>
        }

        // 添加新条目
        <span class="cov10" title="114">dc.entries[key] = diskCacheEntry{
                Key:        key,
                Filepath:   filepath,
                ExpireTime: expireTime,
                AccessTime: time.Now(),
                CreateTime: time.Now(),
                HitCount:   0,
                Size:       int64(len(dataBytes)),
        }
        dc.stats.Size++

        return nil</span>
}

// Delete 从磁盘缓存删除数据
func (dc *DiskCache) Delete(ctx context.Context, key string) error <span class="cov1" title="1">{
        dc.mu.Lock()
        if dc.closed </span><span class="cov0" title="0">{
                dc.mu.Unlock()
                return fmt.Errorf("cache is closed")
        }</span>
        <span class="cov1" title="1">entry, exists := dc.entries[key]
        if exists </span><span class="cov1" title="1">{
                delete(dc.entries, key)
                dc.stats.Size--
        }</span>
        <span class="cov1" title="1">dc.mu.Unlock()

        if exists </span><span class="cov1" title="1">{
                // 异步删除磁盘文件
                go os.Remove(entry.Filepath)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Clear 清空磁盘缓存
func (dc *DiskCache) Clear(ctx context.Context) error <span class="cov1" title="1">{
        dc.mu.Lock()
        if dc.closed </span><span class="cov0" title="0">{
                dc.mu.Unlock()
                return fmt.Errorf("cache is closed")
        }</span>
        <span class="cov1" title="1">entries := make([]diskCacheEntry, 0, len(dc.entries))
        for _, entry := range dc.entries </span><span class="cov2" title="2">{
                entries = append(entries, entry)
        }</span>
        <span class="cov1" title="1">dc.entries = make(map[string]diskCacheEntry)
        dc.stats.Size = 0
        dc.stats.HitCount = 0
        dc.stats.MissCount = 0
        dc.mu.Unlock()

        // 异步删除所有磁盘文件
        go func() </span><span class="cov1" title="1">{
                for _, entry := range entries </span><span class="cov2" title="2">{
                        os.Remove(entry.Filepath)
                }</span>
        }()

        <span class="cov1" title="1">return nil</span>
}

// Stats 获取缓存统计信息
func (dc *DiskCache) Stats() core.CacheStats <span class="cov5" title="9">{
        dc.mu.RLock()
        defer dc.mu.RUnlock()

        stats := dc.stats
        stats.LastCleanup = time.Now()

        // 计算命中率
        total := stats.HitCount + stats.MissCount
        if total &gt; 0 </span><span class="cov3" title="3">{
                stats.HitRate = float64(stats.HitCount) / float64(total)
        }</span>

        <span class="cov5" title="9">return stats</span>
}

// Close 关闭磁盘缓存
func (dc *DiskCache) Close() error <span class="cov5" title="12">{
        dc.mu.Lock()
        if dc.closed </span><span class="cov2" title="2">{
                dc.mu.Unlock()
                return nil // 已经关闭
        }</span>
        <span class="cov5" title="10">dc.closed = true
        close(dc.closeChan)

        // 先解锁，再调用 saveMetadata，避免死锁
        dc.mu.Unlock()

        // 保存元数据
        if err := dc.saveMetadata(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("保存元数据失败: %w", err)
        }</span>

        <span class="cov5" title="10">return nil</span>
}

// readFromDisk 从磁盘读取数据
func (dc *DiskCache) readFromDisk(filepath string) (interface{}, error) <span class="cov4" title="7">{
        data, err := os.ReadFile(filepath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("读取文件失败: %w", err)
        }</span>

        <span class="cov4" title="7">var value interface{}
        if err := json.Unmarshal(data, &amp;value); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("反序列化数据失败: %w", err)
        }</span>

        <span class="cov4" title="7">return value, nil</span>
}

// writeToDisk 向磁盘写入数据
func (dc *DiskCache) writeToDisk(filepath string, data []byte) error <span class="cov10" title="114">{
        tempFile := filepath + ".tmp"

        if err := os.WriteFile(tempFile, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("写入临时文件失败: %w", err)
        }</span>

        <span class="cov10" title="114">if err := os.Rename(tempFile, filepath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("重命名文件失败: %w", err)
        }</span>

        <span class="cov10" title="114">return nil</span>
}

// loadMetadata 加载缓存元数据
func (dc *DiskCache) loadMetadata() error <span class="cov5" title="11">{
        metadataFile := filepath.Join(dc.cacheDir, "metadata.json")
        if _, err := os.Stat(metadataFile); os.IsNotExist(err) </span><span class="cov5" title="9">{
                return nil // 元数据文件不存在是正常的
        }</span>

        <span class="cov2" title="2">data, err := os.ReadFile(metadataFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("读取元数据文件失败: %w", err)
        }</span>

        <span class="cov2" title="2">var entries map[string]diskCacheEntry
        if err := json.Unmarshal(data, &amp;entries); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("反序列化元数据失败: %w", err)
        }</span>

        // 过滤掉过期的条目
        <span class="cov1" title="1">now := time.Now()
        validEntries := make(map[string]diskCacheEntry)
        for key, entry := range entries </span><span class="cov2" title="2">{
                if now.Before(entry.ExpireTime) </span><span class="cov1" title="1">{
                        validEntries[key] = entry
                }</span> else<span class="cov1" title="1"> {
                        // 异步删除过期的磁盘文件
                        go os.Remove(entry.Filepath)
                }</span>
        }

        <span class="cov1" title="1">dc.mu.Lock()
        dc.entries = validEntries
        dc.stats.Size = int64(len(validEntries))
        dc.mu.Unlock()

        return nil</span>
}

// saveMetadata 保存缓存元数据
func (dc *DiskCache) saveMetadata() error <span class="cov5" title="10">{
        dc.mu.RLock()
        entries := dc.entries
        dc.mu.RUnlock()

        data, err := json.Marshal(entries)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("序列化元数据失败: %w", err)
        }</span>

        <span class="cov5" title="10">metadataFile := filepath.Join(dc.cacheDir, "metadata.json")
        tempFile := metadataFile + ".tmp"

        if err := os.WriteFile(tempFile, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("写入元数据临时文件失败: %w", err)
        }</span>

        <span class="cov5" title="10">if err := os.Rename(tempFile, metadataFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("重命名元数据文件失败: %w", err)
        }</span>

        <span class="cov5" title="10">return nil</span>
}

// cleanupWorker 定期清理过期条目的工作协程
func (dc *DiskCache) cleanupWorker() <span class="cov1" title="1">{
        ticker := time.NewTicker(dc.config.CleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov3" title="3">{
                select </span>{
                case &lt;-ticker.C:<span class="cov2" title="2">
                        dc.cleanupExpired()</span>
                case &lt;-dc.closeChan:<span class="cov1" title="1">
                        return</span>
                }
        }
}

// cleanupExpired 清理过期条目
func (dc *DiskCache) cleanupExpired() <span class="cov2" title="2">{
        dc.mu.Lock()
        defer dc.mu.Unlock()

        now := time.Now()
        deletedKeys := make([]string, 0)
        deletedFiles := make([]string, 0)

        for key, entry := range dc.entries </span><span class="cov3" title="3">{
                if now.After(entry.ExpireTime) </span><span class="cov1" title="1">{
                        deletedKeys = append(deletedKeys, key)
                        deletedFiles = append(deletedFiles, entry.Filepath)
                }</span>
        }

        <span class="cov2" title="2">for _, key := range deletedKeys </span><span class="cov1" title="1">{
                delete(dc.entries, key)
                dc.stats.Size--
        }</span>

        // 异步删除磁盘文件
        <span class="cov2" title="2">if len(deletedFiles) &gt; 0 </span><span class="cov1" title="1">{
                go func(files []string) </span><span class="cov1" title="1">{
                        for _, file := range files </span><span class="cov1" title="1">{
                                os.Remove(file)
                        }</span>
                }(deletedFiles)
        }

        <span class="cov2" title="2">dc.stats.LastCleanup = now</span>
}

var _ core.Cache = (*DiskCache)(nil)
</pre>
		
		<pre class="file" id="file14" style="display: none">package cache

import (
        "context"
        "errors"
        "fmt"
        "os"
        "sync"
        "sync/atomic"
        "time"

        "stocksub/pkg/testkit/core"
)

// LayerType 缓存层类型
type LayerType string

const (
        LayerMemory LayerType = "memory" // 内存层
        LayerDisk   LayerType = "disk"   // 磁盘层
        LayerRemote LayerType = "remote" // 远程层（如Redis）
)

// LayerFactory 缓存层工厂接口
type LayerFactory interface {
        // CreateLayer 根据配置创建缓存层
        CreateLayer(config LayerConfig, layerIndex int) (core.Cache, error)
        // LayerType 返回支持的缓存层类型
        LayerType() LayerType
}

// LayerConfig 缓存层配置
type LayerConfig struct {
        Type            LayerType     `yaml:"type"`
        Path            string        `yaml:"path"` // 缓存路径（主要用于磁盘缓存）
        MaxSize         int64         `yaml:"max_size"`
        TTL             time.Duration `yaml:"ttl"`
        Enabled         bool          `yaml:"enabled"`
        Policy          PolicyType    `yaml:"policy"`
        CleanupInterval time.Duration `yaml:"cleanup_interval"`
}

// LayeredCacheConfig 分层缓存配置
type LayeredCacheConfig struct {
        Layers         []LayerConfig `yaml:"layers"`
        PromoteEnabled bool          `yaml:"promote_enabled"` // 是否启用数据提升
        WriteThrough   bool          `yaml:"write_through"`   // 是否写穿透
        WriteBack      bool          `yaml:"write_back"`      // 是否写回
}

// LayeredCache 分层缓存实现
type LayeredCache struct {
        mu          sync.RWMutex
        layers      []core.Cache
        config      LayeredCacheConfig
        stats       LayeredCacheStats
        factories   map[LayerType]LayerFactory // 缓存层工厂注册表
        promoteChan chan promoteRequest        // 数据提升请求通道
        closed      bool                       // 缓存是否已关闭
}

// promoteRequest 数据提升请求
type promoteRequest struct {
        ctx       context.Context
        key       string
        value     interface{}
        fromLayer int
        errChan   chan error
}

// LayeredCacheStats 分层缓存统计
type LayeredCacheStats struct {
        LayerStats   []core.CacheStats `json:"layer_stats"`
        TotalHits    int64             `json:"total_hits"`
        TotalMisses  int64             `json:"total_misses"`
        PromoteCount int64             `json:"promote_count"`
        WriteThrough int64             `json:"write_through"`
        WriteBack    int64             `json:"write_back"`
}

// NewLayeredCache 创建分层缓存
func NewLayeredCache(config LayeredCacheConfig) (*LayeredCache, error) <span class="cov3" title="2">{
        return NewLayeredCacheWithFactories(config, nil)
}</span>

// NewLayeredCacheWithFactories 使用指定的工厂创建分层缓存
func NewLayeredCacheWithFactories(config LayeredCacheConfig, customFactories map[LayerType]LayerFactory) (*LayeredCache, error) <span class="cov8" title="10">{
        layers := make([]core.Cache, 0, len(config.Layers))

        // 初始化默认工厂注册表
        factories := make(map[LayerType]LayerFactory)
        for layerType, factory := range customFactories </span><span class="cov9" title="16">{
                factories[layerType] = factory
        }</span>

        // 注册默认工厂
        <span class="cov8" title="10">registerDefaultFactories(factories)

        for i, layerConfig := range config.Layers </span><span class="cov10" title="18">{
                if !layerConfig.Enabled </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov10" title="18">layer, err := createCacheLayer(layerConfig, i, factories)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("创建缓存层 %d 失败: %w", i, err)
                }</span>

                <span class="cov9" title="17">layers = append(layers, layer)</span>
        }

        <span class="cov7" title="9">if len(layers) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("至少需要一个启用的缓存层")
        }</span>

        <span class="cov7" title="9">lc := &amp;LayeredCache{
                layers:    layers,
                config:    config,
                factories: factories,
                stats: LayeredCacheStats{
                        LayerStats: make([]core.CacheStats, len(layers)),
                },
                promoteChan: make(chan promoteRequest, 100), // 缓冲通道避免阻塞
        }

        // 启动数据提升工作协程
        if config.PromoteEnabled </span><span class="cov7" title="9">{
                go lc.promoteWorker()
        }</span>

        <span class="cov7" title="9">return lc, nil</span>
}

// createCacheLayer 创建单个缓存层
func createCacheLayer(config LayerConfig, layerIndex int, factories map[LayerType]LayerFactory) (core.Cache, error) <span class="cov10" title="18">{
        // 为调试和监控目的，可以根据层索引进行特殊处理
        // 例如：为不同层设置不同的标识或配置

        factory, exists := factories[config.Type]
        if !exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("不支持的缓存层类型: %s (层索引: %d)", config.Type, layerIndex)
        }</span>

        <span class="cov9" title="17">return factory.CreateLayer(config, layerIndex)</span>
}

// registerDefaultFactories 注册默认的缓存层工厂
func registerDefaultFactories(factories map[LayerType]LayerFactory) <span class="cov8" title="10">{
        if _, exists := factories[LayerMemory]; !exists </span><span class="cov3" title="2">{
                factories[LayerMemory] = &amp;memoryLayerFactory{}
        }</span>
        <span class="cov8" title="10">if _, exists := factories[LayerDisk]; !exists </span><span class="cov3" title="2">{
                factories[LayerDisk] = &amp;diskLayerFactory{}
        }</span>
        <span class="cov8" title="10">if _, exists := factories[LayerRemote]; !exists </span><span class="cov8" title="10">{
                factories[LayerRemote] = &amp;remoteLayerFactory{}
        }</span>
}

// Get 从分层缓存获取数据
func (lc *LayeredCache) Get(ctx context.Context, key string) (interface{}, error) <span class="cov4" title="3">{
        lc.mu.RLock()
        if lc.closed </span><span class="cov0" title="0">{
                lc.mu.RUnlock()
                return nil, fmt.Errorf("缓存已关闭")
        }</span>
        <span class="cov4" title="3">lc.mu.RUnlock()

        for i, layer := range lc.layers </span><span class="cov6" title="5">{
                value, err := layer.Get(ctx, key)
                if err == nil </span><span class="cov3" title="2">{
                        // 缓存命中，检查是否需要数据提升
                        if lc.config.PromoteEnabled &amp;&amp; i &gt; 0 </span><span class="cov1" title="1">{
                                lc.asyncPromoteToUpperLayers(ctx, key, value, i)
                        }</span>
                        <span class="cov3" title="2">atomic.AddInt64(&amp;lc.stats.TotalHits, 1)
                        return value, nil</span>
                }

                // 如果不是缓存未命中错误，返回错误
                // 使用错误码比较而不是实例比较
                <span class="cov4" title="3">var testKitErr *core.TestKitError
                if errors.As(err, &amp;testKitErr) </span><span class="cov4" title="3">{
                        if testKitErr.Code != core.ErrCacheMiss </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("缓存层 %d (%s) 错误: %w", i, lc.getLayerType(i), err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // 如果不是TestKitError，直接返回
                        return nil, fmt.Errorf("缓存层 %d (%s) 错误: %w", i, lc.getLayerType(i), err)
                }</span>
        }

        <span class="cov1" title="1">atomic.AddInt64(&amp;lc.stats.TotalMisses, 1)
        return nil, core.NewTestKitError(core.ErrCacheMiss, "cache miss")</span>
}

// getLayerType 获取缓存层类型
func (lc *LayeredCache) getLayerType(index int) string <span class="cov5" title="4">{
        if index &lt; 0 || index &gt;= len(lc.config.Layers) </span><span class="cov0" title="0">{
                return "unknown"
        }</span>

        // 从配置中获取层类型
        <span class="cov5" title="4">return string(lc.config.Layers[index].Type)</span>
}

// asyncPromoteToUpperLayers 异步将数据提升到上层缓存
func (lc *LayeredCache) asyncPromoteToUpperLayers(ctx context.Context, key string, value interface{}, fromLayer int) <span class="cov3" title="2">{
        if !lc.config.PromoteEnabled </span><span class="cov0" title="0">{
                return
        }</span>

        // 使用缓冲通道避免阻塞
        <span class="cov3" title="2">select </span>{
        case lc.promoteChan &lt;- promoteRequest{
                ctx:       ctx,
                key:       key,
                value:     value,
                fromLayer: fromLayer,
                errChan:   nil, // 不需要错误返回
        }:<span class="cov3" title="2">
                atomic.AddInt64(&amp;lc.stats.PromoteCount, 1)</span>
        default:<span class="cov0" title="0"></span>
                // 通道满时丢弃提升请求，避免阻塞
        }
}

// promoteWorker 数据提升工作协程
func (lc *LayeredCache) promoteWorker() <span class="cov7" title="9">{
        for req := range lc.promoteChan </span><span class="cov3" title="2">{
                lc.promoteToUpperLayers(req.ctx, req.key, req.value, req.fromLayer)
                if req.errChan != nil </span><span class="cov0" title="0">{
                        req.errChan &lt;- nil
                }</span>
        }
}

// Set 向分层缓存设置数据
func (lc *LayeredCache) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error <span class="cov7" title="7">{
        lc.mu.RLock()
        if lc.closed </span><span class="cov0" title="0">{
                lc.mu.RUnlock()
                return fmt.Errorf("缓存已关闭")
        }</span>
        <span class="cov7" title="7">lc.mu.RUnlock()

        if lc.config.WriteThrough </span><span class="cov7" title="7">{
                // 写穿透：向所有层写入
                var lastErr error
                for i, layer := range lc.layers </span><span class="cov9" title="14">{
                        if err := layer.Set(ctx, key, value, ttl); err != nil </span><span class="cov1" title="1">{
                                layerType := lc.getLayerType(i)
                                lastErr = fmt.Errorf("缓存层 %d (%s) 写入失败: %w", i, layerType, err)
                        }</span>
                }
                <span class="cov7" title="7">if lastErr == nil </span><span class="cov6" title="6">{
                        atomic.AddInt64(&amp;lc.stats.WriteThrough, 1)
                }</span>
                <span class="cov7" title="7">return lastErr</span>
        } else<span class="cov0" title="0"> {
                // 默认只写入第一层（最快的层）
                if len(lc.layers) &gt; 0 </span><span class="cov0" title="0">{
                        if err := lc.layers[0].Set(ctx, key, value, ttl); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("第一层缓存 (%s) 写入失败: %w", lc.getLayerType(0), err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("没有可用的缓存层")</span>
        }
}

// Delete 从分层缓存删除数据
func (lc *LayeredCache) Delete(ctx context.Context, key string) error <span class="cov3" title="2">{
        lc.mu.RLock()
        if lc.closed </span><span class="cov0" title="0">{
                lc.mu.RUnlock()
                return fmt.Errorf("缓存已关闭")
        }</span>
        <span class="cov3" title="2">lc.mu.RUnlock()

        var lastErr error

        // 从所有层删除
        for i, layer := range lc.layers </span><span class="cov5" title="4">{
                if err := layer.Delete(ctx, key); err != nil </span><span class="cov1" title="1">{
                        layerType := lc.getLayerType(i)
                        lastErr = fmt.Errorf("缓存层 %d (%s) 删除失败: %w", i, layerType, err)
                }</span>
        }

        <span class="cov3" title="2">return lastErr</span>
}

// Clear 清空所有缓存层
func (lc *LayeredCache) Clear(ctx context.Context) error <span class="cov3" title="2">{
        lc.mu.RLock()
        if lc.closed </span><span class="cov0" title="0">{
                lc.mu.RUnlock()
                return fmt.Errorf("缓存已关闭")
        }</span>
        <span class="cov3" title="2">lc.mu.RUnlock()

        var lastErr error

        for i, layer := range lc.layers </span><span class="cov5" title="4">{
                if err := layer.Clear(ctx); err != nil </span><span class="cov1" title="1">{
                        layerType := lc.getLayerType(i)
                        lastErr = fmt.Errorf("缓存层 %d (%s) 清空失败: %w", i, layerType, err)
                }</span>
        }

        // 重置统计信息
        <span class="cov3" title="2">lc.stats = LayeredCacheStats{
                LayerStats: make([]core.CacheStats, len(lc.layers)),
        }

        return lastErr</span>
}

// Stats 获取分层缓存统计信息
func (lc *LayeredCache) Stats() core.CacheStats <span class="cov0" title="0">{
        lc.mu.RLock()
        defer lc.mu.RUnlock()

        // 即使缓存已关闭，也允许获取统计信息

        // 收集各层统计信息
        totalSize := int64(0)
        totalMaxSize := int64(0)
        totalHitCount := atomic.LoadInt64(&amp;lc.stats.TotalHits)
        totalMissCount := atomic.LoadInt64(&amp;lc.stats.TotalMisses)

        for i, layer := range lc.layers </span><span class="cov0" title="0">{
                layerStats := layer.Stats()
                lc.stats.LayerStats[i] = layerStats

                totalSize += layerStats.Size
                totalMaxSize += layerStats.MaxSize
        }</span>

        <span class="cov0" title="0">var hitRate float64
        if total := totalHitCount + totalMissCount; total &gt; 0 </span><span class="cov0" title="0">{
                hitRate = float64(totalHitCount) / float64(total)
        }</span>

        <span class="cov0" title="0">return core.CacheStats{
                Size:        totalSize,
                MaxSize:     totalMaxSize,
                HitCount:    totalHitCount,
                MissCount:   totalMissCount,
                HitRate:     hitRate,
                TTL:         0, // 分层缓存的TTL取决于各层配置
                LastCleanup: time.Now(),
        }</span>
}

// promoteToUpperLayers 将数据提升到上层缓存
func (lc *LayeredCache) promoteToUpperLayers(ctx context.Context, key string, value interface{}, fromLayer int) <span class="cov3" title="2">{
        // 从命中层的上一层开始，逐层向上提升
        for i := fromLayer - 1; i &gt;= 0; i-- </span><span class="cov3" title="2">{
                // 使用各层的默认TTL
                if err := lc.layers[i].Set(ctx, key, value, 0); err != nil </span><span class="cov0" title="0">{
                        // 记录错误但不中断提升过程
                        continue</span>
                }
        }
}

// GetLayerStats 获取各层统计信息
func (lc *LayeredCache) GetLayerStats() LayeredCacheStats <span class="cov1" title="1">{
        lc.mu.RLock()
        defer lc.mu.RUnlock()

        // 即使缓存已关闭，也允许获取统计信息

        // 更新各层统计信息
        for i, layer := range lc.layers </span><span class="cov3" title="2">{
                lc.stats.LayerStats[i] = layer.Stats()
        }</span>

        <span class="cov1" title="1">return lc.stats</span>
}

// Close 关闭所有缓存层
func (lc *LayeredCache) Close() error <span class="cov0" title="0">{
        lc.mu.Lock()
        defer lc.mu.Unlock()

        if lc.closed </span><span class="cov0" title="0">{
                return nil // 已经关闭
        }</span>

        <span class="cov0" title="0">var lastErr error

        // 关闭数据提升通道和工作协程
        if lc.promoteChan != nil </span><span class="cov0" title="0">{
                close(lc.promoteChan)
        }</span>

        <span class="cov0" title="0">for i, layer := range lc.layers </span><span class="cov0" title="0">{
                if closer, ok := layer.(interface{ Close() error }); ok </span><span class="cov0" title="0">{
                        if err := closer.Close(); err != nil </span><span class="cov0" title="0">{
                                lastErr = fmt.Errorf("缓存层 %d 关闭失败: %w", i, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">lc.closed = true
        return lastErr</span>
}

// BatchGet 批量从分层缓存获取数据（可选扩展功能）
func (lc *LayeredCache) BatchGet(ctx context.Context, keys []string) (map[string]any, error) <span class="cov3" title="2">{
        lc.mu.RLock()
        if lc.closed </span><span class="cov0" title="0">{
                lc.mu.RUnlock()
                return nil, fmt.Errorf("缓存已关闭")
        }</span>
        <span class="cov3" title="2">lc.mu.RUnlock()

        result := make(map[string]any)
        remainingKeys := make([]string, len(keys))
        copy(remainingKeys, keys)

        // 逐层查询，直到所有键都找到或所有层都查询完毕
        for i, layer := range lc.layers </span><span class="cov5" title="4">{
                if len(remainingKeys) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                // 检查当前层是否支持批量操作
                <span class="cov5" title="4">if batchGetter, ok := layer.(core.BatchGetter); ok </span><span class="cov0" title="0">{
                        batchResult, err := batchGetter.BatchGet(ctx, remainingKeys)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("缓存层 %d (%s) 批量获取失败: %w", i, lc.getLayerType(i), err)
                        }</span>

                        // 收集结果并更新剩余键
                        <span class="cov0" title="0">for key, value := range batchResult </span><span class="cov0" title="0">{
                                result[key] = value
                                // 从剩余键中移除已找到的键
                                remainingKeys = removeKey(remainingKeys, key)

                                // 检查是否需要数据提升
                                if lc.config.PromoteEnabled &amp;&amp; i &gt; 0 </span><span class="cov0" title="0">{
                                        lc.asyncPromoteToUpperLayers(ctx, key, value, i)
                                }</span>
                        }
                } else<span class="cov5" title="4"> {
                        // 当前层不支持批量操作，回退到单键操作
                        for _, key := range remainingKeys </span><span class="cov7" title="8">{
                                value, err := layer.Get(ctx, key)
                                if err == nil </span><span class="cov4" title="3">{
                                        result[key] = value
                                        // 从剩余键中移除已找到的键
                                        remainingKeys = removeKey(remainingKeys, key)

                                        // 检查是否需要数据提升
                                        if lc.config.PromoteEnabled &amp;&amp; i &gt; 0 </span><span class="cov1" title="1">{
                                                lc.asyncPromoteToUpperLayers(ctx, key, value, i)
                                        }</span>
                                } else<span class="cov6" title="5"> {
                                        // 如果不是缓存未命中错误，则这是一个需要报告的真实错误
                                        var testKitErr *core.TestKitError
                                        if !errors.As(err, &amp;testKitErr) || testKitErr.Code != core.ErrCacheMiss </span><span class="cov1" title="1">{
                                                return nil, fmt.Errorf("缓存层 %d (%s) 获取失败: %w", i, lc.getLayerType(i), err)
                                        }</span>
                                }
                        }
                }
        }

        // 更新统计信息
        <span class="cov1" title="1">atomic.AddInt64(&amp;lc.stats.TotalHits, int64(len(result)))
        atomic.AddInt64(&amp;lc.stats.TotalMisses, int64(len(remainingKeys)))

        return result, nil</span>
}

// BatchSet 批量向分层缓存设置数据
func (lc *LayeredCache) BatchSet(ctx context.Context, items map[string]any, ttl time.Duration) error <span class="cov0" title="0">{
        lc.mu.RLock()
        if lc.closed </span><span class="cov0" title="0">{
                lc.mu.RUnlock()
                return fmt.Errorf("缓存已关闭")
        }</span>
        <span class="cov0" title="0">lc.mu.RUnlock()

        if lc.config.WriteThrough </span><span class="cov0" title="0">{
                // 写穿透：向所有层写入
                var lastErr error
                for i, layer := range lc.layers </span><span class="cov0" title="0">{
                        if batchSetter, ok := layer.(core.BatchSetter); ok </span><span class="cov0" title="0">{
                                if err := batchSetter.BatchSet(ctx, items, ttl); err != nil </span><span class="cov0" title="0">{
                                        layerType := lc.getLayerType(i)
                                        lastErr = fmt.Errorf("缓存层 %d (%s) 批量设置失败: %w", i, layerType, err)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // 当前层不支持批量操作，回退到单键操作
                                for key, value := range items </span><span class="cov0" title="0">{
                                        if err := layer.Set(ctx, key, value, ttl); err != nil </span><span class="cov0" title="0">{
                                                layerType := lc.getLayerType(i)
                                                lastErr = fmt.Errorf("缓存层 %d (%s) 设置失败: %w", i, layerType, err)
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">if lastErr == nil </span><span class="cov0" title="0">{
                        atomic.AddInt64(&amp;lc.stats.WriteThrough, 1)
                }</span>
                <span class="cov0" title="0">return lastErr</span>
        } else<span class="cov0" title="0"> {
                // 默认只写入第一层（最快的层）
                if len(lc.layers) &gt; 0 </span><span class="cov0" title="0">{
                        layer := lc.layers[0]
                        if batchSetter, ok := layer.(core.BatchSetter); ok </span><span class="cov0" title="0">{
                                if err := batchSetter.BatchSet(ctx, items, ttl); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("第一层缓存 (%s) 批量设置失败: %w", lc.getLayerType(0), err)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // 回退到单键操作
                                for key, value := range items </span><span class="cov0" title="0">{
                                        if err := layer.Set(ctx, key, value, ttl); err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("第一层缓存 (%s) 设置失败: %w", lc.getLayerType(0), err)
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("没有可用的缓存层")</span>
        }
}

// removeKey 从字符串切片中移除指定的键
func removeKey(keys []string, keyToRemove string) []string <span class="cov4" title="3">{
        result := make([]string, 0, len(keys))
        for _, key := range keys </span><span class="cov7" title="9">{
                if key != keyToRemove </span><span class="cov6" title="6">{
                        result = append(result, key)
                }</span>
        }
        <span class="cov4" title="3">return result</span>
}

// Warm 预热缓存
func (lc *LayeredCache) Warm(ctx context.Context, data map[string]interface{}) error <span class="cov1" title="1">{
        lc.mu.RLock()
        if lc.closed </span><span class="cov0" title="0">{
                lc.mu.RUnlock()
                return fmt.Errorf("缓存已关闭")
        }</span>
        <span class="cov1" title="1">lc.mu.RUnlock()

        for key, value := range data </span><span class="cov3" title="2">{
                if err := lc.Set(ctx, key, value, 0); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("预热缓存失败，key=%s: %w", key, err)
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// Flush 刷新缓存（将上层数据写入下层）
func (lc *LayeredCache) Flush(ctx context.Context) error <span class="cov0" title="0">{
        lc.mu.RLock()
        if lc.closed </span><span class="cov0" title="0">{
                lc.mu.RUnlock()
                return fmt.Errorf("缓存已关闭")
        }</span>
        <span class="cov0" title="0">lc.mu.RUnlock()

        if !lc.config.WriteBack </span><span class="cov0" title="0">{
                return nil // 只在写回模式下执行刷新
        }</span>

        // TODO: 实现写回逻辑
        // 这需要缓存层支持遍历所有键值对
        <span class="cov0" title="0">lc.stats.WriteBack++
        return nil</span>
}

// DefaultLayeredCacheConfig 默认分层缓存配置
func DefaultLayeredCacheConfig() LayeredCacheConfig <span class="cov1" title="1">{
        return LayeredCacheConfig{
                Layers: []LayerConfig{
                        {
                                Type:            LayerMemory,
                                MaxSize:         1000,
                                TTL:             5 * time.Minute,
                                Enabled:         true,
                                Policy:          PolicyLRU,
                                CleanupInterval: 1 * time.Minute,
                        },
                        {
                                Type:            LayerMemory, // 作为二级缓存
                                MaxSize:         5000,
                                TTL:             30 * time.Minute,
                                Enabled:         true,
                                Policy:          PolicyLFU,
                                CleanupInterval: 5 * time.Minute,
                        },
                },
                PromoteEnabled: true,
                WriteThrough:   false,
                WriteBack:      false,
        }
}</span>

var _ core.Cache = (*LayeredCache)(nil)

// 默认缓存层工厂实现

type memoryLayerFactory struct{}

func (f *memoryLayerFactory) LayerType() LayerType <span class="cov0" title="0">{
        return LayerMemory
}</span>

func (f *memoryLayerFactory) CreateLayer(config LayerConfig, layerIndex int) (core.Cache, error) <span class="cov1" title="1">{
        memConfig := MemoryCacheConfig{
                MaxSize:         config.MaxSize,
                DefaultTTL:      config.TTL,
                CleanupInterval: config.CleanupInterval,
        }

        if config.Policy != "" </span><span class="cov0" title="0">{
                policyConfig := PolicyConfig{
                        Type:    config.Policy,
                        MaxSize: config.MaxSize,
                        TTL:     config.TTL,
                }
                return NewSmartCache(memConfig, policyConfig), nil
        }</span>

        <span class="cov1" title="1">return NewMemoryCache(memConfig), nil</span>
}

type diskLayerFactory struct{}

func (f *diskLayerFactory) LayerType() LayerType <span class="cov0" title="0">{
        return LayerDisk
}</span>

func (f *diskLayerFactory) CreateLayer(config LayerConfig, layerIndex int) (core.Cache, error) <span class="cov0" title="0">{
        // 优先使用配置中指定的路径，如果为空则使用系统临时目录
        baseDir := config.Path
        if baseDir == "" </span><span class="cov0" title="0">{
                baseDir = os.TempDir()
        }</span>

        <span class="cov0" title="0">diskConfig := DiskCacheConfig{
                BaseDir:         baseDir,
                MaxSize:         config.MaxSize,
                DefaultTTL:      config.TTL,
                CleanupInterval: config.CleanupInterval,
                FilePrefix:      fmt.Sprintf("stocksub_layer_%d", layerIndex),
        }
        return NewDiskCache(diskConfig)</span>
}

type remoteLayerFactory struct{}

func (f *remoteLayerFactory) LayerType() LayerType <span class="cov0" title="0">{
        return LayerRemote
}</span>

func (f *remoteLayerFactory) CreateLayer(config LayerConfig, layerIndex int) (core.Cache, error) <span class="cov0" title="0">{
        remoteConfig := RemoteCacheConfig{
                Address:        "localhost:6379", // 默认Redis地址
                MaxSize:        config.MaxSize,
                DefaultTTL:     config.TTL,
                ConnectTimeout: 5 * time.Second,
                RequestTimeout: 2 * time.Second,
                MaxConnections: 10,
                PoolSize:       5,
        }

        // 使用模拟实现，实际项目中应该根据配置选择具体的远程缓存类型
        return NewMockRemoteCache(remoteConfig), nil
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package cache

import (
        "context"
        "sync"
        "sync/atomic"
        "time"

        "stocksub/pkg/testkit/core"
)

// MemoryCache 线程安全的内存缓存实现
type MemoryCache struct {
        mu         sync.RWMutex
        entries    map[string]*core.CacheEntry
        maxSize    int64
        hitCount   int64
        missCount  int64
        defaultTTL time.Duration

        // 清理相关
        cleanupTicker *time.Ticker
        stopCleanup   chan struct{}
        lastCleanup   time.Time
}

// NewMemoryCache 创建新的内存缓存
func NewMemoryCache(config MemoryCacheConfig) *MemoryCache <span class="cov7" title="8">{
        cache := &amp;MemoryCache{
                entries:     make(map[string]*core.CacheEntry),
                maxSize:     config.MaxSize,
                defaultTTL:  config.DefaultTTL,
                stopCleanup: make(chan struct{}),
                lastCleanup: time.Now(),
        }

        // 启动清理协程
        if config.CleanupInterval &gt; 0 </span><span class="cov6" title="6">{
                cache.cleanupTicker = time.NewTicker(config.CleanupInterval)
                go cache.startCleanup()
        }</span>

        <span class="cov7" title="8">return cache</span>
}

// MemoryCacheConfig 内存缓存配置
type MemoryCacheConfig struct {
        MaxSize         int64         // 最大条目数量
        DefaultTTL      time.Duration // 默认TTL
        CleanupInterval time.Duration // 清理间隔
}

// Get 获取缓存值
func (mc *MemoryCache) Get(ctx context.Context, key string) (interface{}, error) <span class="cov9" title="16">{
        mc.mu.RLock()
        entry, exists := mc.entries[key]
        mc.mu.RUnlock()

        if !exists </span><span class="cov7" title="9">{
                atomic.AddInt64(&amp;mc.missCount, 1)
                return nil, core.NewTestKitError(core.ErrCacheMiss, "cache miss")
        }</span>

        // 检查过期
        <span class="cov6" title="7">if entry.ExpireTime.Before(time.Now()) </span><span class="cov0" title="0">{
                mc.mu.Lock()
                delete(mc.entries, key)
                mc.mu.Unlock()
                atomic.AddInt64(&amp;mc.missCount, 1)
                return nil, core.NewTestKitError(core.ErrCacheMiss, "cache miss")
        }</span>

        // 更新访问信息
        <span class="cov6" title="7">entry.AccessTime = time.Now()
        atomic.AddInt64(&amp;entry.HitCount, 1)
        atomic.AddInt64(&amp;mc.hitCount, 1)

        return entry.Value, nil</span>
}

// Set 设置缓存值
func (mc *MemoryCache) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error <span class="cov8" title="13">{
        if ttl &lt;= 0 </span><span class="cov7" title="9">{
                ttl = mc.defaultTTL
        }</span>

        <span class="cov8" title="13">now := time.Now()
        entry := &amp;core.CacheEntry{
                Value:      value,
                ExpireTime: now.Add(ttl),
                AccessTime: now,
                CreateTime: now,
                HitCount:   0,
                Size:       estimateSize(value),
        }

        mc.mu.Lock()
        defer mc.mu.Unlock()

        // 检查是否需要淘汰
        if int64(len(mc.entries)) &gt;= mc.maxSize </span><span class="cov1" title="1">{
                mc.evictOldest()
        }</span>

        <span class="cov8" title="13">mc.entries[key] = entry
        return nil</span>
}

// Delete 删除缓存值
func (mc *MemoryCache) Delete(ctx context.Context, key string) error <span class="cov1" title="1">{
        mc.mu.Lock()
        defer mc.mu.Unlock()

        delete(mc.entries, key)
        return nil
}</span>

// Clear 清空缓存
func (mc *MemoryCache) Clear(ctx context.Context) error <span class="cov1" title="1">{
        mc.mu.Lock()
        defer mc.mu.Unlock()

        mc.entries = make(map[string]*core.CacheEntry)
        atomic.StoreInt64(&amp;mc.hitCount, 0)
        atomic.StoreInt64(&amp;mc.missCount, 0)
        return nil
}</span>

// Stats 获取缓存统计信息
func (mc *MemoryCache) Stats() core.CacheStats <span class="cov7" title="8">{
        mc.mu.RLock()
        size := int64(len(mc.entries))
        mc.mu.RUnlock()

        hitCount := atomic.LoadInt64(&amp;mc.hitCount)
        missCount := atomic.LoadInt64(&amp;mc.missCount)

        var hitRate float64
        if total := hitCount + missCount; total &gt; 0 </span><span class="cov4" title="3">{
                hitRate = float64(hitCount) / float64(total)
        }</span>

        <span class="cov7" title="8">return core.CacheStats{
                Size:        size,
                MaxSize:     mc.maxSize,
                HitCount:    hitCount,
                MissCount:   missCount,
                HitRate:     hitRate,
                TTL:         mc.defaultTTL,
                LastCleanup: mc.lastCleanup,
        }</span>
}

// Close 关闭缓存
func (mc *MemoryCache) Close() error <span class="cov6" title="6">{
        if mc.cleanupTicker != nil </span><span class="cov6" title="6">{
                mc.cleanupTicker.Stop()
        }</span>
        <span class="cov6" title="6">close(mc.stopCleanup)
        return nil</span>
}

// startCleanup 启动清理协程
func (mc *MemoryCache) startCleanup() <span class="cov6" title="6">{
        for </span><span class="cov9" title="17">{
                select </span>{
                case &lt;-mc.cleanupTicker.C:<span class="cov8" title="11">
                        mc.cleanup()</span>
                case &lt;-mc.stopCleanup:<span class="cov6" title="6">
                        return</span>
                }
        }
}

// cleanup 清理过期条目
func (mc *MemoryCache) cleanup() <span class="cov8" title="11">{
        now := time.Now()
        expiredKeys := make([]string, 0)

        mc.mu.RLock()
        for key, entry := range mc.entries </span><span class="cov10" title="21">{
                if entry.ExpireTime.Before(now) </span><span class="cov4" title="3">{
                        expiredKeys = append(expiredKeys, key)
                }</span>
        }
        <span class="cov8" title="11">mc.mu.RUnlock()

        if len(expiredKeys) &gt; 0 </span><span class="cov3" title="2">{
                mc.mu.Lock()
                for _, key := range expiredKeys </span><span class="cov4" title="3">{
                        delete(mc.entries, key)
                }</span>
                <span class="cov3" title="2">mc.lastCleanup = now
                mc.mu.Unlock()</span>
        }
}

// evictOldest 淘汰创建时间最早的条目（基于创建时间的淘汰策略）
func (mc *MemoryCache) evictOldest() <span class="cov1" title="1">{
        var oldestKey string
        var oldestTime time.Time

        for key, entry := range mc.entries </span><span class="cov4" title="3">{
                if oldestKey == "" || entry.CreateTime.Before(oldestTime) </span><span class="cov3" title="2">{
                        oldestKey = key
                        oldestTime = entry.CreateTime
                }</span>
        }

        <span class="cov1" title="1">if oldestKey != "" </span><span class="cov1" title="1">{
                delete(mc.entries, oldestKey)
        }</span>
}

// estimateSize 估算值的大小（简单实现）
func estimateSize(value interface{}) int64 <span class="cov10" title="21">{
        // 简单的大小估算，可以根据需要改进
        switch v := value.(type) </span>{
        case string:<span class="cov9" title="18">
                return int64(len(v))</span>
        case []byte:<span class="cov1" title="1">
                return int64(len(v))</span>
        default:<span class="cov3" title="2">
                return 64</span> // 默认大小
        }
}

var _ core.Cache = (*MemoryCache)(nil)
</pre>
		
		<pre class="file" id="file16" style="display: none">package cache

import (
        "container/list"
        "context"
        "sync"
        "time"

        "stocksub/pkg/testkit/core"
)

// PolicyType 淘汰策略类型
type PolicyType string

const (
        PolicyLRU  PolicyType = "lru"  // Least Recently Used
        PolicyLFU  PolicyType = "lfu"  // Least Frequently Used
        PolicyFIFO PolicyType = "fifo" // First In First Out
)

// EvictionPolicy 缓存淘汰策略
type EvictionPolicy interface {
        ShouldEvict(entries map[string]*core.CacheEntry) []string
        OnAccess(key string, entry *core.CacheEntry)
        OnAdd(key string, entry *core.CacheEntry)
        OnRemove(key string, entry *core.CacheEntry)
}

// NewEvictionPolicy 创建淘汰策略
func NewEvictionPolicy(policyType PolicyType) EvictionPolicy <span class="cov8" title="5">{
        switch policyType </span>{
        case PolicyLRU:<span class="cov4" title="2">
                return newLRUPolicy()</span>
        case PolicyLFU:<span class="cov1" title="1">
                return newLFUPolicy()</span>
        case PolicyFIFO:<span class="cov4" title="2">
                return newFIFOPolicy()</span>
        default:<span class="cov0" title="0">
                return newLRUPolicy()</span> // 默认使用LRU
        }
}

// lruPolicy LRU淘汰策略
type lruPolicy struct {
        mu       sync.Mutex
        lruList  *list.List
        lruIndex map[string]*list.Element
}

// lruEntry LRU条目
type lruEntry struct {
        Key        string
        AccessTime time.Time
}

// newLRUPolicy 创建LRU策略
func newLRUPolicy() *lruPolicy <span class="cov4" title="2">{
        return &amp;lruPolicy{
                lruList:  list.New(),
                lruIndex: make(map[string]*list.Element),
        }
}</span>

// ShouldEvict 确定应该淘汰的键
func (lru *lruPolicy) ShouldEvict(entries map[string]*core.CacheEntry) []string <span class="cov4" title="2">{
        lru.mu.Lock()
        defer lru.mu.Unlock()

        if len(entries) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov4" title="2">var oldestKey string
        var oldestTime time.Time

        for key, entry := range entries </span><span class="cov9" title="6">{
                if oldestKey == "" || entry.AccessTime.Before(oldestTime) </span><span class="cov6" title="3">{
                        oldestKey = key
                        oldestTime = entry.AccessTime
                }</span>
        }

        <span class="cov4" title="2">if oldestKey != "" </span><span class="cov4" title="2">{
                return []string{oldestKey}
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// OnAccess 访问时的回调
func (lru *lruPolicy) OnAccess(key string, entry *core.CacheEntry) <span class="cov4" title="2">{
        lru.mu.Lock()
        defer lru.mu.Unlock()

        if elem, exists := lru.lruIndex[key]; exists </span><span class="cov4" title="2">{
                lru.lruList.MoveToFront(elem)
                elem.Value.(*lruEntry).AccessTime = time.Now()
        }</span>
}

// OnAdd 添加时的回调
func (lru *lruPolicy) OnAdd(key string, entry *core.CacheEntry) <span class="cov10" title="7">{
        lru.mu.Lock()
        defer lru.mu.Unlock()

        lruEntry := &amp;lruEntry{
                Key:        key,
                AccessTime: time.Now(),
        }

        elem := lru.lruList.PushFront(lruEntry)
        lru.lruIndex[key] = elem
}</span>

// OnRemove 移除时的回调
func (lru *lruPolicy) OnRemove(key string, entry *core.CacheEntry) <span class="cov1" title="1">{
        lru.mu.Lock()
        defer lru.mu.Unlock()

        if elem, exists := lru.lruIndex[key]; exists </span><span class="cov1" title="1">{
                lru.lruList.Remove(elem)
                delete(lru.lruIndex, key)
        }</span>
}

// lfuPolicy LFU淘汰策略
type lfuPolicy struct {
        mu          sync.Mutex
        frequencies map[string]int64
}

// newLFUPolicy 创建LFU策略
func newLFUPolicy() *lfuPolicy <span class="cov1" title="1">{
        return &amp;lfuPolicy{
                frequencies: make(map[string]int64),
        }
}</span>

// ShouldEvict 确定应该淘汰的键
func (lfu *lfuPolicy) ShouldEvict(entries map[string]*core.CacheEntry) []string <span class="cov1" title="1">{
        lfu.mu.Lock()
        defer lfu.mu.Unlock()

        if len(entries) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="1">var minFreq int64 = -1
        var evictKey string

        for key, entry := range entries </span><span class="cov6" title="3">{
                freq := entry.HitCount
                if minFreq == -1 || freq &lt; minFreq </span><span class="cov4" title="2">{
                        minFreq = freq
                        evictKey = key
                }</span>
        }

        <span class="cov1" title="1">if evictKey != "" </span><span class="cov1" title="1">{
                return []string{evictKey}
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// OnAccess 访问时的回调
func (lfu *lfuPolicy) OnAccess(key string, entry *core.CacheEntry) <span class="cov6" title="3">{
        lfu.mu.Lock()
        defer lfu.mu.Unlock()

        lfu.frequencies[key]++
}</span>

// OnAdd 添加时的回调
func (lfu *lfuPolicy) OnAdd(key string, entry *core.CacheEntry) <span class="cov6" title="3">{
        lfu.mu.Lock()
        defer lfu.mu.Unlock()

        lfu.frequencies[key] = 1
}</span>

// OnRemove 移除时的回调
func (lfu *lfuPolicy) OnRemove(key string, entry *core.CacheEntry) <span class="cov0" title="0">{
        lfu.mu.Lock()
        defer lfu.mu.Unlock()

        delete(lfu.frequencies, key)
}</span>

// fifoPolicy FIFO淘汰策略
type fifoPolicy struct {
        mu    sync.Mutex
        queue *list.List
        index map[string]*list.Element
}

// fifoEntry FIFO条目
type fifoEntry struct {
        Key        string
        CreateTime time.Time
}

// newFIFOPolicy 创建FIFO策略
func newFIFOPolicy() *fifoPolicy <span class="cov4" title="2">{
        return &amp;fifoPolicy{
                queue: list.New(),
                index: make(map[string]*list.Element),
        }
}</span>

// ShouldEvict 确定应该淘汰的键
func (fifo *fifoPolicy) ShouldEvict(entries map[string]*core.CacheEntry) []string <span class="cov1" title="1">{
        fifo.mu.Lock()
        defer fifo.mu.Unlock()

        if len(entries) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="1">var oldestKey string
        var oldestTime time.Time

        for key, entry := range entries </span><span class="cov6" title="3">{
                if oldestKey == "" || entry.CreateTime.Before(oldestTime) </span><span class="cov1" title="1">{
                        oldestKey = key
                        oldestTime = entry.CreateTime
                }</span>
        }

        <span class="cov1" title="1">if oldestKey != "" </span><span class="cov1" title="1">{
                return []string{oldestKey}
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// OnAccess 访问时的回调（FIFO不需要处理访问）
func (fifo *fifoPolicy) OnAccess(key string, entry *core.CacheEntry) {<span class="cov4" title="2">
        // FIFO策略不需要处理访问事件
}</span>

// OnAdd 添加时的回调
func (fifo *fifoPolicy) OnAdd(key string, entry *core.CacheEntry) <span class="cov7" title="4">{
        fifo.mu.Lock()
        defer fifo.mu.Unlock()

        fifoEntry := &amp;fifoEntry{
                Key:        key,
                CreateTime: time.Now(),
        }

        elem := fifo.queue.PushBack(fifoEntry)
        fifo.index[key] = elem
}</span>

// OnRemove 移除时的回调
func (fifo *fifoPolicy) OnRemove(key string, entry *core.CacheEntry) <span class="cov0" title="0">{
        fifo.mu.Lock()
        defer fifo.mu.Unlock()

        if elem, exists := fifo.index[key]; exists </span><span class="cov0" title="0">{
                fifo.queue.Remove(elem)
                delete(fifo.index, key)
        }</span>
}

// PolicyConfig 策略配置
type PolicyConfig struct {
        Type    PolicyType    `yaml:"type"`
        MaxSize int64         `yaml:"max_size"`
        TTL     time.Duration `yaml:"ttl"`
}

// SmartCache 智能缓存，支持策略配置
type SmartCache struct {
        *MemoryCache
        policy  EvictionPolicy
        maxSize int64
}

// NewSmartCache 创建智能缓存
func NewSmartCache(config MemoryCacheConfig, policyConfig PolicyConfig) *SmartCache <span class="cov1" title="1">{
        baseCache := NewMemoryCache(config)
        policy := NewEvictionPolicy(policyConfig.Type)

        return &amp;SmartCache{
                MemoryCache: baseCache,
                policy:      policy,
                maxSize:     policyConfig.MaxSize,
        }
}</span>

// Set 重写Set方法，集成淘汰策略
func (sc *SmartCache) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error <span class="cov7" title="4">{
        if ttl &lt;= 0 </span><span class="cov7" title="4">{
                ttl = sc.defaultTTL
        }</span>

        <span class="cov7" title="4">now := time.Now()
        entry := &amp;core.CacheEntry{
                Value:      value,
                ExpireTime: now.Add(ttl),
                AccessTime: now,
                CreateTime: now,
                HitCount:   0,
                Size:       estimateSize(value),
        }

        sc.mu.Lock()
        defer sc.mu.Unlock()

        // 如果达到最大容量，执行淘汰策略
        if int64(len(sc.entries)) &gt;= sc.maxSize </span><span class="cov1" title="1">{
                toEvict := sc.policy.ShouldEvict(sc.entries)
                for _, evictKey := range toEvict </span><span class="cov1" title="1">{
                        if existingEntry, exists := sc.entries[evictKey]; exists </span><span class="cov1" title="1">{
                                sc.policy.OnRemove(evictKey, existingEntry)
                                delete(sc.entries, evictKey)
                        }</span>
                }
        }

        // 直接设置条目，避免调用基类方法造成双重加锁
        <span class="cov7" title="4">sc.entries[key] = entry

        // 通知策略新增了条目
        sc.policy.OnAdd(key, entry)

        return nil</span>
}

// Get 重写Get方法，集成访问通知
func (sc *SmartCache) Get(ctx context.Context, key string) (interface{}, error) <span class="cov4" title="2">{
        value, err := sc.MemoryCache.Get(ctx, key)

        if err == nil </span><span class="cov1" title="1">{
                sc.mu.RLock()
                if entry, exists := sc.entries[key]; exists </span><span class="cov1" title="1">{
                        sc.policy.OnAccess(key, entry)
                }</span>
                <span class="cov1" title="1">sc.mu.RUnlock()</span>
        }

        <span class="cov4" title="2">return value, err</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package cache

import (
        "context"
        "fmt"
        "sync"
        "time"

        "stocksub/pkg/testkit/core"
)

// RemoteCacheConfig 远程缓存配置
type RemoteCacheConfig struct {
        Address        string        `yaml:"address"`         // 远程服务器地址
        MaxSize        int64         `yaml:"max_size"`        // 最大缓存条目数（客户端限制）
        DefaultTTL     time.Duration `yaml:"default_ttl"`     // 默认生存时间
        ConnectTimeout time.Duration `yaml:"connect_timeout"` // 连接超时
        RequestTimeout time.Duration `yaml:"request_timeout"` // 请求超时
        MaxConnections int           `yaml:"max_connections"` // 最大连接数
        PoolSize       int           `yaml:"pool_size"`       // 连接池大小
}

// RemoteCache 远程缓存接口
// 为不同的远程缓存实现（Redis、Memcached等）提供统一接口
type RemoteCache interface {
        core.Cache

        // Connect 连接到远程缓存服务器
        Connect(ctx context.Context) error

        // IsConnected 检查是否已连接
        IsConnected() bool

        // Ping 检查连接状态
        Ping(ctx context.Context) error

        // GetStats 获取远程缓存统计信息
        GetStats(ctx context.Context) (map[string]interface{}, error)
}

// remoteCacheBase 远程缓存基础实现
type remoteCacheBase struct {
        mu          sync.RWMutex
        config      RemoteCacheConfig
        stats       core.CacheStats
        isConnected bool
        client      interface{} // 具体的客户端实现
}

// newRemoteCacheBase 创建远程缓存基础实例
func newRemoteCacheBase(config RemoteCacheConfig) *remoteCacheBase <span class="cov7" title="8">{
        return &amp;remoteCacheBase{
                config: config,
                stats: core.CacheStats{
                        MaxSize: config.MaxSize,
                        TTL:     config.DefaultTTL,
                },
        }
}</span>

// Get 从远程缓存获取数据（基础实现，需要具体实现重写）
func (rc *remoteCacheBase) Get(ctx context.Context, key string) (interface{}, error) <span class="cov1" title="1">{
        return nil, fmt.Errorf("Get method not implemented")
}</span>

// Set 向远程缓存设置数据（基础实现，需要具体实现重写）
func (rc *remoteCacheBase) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error <span class="cov1" title="1">{
        return fmt.Errorf("Set method not implemented")
}</span>

// Delete 从远程缓存删除数据（基础实现，需要具体实现重写）
func (rc *remoteCacheBase) Delete(ctx context.Context, key string) error <span class="cov1" title="1">{
        return fmt.Errorf("Delete method not implemented")
}</span>

// Clear 清空远程缓存（基础实现，需要具体实现重写）
func (rc *remoteCacheBase) Clear(ctx context.Context) error <span class="cov1" title="1">{
        return fmt.Errorf("Clear method not implemented")
}</span>

// Stats 获取缓存统计信息
func (rc *remoteCacheBase) Stats() core.CacheStats <span class="cov8" title="10">{
        rc.mu.RLock()
        defer rc.mu.RUnlock()

        stats := rc.stats
        stats.LastCleanup = time.Now()

        // 计算命中率
        total := stats.HitCount + stats.MissCount
        if total &gt; 0 </span><span class="cov5" title="4">{
                stats.HitRate = float64(stats.HitCount) / float64(total)
        }</span>

        <span class="cov8" title="10">return stats</span>
}

// IsConnected 检查是否已连接
func (rc *remoteCacheBase) IsConnected() bool <span class="cov6" title="5">{
        rc.mu.RLock()
        defer rc.mu.RUnlock()
        return rc.isConnected
}</span>

// setConnected 设置连接状态
func (rc *remoteCacheBase) setConnected(connected bool) <span class="cov7" title="7">{
        rc.mu.Lock()
        defer rc.mu.Unlock()
        rc.isConnected = connected
}</span>

// updateStats 更新统计信息
func (rc *remoteCacheBase) updateStats(hit bool) <span class="cov7" title="9">{
        rc.mu.Lock()
        defer rc.mu.Unlock()

        if hit </span><span class="cov5" title="4">{
                rc.stats.HitCount++
        }</span> else<span class="cov6" title="5"> {
                rc.stats.MissCount++
        }</span>
}

// MockRemoteCache 模拟远程缓存实现（用于测试和开发）
type MockRemoteCache struct {
        *remoteCacheBase
        data map[string]mockRemoteEntry
}

type mockRemoteEntry struct {
        value      interface{}
        expireTime time.Time
}

// NewMockRemoteCache 创建模拟远程缓存
func NewMockRemoteCache(config RemoteCacheConfig) *MockRemoteCache <span class="cov6" title="6">{
        return &amp;MockRemoteCache{
                remoteCacheBase: newRemoteCacheBase(config),
                data:            make(map[string]mockRemoteEntry),
        }
}</span>

// Connect 模拟连接
func (m *MockRemoteCache) Connect(ctx context.Context) error <span class="cov6" title="6">{
        m.setConnected(true)
        return nil
}</span>

// Ping 模拟Ping操作
func (m *MockRemoteCache) Ping(ctx context.Context) error <span class="cov3" title="2">{
        if !m.IsConnected() </span><span class="cov1" title="1">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// Get 从模拟缓存获取数据
func (m *MockRemoteCache) Get(ctx context.Context, key string) (interface{}, error) <span class="cov7" title="9">{
        m.mu.RLock()
        entry, exists := m.data[key]
        m.mu.RUnlock()

        if !exists </span><span class="cov5" title="4">{
                m.updateStats(false)
                return nil, core.NewTestKitError(core.ErrCacheMiss, "cache miss")
        }</span>

        // 检查是否过期
        <span class="cov6" title="5">if time.Now().After(entry.expireTime) </span><span class="cov1" title="1">{
                m.mu.Lock()
                delete(m.data, key)
                m.stats.Size--
                m.mu.Unlock()
                m.updateStats(false)
                return nil, core.NewTestKitError(core.ErrCacheMiss, "cache expired")
        }</span>

        <span class="cov5" title="4">m.updateStats(true)
        return entry.value, nil</span>
}

// Set 向模拟缓存设置数据
func (m *MockRemoteCache) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error <span class="cov10" title="18">{
        if ttl &lt;= 0 </span><span class="cov6" title="6">{
                ttl = m.config.DefaultTTL
        }</span>

        <span class="cov10" title="18">expireTime := time.Now().Add(ttl)

        m.mu.Lock()
        defer m.mu.Unlock()

        // 检查是否超过最大大小
        if int64(len(m.data)) &gt;= m.config.MaxSize &amp;&amp; m.config.MaxSize &gt; 0 </span><span class="cov1" title="1">{
                // 简单策略：删除最旧的条目
                var oldestKey string
                var oldestTime time.Time
                for k, e := range m.data </span><span class="cov8" title="10">{
                        if oldestTime.IsZero() || e.expireTime.Before(oldestTime) </span><span class="cov4" title="3">{
                                oldestKey = k
                                oldestTime = e.expireTime
                        }</span>
                }
                <span class="cov1" title="1">if oldestKey != "" </span><span class="cov1" title="1">{
                        delete(m.data, oldestKey)
                        m.stats.Size--
                }</span>
        }

        // 添加新条目
        <span class="cov10" title="18">if _, exists := m.data[key]; !exists </span><span class="cov10" title="18">{
                m.stats.Size++
        }</span>

        <span class="cov10" title="18">m.data[key] = mockRemoteEntry{
                value:      value,
                expireTime: expireTime,
        }

        return nil</span>
}

// Delete 从模拟缓存删除数据
func (m *MockRemoteCache) Delete(ctx context.Context, key string) error <span class="cov3" title="2">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if _, exists := m.data[key]; exists </span><span class="cov1" title="1">{
                delete(m.data, key)
                m.stats.Size--
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// Clear 清空模拟缓存
func (m *MockRemoteCache) Clear(ctx context.Context) error <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.data = make(map[string]mockRemoteEntry)
        m.stats.Size = 0
        m.stats.HitCount = 0
        m.stats.MissCount = 0

        return nil
}</span>

// GetStats 获取模拟缓存统计信息
func (m *MockRemoteCache) GetStats(ctx context.Context) (map[string]interface{}, error) <span class="cov1" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        stats := m.Stats()
        return map[string]interface{}{
                "connected":    m.isConnected,
                "items_count":  len(m.data),
                "hit_count":    stats.HitCount,
                "miss_count":   stats.MissCount,
                "hit_rate":     stats.HitRate,
                "max_size":     stats.MaxSize,
                "current_size": stats.Size,
        }, nil
}</span>

// Close 关闭模拟缓存
func (m *MockRemoteCache) Close() error <span class="cov1" title="1">{
        m.setConnected(false)
        return nil
}</span>

var _ RemoteCache = (*MockRemoteCache)(nil)
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package config 定义了 testkit 框架的所有配置选项。
// 通过这些结构体，用户可以灵活地配置缓存、存储、数据提供者和Mock等行为。
package config

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"
)

// Config 是 testkit 的主配置结构，聚合了所有子模块的配置。
type Config struct {
        Storage     StorageConfig     `json:"storage" yaml:"storage"`
        Cache       CacheConfig       `json:"cache" yaml:"cache"`
        Provider    ProviderConfig    `json:"provider" yaml:"provider"`
        Performance PerformanceConfig `json:"performance" yaml:"performance"`
        Logging     LoggingConfig     `json:"logging" yaml:"logging"`
        Mock        MockConfig        `json:"mock" yaml:"mock"`
}

// StorageConfig 定义了持久化存储的配置。
type StorageConfig struct {
        Type         string        `json:"type" yaml:"type"`                   // 存储类型，如 "csv", "memory", "json"。
        Directory    string        `json:"directory" yaml:"directory"`         // 存储目录的路径。
        MaxFileSize  int64         `json:"max_file_size" yaml:"max_file_size"` // 单个文件的最大大小（字节）。
        MaxFiles     int           `json:"max_files" yaml:"max_files"`         // 最多保留的文件数量。
        Compression  bool          `json:"compression" yaml:"compression"`     // 是否对旧的存储文件启用压缩。
        AutoCleanup  bool          `json:"auto_cleanup" yaml:"auto_cleanup"`   // 是否自动清理过期的文件。
        CleanupAge   time.Duration `json:"cleanup_age" yaml:"cleanup_age"`     // 文件的最大保留时间。
        BufferSize   int           `json:"buffer_size" yaml:"buffer_size"`     // 写入文件时的缓冲区大小。
        SyncInterval time.Duration `json:"sync_interval" yaml:"sync_interval"` // 将缓冲区数据同步到磁盘的间隔。
}

// CacheConfig 定义了缓存的配置。
type CacheConfig struct {
        Type            string        `json:"type" yaml:"type"`                         // 缓存类型，如 "memory", "layered"。
        MaxSize         int64         `json:"max_size" yaml:"max_size"`                 // 缓存中最多保留的条目数。
        MaxMemory       int64         `json:"max_memory" yaml:"max_memory"`             // 缓存占用的最大内存（字节）。
        TTL             time.Duration `json:"ttl" yaml:"ttl"`                           // 缓存条目的默认生存时间。
        EvictionPolicy  string        `json:"eviction_policy" yaml:"eviction_policy"`   // 缓存淘汰策略，如 "lru", "lfu", "fifo"。
        CleanupInterval time.Duration `json:"cleanup_interval" yaml:"cleanup_interval"` // 清理过期缓存条目的时间间隔。
        Layers          []LayerConfig `json:"layers" yaml:"layers"`                     // 当 Type 为 "layered" 时，定义各缓存层的配置。
}

// LayerConfig 定义了分层缓存中每一层的具体配置。
type LayerConfig struct {
        Name           string        `json:"name" yaml:"name"`                       // 缓存层的名称，如 "L1", "L2"。
        Type           string        `json:"type" yaml:"type"`                       // 缓存层的类型，如 "memory", "disk"。
        MaxSize        int64         `json:"max_size" yaml:"max_size"`               // 该层的最大条目数。
        TTL            time.Duration `json:"ttl" yaml:"ttl"`                         // 该层的默认生存时间。
        EvictionPolicy string        `json:"eviction_policy" yaml:"eviction_policy"` // 该层的淘汰策略。
}

// ProviderConfig 定义了数据提供者的配置。
type ProviderConfig struct {
        Type            string            `json:"type" yaml:"type"`                         // 提供者类型，如 "tencent", "mock", "hybrid"。
        Timeout         time.Duration     `json:"timeout" yaml:"timeout"`                   // API请求的超时时间。
        RetryAttempts   int               `json:"retry_attempts" yaml:"retry_attempts"`     // 请求失败时的最大重试次数。
        RetryDelay      time.Duration     `json:"retry_delay" yaml:"retry_delay"`           // 每次重试之间的延迟。
        ConcurrentLimit int               `json:"concurrent_limit" yaml:"concurrent_limit"` // 最大并发请求数。
        RateLimitQPS    int               `json:"rate_limit_qps" yaml:"rate_limit_qps"`     // 每秒请求速率限制 (QPS)。
        UserAgent       string            `json:"user_agent" yaml:"user_agent"`             // 发起HTTP请求时使用的User-Agent。
        Headers         map[string]string `json:"headers" yaml:"headers"`                   // 附加到HTTP请求中的自定义头部。
}

// PerformanceConfig 定义了与性能相关的配置。
type PerformanceConfig struct {
        WorkerCount     int           `json:"worker_count" yaml:"worker_count"`         // 用于处理后台任务的工作协程数。
        BatchSize       int           `json:"batch_size" yaml:"batch_size"`             // 批处理操作的大小。
        MaxConcurrency  int           `json:"max_concurrency" yaml:"max_concurrency"`   // 框架内部允许的最大并发数。
        MemoryLimit     int64         `json:"memory_limit" yaml:"memory_limit"`         // 框架的总内存使用限制（字节）。
        GCInterval      time.Duration `json:"gc_interval" yaml:"gc_interval"`           // 强制进行垃圾回收（GC）的时间间隔。
        MetricsInterval time.Duration `json:"metrics_interval" yaml:"metrics_interval"` // 收集和报告性能指标的时间间隔。
        EnableProfiling bool          `json:"enable_profiling" yaml:"enable_profiling"` // 是否启用性能分析（如 pprof）。
        EnableMetrics   bool          `json:"enable_metrics" yaml:"enable_metrics"`     // 是否启用指标收集。
}

// LoggingConfig 定义了日志记录的配置。
type LoggingConfig struct {
        Level        string `json:"level" yaml:"level"`                 // 日志级别，如 "debug", "info", "warn", "error"。
        Format       string `json:"format" yaml:"format"`               // 日志格式，如 "json", "text"。
        Output       string `json:"output" yaml:"output"`               // 日志输出位置，如 "stdout", "file", "both"。
        File         string `json:"file" yaml:"file"`                   // 日志文件的路径。
        MaxSize      int    `json:"max_size" yaml:"max_size"`           // 日志文件的最大大小（MB）。
        MaxBackups   int    `json:"max_backups" yaml:"max_backups"`     // 保留的旧日志文件的最大数量。
        MaxAge       int    `json:"max_age" yaml:"max_age"`             // 日志文件的最大保留天数。
        Compress     bool   `json:"compress" yaml:"compress"`           // 是否压缩归档的日志文件。
        EnableCaller bool   `json:"enable_caller" yaml:"enable_caller"` // 是否在日志中记录调用者的文件和行号。
        EnableTrace  bool   `json:"enable_trace" yaml:"enable_trace"`   // 是否启用全链路跟踪日志。
}

// MockConfig 定义了Mock功能相关的配置。
type MockConfig struct {
        Enabled       bool                   `json:"enabled" yaml:"enabled"`               // 是否全局启用Mock模式。
        ScenarioFile  string                 `json:"scenario_file" yaml:"scenario_file"`   // 用于加载Mock场景的YAML文件路径。
        DefaultDelay  time.Duration          `json:"default_delay" yaml:"default_delay"`   // Mock响应的默认延迟。
        ErrorRate     float64                `json:"error_rate" yaml:"error_rate"`         // 随机返回错误的概率 (0.0 to 1.0)。
        DataGenerator DataGenConfig          `json:"data_generator" yaml:"data_generator"` // 自动数据生成器的配置。
        Scenarios     map[string]interface{} `json:"scenarios" yaml:"scenarios"`           // 直接在配置中以内联方式定义的Mock场景。
}

// DataGenConfig 定义了Mock数据自动生成器的配置。
type DataGenConfig struct {
        Enabled        bool          `json:"enabled" yaml:"enabled"`                 // 是否启用自动数据生成。
        StockCount     int           `json:"stock_count" yaml:"stock_count"`         // 生成的模拟股票数量。
        PriceRange     [2]float64    `json:"price_range" yaml:"price_range"`         // 生成价格的范围 [min, max]。
        VolumeRange    [2]int64      `json:"volume_range" yaml:"volume_range"`       // 生成成交量的范围 [min, max]。
        UpdateInterval time.Duration `json:"update_interval" yaml:"update_interval"` // 随机数据更新的时间间隔。
        Volatility     float64       `json:"volatility" yaml:"volatility"`           // 价格波动率。
}

// DefaultConfig 返回一个包含所有模块默认值的完整配置实例。
// 此默认配置已针对测试环境进行优化
func DefaultConfig() *Config <span class="cov10" title="10">{
        return &amp;Config{
                Storage: StorageConfig{
                        Type:         "csv",
                        Directory:    "./testdata",
                        MaxFileSize:  10 * 1024 * 1024, // 测试环境：10MB（原100MB）
                        MaxFiles:     100,              // 测试环境：100个文件（原1000）
                        Compression:  false,
                        AutoCleanup:  true,
                        CleanupAge:   24 * time.Hour,
                        BufferSize:   8192,
                        SyncInterval: 5 * time.Second,
                },
                Cache: CacheConfig{
                        Type:            "memory",
                        MaxSize:         500,              // 测试环境：500条记录（原1000）
                        MaxMemory:       50 * 1024 * 1024, // 测试环境：50MB（原100MB）
                        TTL:             2 * time.Hour,    // 测试环境：2小时（原24小时）
                        EvictionPolicy:  "lru",
                        CleanupInterval: 2 * time.Minute, // 测试环境：2分钟（原5分钟）
                        Layers: []LayerConfig{
                                {
                                        Name:           "L1",
                                        Type:           "memory",
                                        MaxSize:        100,
                                        TTL:            1 * time.Hour,
                                        EvictionPolicy: "lru",
                                },
                                {
                                        Name:           "L2",
                                        Type:           "memory",
                                        MaxSize:        500,           // 测试环境：500条记录（原1000）
                                        TTL:            2 * time.Hour, // 测试环境：2小时（原24小时）
                                        EvictionPolicy: "lru",
                                },
                        },
                },
                Provider: ProviderConfig{
                        Type:            "tencent",
                        Timeout:         30 * time.Second,
                        RetryAttempts:   3,
                        RetryDelay:      1 * time.Second,
                        ConcurrentLimit: 10,
                        RateLimitQPS:    100,
                        UserAgent:       "stocksub-testkit/1.0",
                        Headers:         make(map[string]string),
                },
                Performance: PerformanceConfig{
                        WorkerCount:     2,                 // 测试环境：2个工作协程（原4）
                        BatchSize:       20,                // 测试环境：20条批处理（原50）
                        MaxConcurrency:  50,                // 测试环境：50并发（原100）
                        MemoryLimit:     100 * 1024 * 1024, // 测试环境：100MB（原500MB）
                        GCInterval:      5 * time.Minute,   // 测试环境：5分钟（原10分钟）
                        MetricsInterval: 30 * time.Second,  // 测试环境：30秒（原1分钟）
                        EnableProfiling: false,
                        EnableMetrics:   true,
                },
                Logging: LoggingConfig{
                        Level:        "info",
                        Format:       "text",
                        Output:       "stdout",
                        File:         "./logs/testkit.log",
                        MaxSize:      100,
                        MaxBackups:   3,
                        MaxAge:       7,
                        Compress:     true,
                        EnableCaller: false,
                        EnableTrace:  false,
                },
                Mock: MockConfig{
                        Enabled:      false,
                        ScenarioFile: "./scenarios.yaml",
                        DefaultDelay: 100 * time.Millisecond,
                        ErrorRate:    0.0,
                        DataGenerator: DataGenConfig{
                                Enabled:        false,
                                StockCount:     100,
                                PriceRange:     [2]float64{1.0, 1000.0},
                                VolumeRange:    [2]int64{1000, 10000000},
                                UpdateInterval: 1 * time.Second,
                                Volatility:     0.02,
                        },
                        Scenarios: make(map[string]interface{}),
                },
        }
}</span>

// LoadConfig 从指定的JSON文件加载配置。
// 如果文件不存在，它会使用默认配置创建一个新文件。
func LoadConfig(filename string) (*Config, error) <span class="cov3" title="2">{
        if filename == "" </span><span class="cov0" title="0">{
                return DefaultConfig(), nil
        }</span>

        // 检查文件是否存在
        <span class="cov3" title="2">if _, err := os.Stat(filename); os.IsNotExist(err) </span><span class="cov1" title="1">{
                // 文件不存在，使用默认配置并创建配置文件
                config := DefaultConfig()
                if err := SaveConfig(filename, config); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create default config file: %w", err)
                }</span>
                <span class="cov1" title="1">return config, nil</span>
        }

        // 读取配置文件
        <span class="cov1" title="1">data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // 解析配置
        <span class="cov1" title="1">config := DefaultConfig()
        if err := json.Unmarshal(data, config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        // 验证配置
        <span class="cov1" title="1">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid config: %w", err)
        }</span>

        <span class="cov1" title="1">return config, nil</span>
}

// SaveConfig 将给定的配置对象序列化为JSON并保存到文件。
func SaveConfig(filename string, config *Config) error <span class="cov3" title="2">{
        // 确保目录存在
        dir := filepath.Dir(filename)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        // 序列化配置
        <span class="cov3" title="2">data, err := json.MarshalIndent(config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        // 写入文件
        <span class="cov3" title="2">if err := os.WriteFile(filename, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// Validate 检查配置中的关键字段是否有效。
func (c *Config) Validate() error <span class="cov9" title="8">{

        // 验证存储配置
        if c.Storage.Type == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("storage type is required")
        }</span>
        <span class="cov9" title="8">if !isValidStorageType(c.Storage.Type) </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid storage type: %s, must be one of: csv, memory, json", c.Storage.Type)
        }</span>
        <span class="cov8" title="7">if c.Storage.Directory == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("storage directory is required")
        }</span>
        <span class="cov8" title="7">if c.Storage.MaxFileSize &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("storage max_file_size must be positive")
        }</span>
        <span class="cov8" title="7">if c.Storage.MaxFiles &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("storage max_files must be positive")
        }</span>

        // 验证缓存配置
        <span class="cov8" title="7">if c.Cache.MaxSize &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("cache max_size must be positive")
        }</span>
        <span class="cov8" title="7">if c.Cache.TTL &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("cache ttl must be positive")
        }</span>
        <span class="cov8" title="7">if !isValidCacheType(c.Cache.Type) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid cache type: %s, must be one of: memory, layered", c.Cache.Type)
        }</span>
        <span class="cov8" title="7">if !isValidEvictionPolicy(c.Cache.EvictionPolicy) </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid eviction policy: %s, must be one of: lru, lfu, fifo", c.Cache.EvictionPolicy)
        }</span>

        // 验证Provider配置
        <span class="cov8" title="6">if c.Provider.Type == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("provider type is required")
        }</span>
        <span class="cov8" title="6">if !isValidProviderType(c.Provider.Type) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid provider type: %s, must be one of: tencent, mock, hybrid", c.Provider.Type)
        }</span>
        <span class="cov8" title="6">if c.Provider.Timeout &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("provider timeout must be positive")
        }</span>
        <span class="cov8" title="6">if c.Provider.RetryAttempts &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("provider retry_attempts cannot be negative")
        }</span>
        <span class="cov8" title="6">if c.Provider.RateLimitQPS &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("provider rate_limit_qps cannot be negative")
        }</span>

        // 验证性能配置
        <span class="cov8" title="6">if c.Performance.WorkerCount &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("performance worker_count must be positive")
        }</span>
        <span class="cov8" title="6">if c.Performance.BatchSize &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("performance batch_size must be positive")
        }</span>
        <span class="cov8" title="6">if c.Performance.MemoryLimit &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("performance memory_limit must be positive")
        }</span>

        // 验证日志配置
        <span class="cov8" title="6">if !isValidLogLevel(c.Logging.Level) </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid log level: %s, must be one of: debug, info, warn, error", c.Logging.Level)
        }</span>
        <span class="cov7" title="5">if !isValidLogFormat(c.Logging.Format) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid log format: %s, must be one of: json, text", c.Logging.Format)
        }</span>
        <span class="cov7" title="5">if !isValidLogOutput(c.Logging.Output) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid log output: %s, must be one of: stdout, file, both", c.Logging.Output)
        }</span>

        // 验证Mock配置
        <span class="cov7" title="5">if c.Mock.ErrorRate &lt; 0 || c.Mock.ErrorRate &gt; 1 </span><span class="cov1" title="1">{
                return fmt.Errorf("mock error_rate must be between 0.0 and 1.0")
        }</span>
        <span class="cov6" title="4">if c.Mock.DataGenerator.Volatility &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("mock data_generator volatility cannot be negative")
        }</span>

        <span class="cov6" title="4">return nil</span>
}

// 辅助验证函数
func isValidStorageType(t string) bool <span class="cov10" title="10">{
        validTypes := map[string]bool{"csv": true, "memory": true, "json": true}
        return validTypes[t]
}</span>

func isValidCacheType(t string) bool <span class="cov9" title="9">{
        validTypes := map[string]bool{"memory": true, "layered": true}
        return validTypes[t]
}</span>

func isValidEvictionPolicy(policy string) bool <span class="cov9" title="9">{
        validPolicies := map[string]bool{"lru": true, "lfu": true, "fifo": true}
        return validPolicies[policy]
}</span>

func isValidProviderType(t string) bool <span class="cov8" title="6">{
        validTypes := map[string]bool{"tencent": true, "mock": true, "hybrid": true}
        return validTypes[t]
}</span>

func isValidLogLevel(level string) bool <span class="cov9" title="8">{
        validLevels := map[string]bool{"debug": true, "info": true, "warn": true, "error": true}
        return validLevels[level]
}</span>

func isValidLogFormat(format string) bool <span class="cov7" title="5">{
        validFormats := map[string]bool{"json": true, "text": true}
        return validFormats[format]
}</span>

func isValidLogOutput(output string) bool <span class="cov7" title="5">{
        validOutputs := map[string]bool{"stdout": true, "file": true, "both": true}
        return validOutputs[output]
}</span>

// IsTestEnvironment 检查当前是否运行在测试环境中
func IsTestEnvironment() bool <span class="cov5" title="3">{
        // 检查常见的测试环境标识
        if os.Getenv("GO_ENV") == "test" || os.Getenv("ENV") == "test" </span><span class="cov5" title="3">{
                return true
        }</span>
        // 检查是否在运行测试
        <span class="cov0" title="0">if len(os.Args) &gt; 0 &amp;&amp; (contains(os.Args, "-test.") || contains(os.Args, "test")) </span><span class="cov0" title="0">{
                return true
        }</span>
        // 检查是否在IDE的测试模式下运行
        <span class="cov0" title="0">if os.Getenv("IDE_TEST") == "true" || os.Getenv("TEST_MODE") == "true" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// DefaultConfigForEnvironment 根据运行环境返回合适的默认配置
func DefaultConfigForEnvironment() *Config <span class="cov1" title="1">{
        if IsTestEnvironment() </span><span class="cov1" title="1">{
                // 测试环境使用优化配置
                return DefaultConfig()
        }</span>

        // 生产环境使用更保守的配置
        <span class="cov0" title="0">config := DefaultConfig()

        // 生产环境调整配置
        config.Storage.MaxFileSize = 50 * 1024 * 1024           // 生产环境：50MB
        config.Storage.MaxFiles = 500                           // 生产环境：500个文件
        config.Cache.MaxSize = 2000                             // 生产环境：2000条记录
        config.Cache.MaxMemory = 200 * 1024 * 1024              // 生产环境：200MB
        config.Cache.TTL = 12 * time.Hour                       // 生产环境：12小时
        config.Performance.MemoryLimit = 1 * 1024 * 1024 * 1024 // 生产环境：1GB
        config.Performance.WorkerCount = 8                      // 生产环境：8个工作协程

        return config</span>
}

// contains 检查字符串切片是否包含特定字符串
func contains(slice []string, s string) bool <span class="cov0" title="0">{
        for _, item := range slice </span><span class="cov0" title="0">{
                if strings.Contains(item, s) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Merge 将另一个配置对象合并到当前配置，返回一个新的配置实例。
// other中的非零/非空值将覆盖当前配置的值。
func (c *Config) Merge(other *Config) *Config <span class="cov1" title="1">{
        // 创建新配置，避免修改原配置
        merged := *c

        if other == nil </span><span class="cov0" title="0">{
                return &amp;merged
        }</span>

        // 合并存储配置
        <span class="cov1" title="1">if other.Storage.Type != "" </span><span class="cov1" title="1">{
                merged.Storage.Type = other.Storage.Type
        }</span>
        <span class="cov1" title="1">if other.Storage.Directory != "" </span><span class="cov1" title="1">{
                merged.Storage.Directory = other.Storage.Directory
        }</span>

        // 合并缓存配置
        <span class="cov1" title="1">if other.Cache.MaxSize &gt; 0 </span><span class="cov1" title="1">{
                merged.Cache.MaxSize = other.Cache.MaxSize
        }</span>
        <span class="cov1" title="1">if other.Cache.TTL &gt; 0 </span><span class="cov1" title="1">{
                merged.Cache.TTL = other.Cache.TTL
        }</span>

        // 其他配置合并...

        <span class="cov1" title="1">return &amp;merged</span>
}

// Clone 创建并返回当前配置对象的一个深拷贝。
func (c *Config) Clone() *Config <span class="cov7" title="5">{
        clone := *c

        // 深拷贝切片和映射
        clone.Cache.Layers = make([]LayerConfig, len(c.Cache.Layers))
        copy(clone.Cache.Layers, c.Cache.Layers)

        clone.Provider.Headers = make(map[string]string)
        for k, v := range c.Provider.Headers </span><span class="cov0" title="0">{
                clone.Provider.Headers[k] = v
        }</span>

        <span class="cov7" title="5">clone.Mock.Scenarios = make(map[string]interface{})
        for k, v := range c.Mock.Scenarios </span><span class="cov0" title="0">{
                clone.Mock.Scenarios[k] = v
        }</span>

        <span class="cov7" title="5">return &amp;clone</span>
}

// SimpleConfig 是 Config 的简化版本，专为测试环境设计
// 包含最常用的配置选项，减少配置复杂性
type SimpleConfig struct {
        StorageType  string        `json:"storage_type" yaml:"storage_type"`   // 存储类型
        StorageDir   string        `json:"storage_dir" yaml:"storage_dir"`     // 存储目录
        CacheType    string        `json:"cache_type" yaml:"cache_type"`       // 缓存类型
        CacheSize    int64         `json:"cache_size" yaml:"cache_size"`       // 缓存大小
        CacheTTL     time.Duration `json:"cache_ttl" yaml:"cache_ttl"`         // 缓存生存时间
        ProviderType string        `json:"provider_type" yaml:"provider_type"` // Provider类型
        MockEnabled  bool          `json:"mock_enabled" yaml:"mock_enabled"`   // 是否启用Mock
        LogLevel     string        `json:"log_level" yaml:"log_level"`         // 日志级别
}

// ToSimple 将完整配置转换为简化配置
func (c *Config) ToSimple() *SimpleConfig <span class="cov1" title="1">{
        return &amp;SimpleConfig{
                StorageType:  c.Storage.Type,
                StorageDir:   c.Storage.Directory,
                CacheType:    c.Cache.Type,
                CacheSize:    c.Cache.MaxSize,
                CacheTTL:     c.Cache.TTL,
                ProviderType: c.Provider.Type,
                MockEnabled:  c.Mock.Enabled,
                LogLevel:     c.Logging.Level,
        }
}</span>

// ToFull 将简化配置转换为完整配置
func (s *SimpleConfig) ToFull() *Config <span class="cov1" title="1">{
        full := DefaultConfig()

        // 只覆盖简化配置中指定的字段
        if s.StorageType != "" </span><span class="cov1" title="1">{
                full.Storage.Type = s.StorageType
        }</span>
        <span class="cov1" title="1">if s.StorageDir != "" </span><span class="cov1" title="1">{
                full.Storage.Directory = s.StorageDir
        }</span>
        <span class="cov1" title="1">if s.CacheType != "" </span><span class="cov1" title="1">{
                full.Cache.Type = s.CacheType
        }</span>
        <span class="cov1" title="1">if s.CacheSize &gt; 0 </span><span class="cov1" title="1">{
                full.Cache.MaxSize = s.CacheSize
        }</span>
        <span class="cov1" title="1">if s.CacheTTL &gt; 0 </span><span class="cov1" title="1">{
                full.Cache.TTL = s.CacheTTL
        }</span>
        <span class="cov1" title="1">if s.ProviderType != "" </span><span class="cov1" title="1">{
                full.Provider.Type = s.ProviderType
        }</span>
        <span class="cov1" title="1">full.Mock.Enabled = s.MockEnabled
        if s.LogLevel != "" </span><span class="cov1" title="1">{
                full.Logging.Level = s.LogLevel
        }</span>

        <span class="cov1" title="1">return full</span>
}

// DefaultSimpleConfig 返回适合测试环境的简化默认配置
func DefaultSimpleConfig() *SimpleConfig <span class="cov1" title="1">{
        return &amp;SimpleConfig{
                StorageType:  "csv",
                StorageDir:   "./testdata",
                CacheType:    "memory",
                CacheSize:    100,           // 测试环境：100条记录
                CacheTTL:     1 * time.Hour, // 测试环境：1小时
                ProviderType: "tencent",
                MockEnabled:  false,
                LogLevel:     "info",
        }
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package core

import (
        "errors"
        "fmt"
        "time"
)

// ErrorCode 是一个字符串类型，用于表示 testkit 框架中所有预定义的错误类别。
type ErrorCode string

// 标准错误代码常量定义了 testkit 中可能出现的各种错误。
const (
        // ErrCacheTimeout 表示缓存操作超时。
        ErrCacheTimeout ErrorCode = "CACHE_TIMEOUT"
        // ErrCacheMiss 表示在缓存中未找到请求的条目。
        ErrCacheMiss ErrorCode = "CACHE_MISS"
        // ErrCacheFull 表示缓存已满，无法添加新条目。
        ErrCacheFull ErrorCode = "CACHE_FULL"
        // ErrCacheCorrupted 表示缓存数据已损坏。
        ErrCacheCorrupted ErrorCode = "CACHE_CORRUPTED"

        // ErrStorageFull 表示存储空间已满。
        ErrStorageFull ErrorCode = "STORAGE_FULL"
        // ErrStorageIO 表示发生了存储I/O错误。
        ErrStorageIO ErrorCode = "STORAGE_IO"
        // ErrStorageCorrupted 表示持久化存储的数据已损坏。
        ErrStorageCorrupted ErrorCode = "STORAGE_CORRUPTED"
        // ErrStoragePermission 表示存储权限不足。
        ErrStoragePermission ErrorCode = "STORAGE_PERMISSION"

        // ErrSerializeFailed 表示序列化操作失败。
        ErrSerializeFailed ErrorCode = "SERIALIZE_FAILED"
        // ErrDeserializeFailed 表示反序列化操作失败。
        ErrDeserializeFailed ErrorCode = "DESERIALIZE_FAILED"
        // ErrInvalidFormat 表示数据格式无效。
        ErrInvalidFormat ErrorCode = "INVALID_FORMAT"

        // ErrProviderError 表示数据提供者返回了一个通用错误。
        ErrProviderError ErrorCode = "PROVIDER_ERROR"
        // ErrProviderTimeout 表示数据提供者操作超时。
        ErrProviderTimeout ErrorCode = "PROVIDER_TIMEOUT"
        // ErrProviderNotFound 表示数据提供者未找到请求的资源。
        ErrProviderNotFound ErrorCode = "PROVIDER_NOT_FOUND"
        // ErrProviderAuth 表示数据提供者认证失败。
        ErrProviderAuth ErrorCode = "PROVIDER_AUTH"

        // ErrConcurrencyLimit 表示超出了并发限制。
        ErrConcurrencyLimit ErrorCode = "CONCURRENCY_LIMIT"
        // ErrDeadlock 表示检测到死锁。
        ErrDeadlock ErrorCode = "DEADLOCK"
        // ErrRaceCondition 表示检测到竞态条件。
        ErrRaceCondition ErrorCode = "RACE_CONDITION"

        // ErrConfigInvalid 表示配置无效。
        ErrConfigInvalid ErrorCode = "CONFIG_INVALID"
        // ErrConfigMissing 表示缺少必要的配置项。
        ErrConfigMissing ErrorCode = "CONFIG_MISSING"

        // ErrSystemResource 表示系统资源不足。
        ErrSystemResource ErrorCode = "SYSTEM_RESOURCE"
        // ErrSystemShutdown 表示系统正在关闭。
        ErrSystemShutdown ErrorCode = "SYSTEM_SHUTDOWN"
        // ErrInternalError 表示发生了未知的内部错误。
        ErrInternalError ErrorCode = "INTERNAL_ERROR"
        // ErrResourceClosed 表示尝试访问已关闭的资源。
        ErrResourceClosed ErrorCode = "RESOURCE_CLOSED"
)

// TestKitError 是 testkit 框架的自定义错误类型。
// 它包含了错误代码、消息、可选的原始错误(cause)和附加上下文信息。
type TestKitError struct {
        Code      ErrorCode              `json:"code"`              // 错误的分类代码
        Message   string                 `json:"message"`           // 人类可读的错误信息
        Cause     error                  `json:"-"`                 // 导致此错误的原始错误
        Context   map[string]interface{} `json:"context,omitempty"` // 额外的上下文信息
        Timestamp time.Time              `json:"timestamp"`         // 错误发生的时间戳
        Stack     []string               `json:"stack,omitempty"`   // 错误发生时的调用栈
}

// Error 实现了 Go 内置的 error 接口。
func (e *TestKitError) Error() string <span class="cov2" title="2">{
        if e.Cause != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s: %s (caused by: %s)", e.Code, e.Message, e.Cause.Error())
        }</span>
        <span class="cov2" title="2">return fmt.Sprintf("%s: %s", e.Code, e.Message)</span>
}

// Unwrap 实现了 Go 1.13+ 的错误包装接口，允许访问被包装的原始错误(Cause)。
func (e *TestKitError) Unwrap() error <span class="cov0" title="0">{
        return e.Cause
}</span>

// Is 实现了错误判断接口，用于判断一个错误是否与目标错误具有相同的错误代码。
func (e *TestKitError) Is(target error) bool <span class="cov0" title="0">{
        var tkErr *TestKitError
        if errors.As(target, &amp;tkErr) </span><span class="cov0" title="0">{
                return e.Code == tkErr.Code
        }</span>
        <span class="cov0" title="0">return false</span>
}

// WithContext 为错误附加一个键值对形式的上下文信息。
func (e *TestKitError) WithContext(key string, value interface{}) *TestKitError <span class="cov0" title="0">{
        if e.Context == nil </span><span class="cov0" title="0">{
                e.Context = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">e.Context[key] = value
        return e</span>
}

// WithStack 为错误附加调用栈信息。
func (e *TestKitError) WithStack(stack []string) *TestKitError <span class="cov0" title="0">{
        e.Stack = stack
        return e
}</span>

// NewTestKitError 创建一个新的 TestKitError。
func NewTestKitError(code ErrorCode, message string) *TestKitError <span class="cov10" title="60">{
        return &amp;TestKitError{
                Code:      code,
                Message:   message,
                Timestamp: time.Now(),
                Context:   make(map[string]interface{}),
        }
}</span>

// WrapError 将一个已有的 error 包装成一个新的 TestKitError。
func WrapError(code ErrorCode, message string, cause error) *TestKitError <span class="cov0" title="0">{
        return &amp;TestKitError{
                Code:      code,
                Message:   message,
                Cause:     cause,
                Timestamp: time.Now(),
                Context:   make(map[string]interface{}),
        }
}</span>

// 预定义的常用错误实例
var (
        ErrCacheMissNotFound    = NewTestKitError(ErrCacheMiss, "cache entry not found")
        ErrCacheTimeoutExceeded = NewTestKitError(ErrCacheTimeout, "cache operation timeout")
        ErrStorageQuotaExceeded = NewTestKitError(ErrStorageFull, "storage quota exceeded")
        ErrSerializationFailed  = NewTestKitError(ErrSerializeFailed, "data serialization failed")
        ErrConcurrencyExceeded  = NewTestKitError(ErrConcurrencyLimit, "concurrency limit exceeded")
        ErrInvalidConfiguration = NewTestKitError(ErrConfigInvalid, "invalid configuration")
        ErrShutdownInProgress   = NewTestKitError(ErrSystemShutdown, "system shutdown in progress")
)

// ErrorHandler 定义了错误处理器的行为，用于实现复杂的错误处理逻辑，如重试。
type ErrorHandler interface {
        HandleError(ctx interface{}, err error) error
        ShouldRetry(err error) bool
        GetRetryDelay(attempt int, err error) time.Duration
}

// RetryConfig 定义了重试操作的配置参数。
type RetryConfig struct {
        MaxAttempts    int           `json:"max_attempts"`    // 最大重试次数
        InitialDelay   time.Duration `json:"initial_delay"`   // 初始延迟
        MaxDelay       time.Duration `json:"max_delay"`       // 最大延迟
        BackoffFactor  float64       `json:"backoff_factor"`  // 退避因子，用于指数退避算法
        RetryableCodes []ErrorCode   `json:"retryable_codes"` // 可重试的错误代码列表
}

// DefaultRetryConfig 是一个默认的重试配置实例。
var DefaultRetryConfig = RetryConfig{
        MaxAttempts:   3,
        InitialDelay:  100 * time.Millisecond,
        MaxDelay:      5 * time.Second,
        BackoffFactor: 2.0,
        RetryableCodes: []ErrorCode{
                ErrCacheTimeout,
                ErrProviderTimeout,
                ErrStorageIO,
                ErrSystemResource,
        },
}

// IsRetryable 判断一个错误根据默认配置是否是可重试的。
func IsRetryable(err error) bool <span class="cov0" title="0">{
        var tkErr *TestKitError
        if errors.As(err, &amp;tkErr) </span><span class="cov0" title="0">{
                for _, code := range DefaultRetryConfig.RetryableCodes </span><span class="cov0" title="0">{
                        if tkErr.Code == code </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

// CalculateRetryDelay 根据默认配置和当前重试次数计算下一次重试的延迟时间（指数退避）。
func CalculateRetryDelay(attempt int, config RetryConfig) time.Duration <span class="cov0" title="0">{
        if attempt &lt;= 0 </span><span class="cov0" title="0">{
                return config.InitialDelay
        }</span>

        <span class="cov0" title="0">delay := float64(config.InitialDelay)
        for i := 0; i &lt; attempt; i++ </span><span class="cov0" title="0">{
                delay *= config.BackoffFactor
        }</span>

        <span class="cov0" title="0">if delay &gt; float64(config.MaxDelay) </span><span class="cov0" title="0">{
                delay = float64(config.MaxDelay)
        }</span>

        <span class="cov0" title="0">return time.Duration(delay)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package helpers

import (
        "bufio"
        "encoding/csv"
        "os"
        "sync"
        "sync/atomic"

        "stocksub/pkg/testkit/core"
)

// ResourceManager 资源管理器实现
type ResourceManager struct {
        // 资源池
        csvWriterPool *sync.Pool
        bufferPool    *sync.Pool
        filePool      *sync.Pool

        // 清理函数
        cleanupFuncs []func()
        cleanupMu    sync.Mutex

        // 统计信息
        csvWriterAcquired int64
        csvWriterReleased int64
        bufferAcquired    int64
        bufferReleased    int64

        // 配置
        config ResourceConfig
}

// ResourceConfig 资源管理配置
type ResourceConfig struct {
        BufferSize    int  `yaml:"buffer_size"`    // 缓冲区大小
        MaxBuffers    int  `yaml:"max_buffers"`    // 最大缓冲区数量
        MaxWriters    int  `yaml:"max_writers"`    // 最大写入器数量
        EnablePooling bool `yaml:"enable_pooling"` // 是否启用池化
}

// NewResourceManager 创建资源管理器
func NewResourceManager(config ResourceConfig) *ResourceManager <span class="cov7" title="7">{
        rm := &amp;ResourceManager{
                config:       config,
                cleanupFuncs: make([]func(), 0),
        }

        if config.EnablePooling </span><span class="cov7" title="7">{
                rm.initPools()
        }</span>

        <span class="cov7" title="7">return rm</span>
}

// initPools 初始化资源池
func (rm *ResourceManager) initPools() <span class="cov7" title="7">{
        // CSV写入器池
        rm.csvWriterPool = &amp;sync.Pool{
                New: func() interface{} </span><span class="cov7" title="6">{
                        buffer := rm.acquireBufferInternal()
                        return csv.NewWriter(buffer.(*bufio.Writer))
                }</span>,
        }

        // 缓冲区池
        <span class="cov7" title="7">rm.bufferPool = &amp;sync.Pool{
                New: func() interface{} </span><span class="cov9" title="13">{
                        return bufio.NewWriterSize(nil, rm.config.BufferSize)
                }</span>,
        }

        // 文件池（用于复用文件句柄，虽然CSV通常不适用）
        <span class="cov7" title="7">rm.filePool = &amp;sync.Pool{
                New: func() interface{} </span><span class="cov0" title="0">{
                        return nil // 文件不能预创建，返回nil
                }</span>,
        }
}

// AcquireCSVWriter 获取CSV写入器
func (rm *ResourceManager) AcquireCSVWriter() interface{} <span class="cov7" title="7">{
        atomic.AddInt64(&amp;rm.csvWriterAcquired, 1)

        if !rm.config.EnablePooling || rm.csvWriterPool == nil </span><span class="cov0" title="0">{
                buffer := rm.AcquireBuffer().(*bufio.Writer)
                return csv.NewWriter(buffer)
        }</span>

        <span class="cov7" title="7">writer := rm.csvWriterPool.Get().(*csv.Writer)
        return writer</span>
}

// ReleaseCSVWriter 释放CSV写入器
func (rm *ResourceManager) ReleaseCSVWriter(writer interface{}) <span class="cov10" title="14">{
        atomic.AddInt64(&amp;rm.csvWriterReleased, 1)

        switch w := writer.(type) </span>{
        case *csv.Writer:<span class="cov10" title="14">
                if !rm.config.EnablePooling || rm.csvWriterPool == nil </span><span class="cov0" title="0">{
                        w.Flush()
                        return
                }</span>

                <span class="cov10" title="14">w.Flush()
                rm.csvWriterPool.Put(w)</span>
        }
}

// AcquireBuffer 获取缓冲区
func (rm *ResourceManager) AcquireBuffer() interface{} <span class="cov7" title="7">{
        return rm.acquireBufferInternal()
}</span>

// acquireBufferInternal 内部获取缓冲区方法
func (rm *ResourceManager) acquireBufferInternal() interface{} <span class="cov9" title="13">{
        atomic.AddInt64(&amp;rm.bufferAcquired, 1)

        if !rm.config.EnablePooling || rm.bufferPool == nil </span><span class="cov0" title="0">{
                return bufio.NewWriterSize(nil, rm.config.BufferSize)
        }</span>

        <span class="cov9" title="13">buffer := rm.bufferPool.Get().(*bufio.Writer)
        buffer.Reset(nil) // 重置缓冲区
        return buffer</span>
}

// ReleaseBuffer 释放缓冲区
func (rm *ResourceManager) ReleaseBuffer(buffer interface{}) <span class="cov7" title="7">{
        atomic.AddInt64(&amp;rm.bufferReleased, 1)

        if !rm.config.EnablePooling || rm.bufferPool == nil </span><span class="cov0" title="0">{
                if b, ok := buffer.(*bufio.Writer); ok </span><span class="cov0" title="0">{
                        b.Flush()
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov7" title="7">if b, ok := buffer.(*bufio.Writer); ok </span><span class="cov7" title="7">{
                b.Flush()
                rm.bufferPool.Put(b)
        }</span>
}

// RegisterCleanup 注册清理函数
func (rm *ResourceManager) RegisterCleanup(fn func()) <span class="cov10" title="14">{
        rm.cleanupMu.Lock()
        defer rm.cleanupMu.Unlock()

        rm.cleanupFuncs = append(rm.cleanupFuncs, fn)
}</span>

// Cleanup 执行清理
func (rm *ResourceManager) Cleanup() <span class="cov7" title="7">{
        rm.cleanupMu.Lock()
        defer rm.cleanupMu.Unlock()

        for _, fn := range rm.cleanupFuncs </span><span class="cov10" title="14">{
                if fn != nil </span><span class="cov10" title="14">{
                        fn()
                }</span>
        }

        <span class="cov7" title="7">rm.cleanupFuncs = rm.cleanupFuncs[:0]</span> // 清空但保留容量
}

// GetStats 获取资源使用统计
func (rm *ResourceManager) GetStats() ResourceStats <span class="cov3" title="2">{
        return ResourceStats{
                CSVWriterAcquired: atomic.LoadInt64(&amp;rm.csvWriterAcquired),
                CSVWriterReleased: atomic.LoadInt64(&amp;rm.csvWriterReleased),
                BufferAcquired:    atomic.LoadInt64(&amp;rm.bufferAcquired),
                BufferReleased:    atomic.LoadInt64(&amp;rm.bufferReleased),
                PoolingEnabled:    rm.config.EnablePooling,
                BufferSize:        rm.config.BufferSize,
        }
}</span>

// ResourceStats 资源使用统计
type ResourceStats struct {
        CSVWriterAcquired int64 `json:"csv_writer_acquired"`
        CSVWriterReleased int64 `json:"csv_writer_released"`
        BufferAcquired    int64 `json:"buffer_acquired"`
        BufferReleased    int64 `json:"buffer_released"`
        PoolingEnabled    bool  `json:"pooling_enabled"`
        BufferSize        int   `json:"buffer_size"`
}

// Close 关闭资源管理器
func (rm *ResourceManager) Close() error <span class="cov7" title="7">{
        rm.Cleanup()
        return nil
}</span>

// CSVWriterWrapper CSV写入器包装器，提供自动资源管理
type CSVWriterWrapper struct {
        writer  *csv.Writer
        buffer  *bufio.Writer
        file    *os.File
        manager *ResourceManager
        closed  bool
        mu      sync.Mutex
}

// NewCSVWriterWrapper 创建CSV写入器包装器
func NewCSVWriterWrapper(file *os.File, manager *ResourceManager) *CSVWriterWrapper <span class="cov7" title="7">{
        buffer := manager.AcquireBuffer().(*bufio.Writer)
        buffer.Reset(file)

        writerInterface := manager.AcquireCSVWriter()

        // 获取底层缓冲区写入器，如果writer不是基于我们的buffer创建的
        if csvWriter, ok := writerInterface.(*csv.Writer); ok </span><span class="cov7" title="7">{
                // 重新创建writer，确保使用我们的buffer
                writer := csv.NewWriter(buffer)
                manager.ReleaseCSVWriter(csvWriter) // 释放之前的writer

                wrapper := &amp;CSVWriterWrapper{
                        writer:  writer,
                        buffer:  buffer,
                        file:    file,
                        manager: manager,
                }

                // 注册清理函数
                manager.RegisterCleanup(func() </span><span class="cov7" title="7">{
                        wrapper.Close()
                }</span>)

                <span class="cov7" title="7">return wrapper</span>
        }

        // 如果类型断言失败，直接创建新的writer
        <span class="cov0" title="0">writer := csv.NewWriter(buffer)

        wrapper := &amp;CSVWriterWrapper{
                writer:  writer,
                buffer:  buffer,
                file:    file,
                manager: manager,
        }

        // 注册清理函数
        manager.RegisterCleanup(func() </span><span class="cov0" title="0">{
                wrapper.Close()
        }</span>)

        <span class="cov0" title="0">return wrapper</span>
}

// Write 写入记录
func (cw *CSVWriterWrapper) Write(record []string) error <span class="cov9" title="12">{
        cw.mu.Lock()
        defer cw.mu.Unlock()

        if cw.closed </span><span class="cov0" title="0">{
                return core.NewTestKitError(core.ErrResourceClosed, "resource has been closed")
        }</span>

        <span class="cov9" title="12">return cw.writer.Write(record)</span>
}

// WriteAll 写入所有记录
func (cw *CSVWriterWrapper) WriteAll(records [][]string) error <span class="cov3" title="2">{
        cw.mu.Lock()
        defer cw.mu.Unlock()

        if cw.closed </span><span class="cov0" title="0">{
                return core.NewTestKitError(core.ErrResourceClosed, "resource has been closed")
        }</span>

        <span class="cov3" title="2">return cw.writer.WriteAll(records)</span>
}

// Flush 刷新缓冲区
func (cw *CSVWriterWrapper) Flush() error <span class="cov7" title="6">{
        cw.mu.Lock()
        defer cw.mu.Unlock()

        if cw.closed </span><span class="cov0" title="0">{
                return core.NewTestKitError(core.ErrResourceClosed, "resource has been closed")
        }</span>

        <span class="cov7" title="6">cw.writer.Flush()
        return cw.buffer.Flush()</span>
}

// Close 关闭写入器
func (cw *CSVWriterWrapper) Close() error <span class="cov10" title="14">{
        cw.mu.Lock()
        defer cw.mu.Unlock()

        if cw.closed </span><span class="cov7" title="7">{
                return nil
        }</span>

        // 刷新数据
        <span class="cov7" title="7">cw.writer.Flush()
        cw.buffer.Flush()

        // 释放资源
        cw.manager.ReleaseCSVWriter(cw.writer)
        cw.manager.ReleaseBuffer(cw.buffer)

        // 关闭文件
        if cw.file != nil </span><span class="cov7" title="7">{
                cw.file.Close()
        }</span>

        <span class="cov7" title="7">cw.closed = true
        return nil</span>
}

// Error 获取CSV写入器的错误
func (cw *CSVWriterWrapper) Error() error <span class="cov0" title="0">{
        cw.mu.Lock()
        defer cw.mu.Unlock()

        return cw.writer.Error()
}</span>

// DefaultResourceConfig 默认资源配置
func DefaultResourceConfig() ResourceConfig <span class="cov7" title="7">{
        return ResourceConfig{
                BufferSize:    64 * 1024, // 64KB
                MaxBuffers:    100,
                MaxWriters:    50,
                EnablePooling: true,
        }
}</span>

// FileManager 文件管理器
type FileManager struct {
        openFiles map[string]*os.File
        mu        sync.RWMutex
        manager   *ResourceManager
}

// NewFileManager 创建文件管理器
func NewFileManager(manager *ResourceManager) *FileManager <span class="cov7" title="7">{
        return &amp;FileManager{
                openFiles: make(map[string]*os.File),
                manager:   manager,
        }
}</span>

// OpenFile 打开文件
func (fm *FileManager) OpenFile(filename string, flag int, perm os.FileMode) (*os.File, error) <span class="cov7" title="7">{
        fm.mu.Lock()
        defer fm.mu.Unlock()

        // 检查是否已经打开
        if file, exists := fm.openFiles[filename]; exists </span><span class="cov0" title="0">{
                return file, nil
        }</span>

        // 打开新文件
        <span class="cov7" title="7">file, err := os.OpenFile(filename, flag, perm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="7">fm.openFiles[filename] = file

        // 注册清理函数
        fm.manager.RegisterCleanup(func() </span><span class="cov7" title="7">{
                fm.closeFile(filename)
        }</span>)

        <span class="cov7" title="7">return file, nil</span>
}

// closeFile 关闭指定文件
func (fm *FileManager) closeFile(filename string) <span class="cov7" title="7">{
        if file, exists := fm.openFiles[filename]; exists </span><span class="cov0" title="0">{
                file.Close()
                delete(fm.openFiles, filename)
        }</span>
}

// CloseAll 关闭所有文件
func (fm *FileManager) CloseAll() error <span class="cov7" title="7">{
        fm.mu.Lock()
        defer fm.mu.Unlock()

        var lastErr error
        for filename, file := range fm.openFiles </span><span class="cov7" title="7">{
                if err := file.Close(); err != nil </span><span class="cov7" title="7">{
                        lastErr = err
                }</span>
                <span class="cov7" title="7">delete(fm.openFiles, filename)</span>
        }

        <span class="cov7" title="7">return lastErr</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package providers

import (
        "context"
        "fmt"
        "sync"
        "time"

        "stocksub/pkg/provider/tencent"
        "stocksub/pkg/subscriber"
        "stocksub/pkg/testkit/core"
)

// CachedProvider 缓存包装的Provider
type CachedProvider struct {
        realProvider core.Provider
        mockProvider *MockProvider
        cache        core.Cache
        mu           sync.RWMutex
        config       CachedProviderConfig
        stats        CachedProviderStats
        mockMode     bool
}

// CachedProviderConfig 缓存Provider配置
type CachedProviderConfig struct {
        CacheTTL           time.Duration `yaml:"cache_ttl"`            // 缓存TTL
        EnableMockFallback bool          `yaml:"enable_mock_fallback"` // 是否启用Mock回退
        MaxRetries         int           `yaml:"max_retries"`          // 最大重试次数
        RetryDelay         time.Duration `yaml:"retry_delay"`          // 重试延迟
        TimeoutDuration    time.Duration `yaml:"timeout_duration"`     // 请求超时
}

// CachedProviderStats 缓存Provider统计
type CachedProviderStats struct {
        TotalRequests     int64         `json:"total_requests"`
        CacheHits         int64         `json:"cache_hits"`
        CacheMisses       int64         `json:"cache_misses"`
        RealProviderCalls int64         `json:"real_provider_calls"`
        MockProviderCalls int64         `json:"mock_provider_calls"`
        FailedRequests    int64         `json:"failed_requests"`
        AverageLatency    time.Duration `json:"average_latency"`
        LastRequest       time.Time     `json:"last_request"`
}

// NewCachedProvider 创建缓存Provider
func NewCachedProvider(realProvider core.Provider, cache core.Cache, config CachedProviderConfig) *CachedProvider <span class="cov6" title="2">{
        // 创建Mock Provider
        mockConfig := DefaultMockProviderConfig()
        mockProvider := NewMockProvider(mockConfig)

        return &amp;CachedProvider{
                realProvider: realProvider,
                mockProvider: mockProvider,
                cache:        cache,
                config:       config,
                stats:        CachedProviderStats{},
                mockMode:     false,
        }
}</span>

// FetchData 获取股票数据
func (cp *CachedProvider) FetchData(ctx context.Context, symbols []string) ([]subscriber.StockData, error) <span class="cov10" title="3">{
        startTime := time.Now()
        cp.stats.TotalRequests++
        cp.stats.LastRequest = startTime

        // 如果是Mock模式，直接使用Mock Provider
        if cp.mockMode </span><span class="cov1" title="1">{
                cp.stats.MockProviderCalls++
                return cp.mockProvider.FetchData(ctx, symbols)
        }</span>

        // 尝试从缓存获取
        <span class="cov6" title="2">cacheKey := cp.generateCacheKey(symbols)
        if cached, err := cp.cache.Get(ctx, cacheKey); err == nil </span><span class="cov1" title="1">{
                cp.stats.CacheHits++
                cp.updateLatency(time.Since(startTime))
                return cached.([]subscriber.StockData), nil
        }</span>

        <span class="cov1" title="1">cp.stats.CacheMisses++

        // 从真实Provider获取数据
        data, err := cp.fetchFromRealProvider(ctx, symbols)
        if err != nil </span><span class="cov0" title="0">{
                cp.stats.FailedRequests++

                // 如果启用了Mock回退，使用Mock数据
                if cp.config.EnableMockFallback </span><span class="cov0" title="0">{
                        cp.stats.MockProviderCalls++
                        mockData, mockErr := cp.mockProvider.FetchData(ctx, symbols)
                        if mockErr == nil </span><span class="cov0" title="0">{
                                cp.updateLatency(time.Since(startTime))
                                return mockData, nil
                        }</span>
                }

                <span class="cov0" title="0">return nil, fmt.Errorf("获取数据失败: %w", err)</span>
        }

        // 存入缓存
        <span class="cov1" title="1">if err := cp.cache.Set(ctx, cacheKey, data, cp.config.CacheTTL); err != nil </span><span class="cov0" title="0">{
                // 缓存失败不影响数据返回，只记录错误
                fmt.Printf("缓存写入失败: %v\n", err)
        }</span>

        <span class="cov1" title="1">cp.stats.RealProviderCalls++
        cp.updateLatency(time.Since(startTime))

        return data, nil</span>
}

// SetMockMode 设置Mock模式
func (cp *CachedProvider) SetMockMode(enabled bool) <span class="cov1" title="1">{
        cp.mu.Lock()
        defer cp.mu.Unlock()

        cp.mockMode = enabled
        if cp.mockProvider != nil </span><span class="cov1" title="1">{
                cp.mockProvider.SetMockMode(enabled)
        }</span>
}

// SetMockData 设置Mock数据
func (cp *CachedProvider) SetMockData(symbols []string, data []subscriber.StockData) <span class="cov1" title="1">{
        if cp.mockProvider != nil </span><span class="cov1" title="1">{
                cp.mockProvider.SetMockData(symbols, data)
        }</span>
}

// Close 关闭Provider
func (cp *CachedProvider) Close() error <span class="cov6" title="2">{
        var errs []error

        if cp.realProvider != nil </span><span class="cov6" title="2">{
                if err := cp.realProvider.Close(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("关闭真实Provider失败: %w", err))
                }</span>
        }

        <span class="cov6" title="2">if cp.mockProvider != nil </span><span class="cov6" title="2">{
                if err := cp.mockProvider.Close(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("关闭Mock Provider失败: %w", err))
                }</span>
        }

        <span class="cov6" title="2">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("关闭Provider时发生错误: %v", errs)
        }</span>

        <span class="cov6" title="2">return nil</span>
}

// GetStats 获取统计信息
func (cp *CachedProvider) GetStats() CachedProviderStats <span class="cov6" title="2">{
        cp.mu.RLock()
        defer cp.mu.RUnlock()

        return cp.stats
}</span>

// GetMockProvider 获取Mock Provider
func (cp *CachedProvider) GetMockProvider() *MockProvider <span class="cov0" title="0">{
        return cp.mockProvider
}</span>

// fetchFromRealProvider 从真实Provider获取数据（带重试）
func (cp *CachedProvider) fetchFromRealProvider(ctx context.Context, symbols []string) ([]subscriber.StockData, error) <span class="cov1" title="1">{
        var lastErr error

        for attempt := 0; attempt &lt;= cp.config.MaxRetries; attempt++ </span><span class="cov1" title="1">{
                // 创建超时上下文
                timeoutCtx, cancel := context.WithTimeout(ctx, cp.config.TimeoutDuration)

                data, err := cp.realProvider.FetchData(timeoutCtx, symbols)
                cancel()

                if err == nil </span><span class="cov1" title="1">{
                        return data, nil
                }</span>

                <span class="cov0" title="0">lastErr = err

                // 如果不是最后一次尝试，等待后重试
                if attempt &lt; cp.config.MaxRetries </span><span class="cov0" title="0">{
                        time.Sleep(cp.config.RetryDelay)
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("重试 %d 次后仍失败: %w", cp.config.MaxRetries, lastErr)</span>
}

// generateCacheKey 生成缓存键
func (cp *CachedProvider) generateCacheKey(symbols []string) string <span class="cov6" title="2">{
        // 简单的键生成策略
        key := "stock_data:"
        for i, symbol := range symbols </span><span class="cov6" title="2">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        key += ","
                }</span>
                <span class="cov6" title="2">key += symbol</span>
        }
        <span class="cov6" title="2">return key</span>
}

// updateLatency 更新平均延迟
func (cp *CachedProvider) updateLatency(duration time.Duration) <span class="cov6" title="2">{
        if cp.stats.AverageLatency == 0 </span><span class="cov1" title="1">{
                cp.stats.AverageLatency = duration
        }</span> else<span class="cov1" title="1"> {
                // 简单的移动平均
                cp.stats.AverageLatency = (cp.stats.AverageLatency + duration) / 2
        }</span>
}

// TencentProviderWrapper 腾讯Provider包装器
type TencentProviderWrapper struct {
        client *tencent.Provider
        mu     sync.Mutex
}

// FetchData 获取股票数据
func (tpw *TencentProviderWrapper) FetchData(ctx context.Context, symbols []string) ([]subscriber.StockData, error) <span class="cov0" title="0">{
        tpw.mu.Lock()
        defer tpw.mu.Unlock()

        // 如果客户端未初始化，进行初始化
        if tpw.client == nil </span><span class="cov0" title="0">{
                tpw.client = tencent.NewProvider()
        }</span>

        // 调用腾讯API
        <span class="cov0" title="0">return tpw.client.FetchData(ctx, symbols)</span>
}

// SetMockMode 设置Mock模式（腾讯Provider不支持）
func (tpw *TencentProviderWrapper) SetMockMode(enabled bool) {<span class="cov0" title="0">
        // 腾讯Provider不支持Mock模式
}</span>

// SetMockData 设置Mock数据（腾讯Provider不支持）
func (tpw *TencentProviderWrapper) SetMockData(symbols []string, data []subscriber.StockData) {<span class="cov0" title="0">
        // 腾讯Provider不支持Mock数据设置
}</span>

// Close 关闭Provider
func (tpw *TencentProviderWrapper) Close() error <span class="cov0" title="0">{
        // 腾讯Provider没有需要关闭的资源
        return nil
}</span>

// ProviderFactory Provider工厂
type ProviderFactory struct {
        cache core.Cache
}

// NewProviderFactory 创建Provider工厂
func NewProviderFactory(cache core.Cache) *ProviderFactory <span class="cov0" title="0">{
        return &amp;ProviderFactory{
                cache: cache,
        }
}</span>

// CreateMockProvider 创建Mock Provider
func (pf *ProviderFactory) CreateMockProvider(config MockProviderConfig) *MockProvider <span class="cov0" title="0">{
        return NewMockProvider(config)
}</span>

// CreateCachedProvider 创建缓存Provider
func (pf *ProviderFactory) CreateCachedProvider(config CachedProviderConfig) *CachedProvider <span class="cov0" title="0">{
        return NewCachedProvider(pf.CreateRealProvider(), pf.cache, config)
}</span>

// CreateRealProvider 创建真实Provider
func (pf *ProviderFactory) CreateRealProvider() core.Provider <span class="cov0" title="0">{
        return &amp;TencentProviderWrapper{}
}</span>

// ProviderManager Provider管理器
type ProviderManager struct {
        providers map[string]core.Provider
        mu        sync.RWMutex
        factory   *ProviderFactory
}

// NewProviderManager 创建Provider管理器
func NewProviderManager(cache core.Cache) *ProviderManager <span class="cov0" title="0">{
        return &amp;ProviderManager{
                providers: make(map[string]core.Provider),
                factory:   NewProviderFactory(cache),
        }
}</span>

// RegisterProvider 注册Provider
func (pm *ProviderManager) RegisterProvider(name string, provider core.Provider) <span class="cov0" title="0">{
        pm.mu.Lock()
        defer pm.mu.Unlock()

        pm.providers[name] = provider
}</span>

// GetProvider 获取Provider
func (pm *ProviderManager) GetProvider(name string) (core.Provider, bool) <span class="cov0" title="0">{
        pm.mu.RLock()
        defer pm.mu.RUnlock()

        provider, exists := pm.providers[name]
        return provider, exists
}</span>

// RemoveProvider 移除Provider
func (pm *ProviderManager) RemoveProvider(name string) <span class="cov0" title="0">{
        pm.mu.Lock()
        defer pm.mu.Unlock()

        if provider, exists := pm.providers[name]; exists </span><span class="cov0" title="0">{
                provider.Close()
                delete(pm.providers, name)
        }</span>
}

// CloseAll 关闭所有Provider
func (pm *ProviderManager) CloseAll() error <span class="cov0" title="0">{
        pm.mu.Lock()
        defer pm.mu.Unlock()

        var errs []error
        for name, provider := range pm.providers </span><span class="cov0" title="0">{
                if err := provider.Close(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("关闭Provider %s 失败: %w", name, err))
                }</span>
        }

        <span class="cov0" title="0">pm.providers = make(map[string]core.Provider)

        if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("关闭Provider时发生错误: %v", errs)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DefaultCachedProviderConfig 默认缓存Provider配置
func DefaultCachedProviderConfig() CachedProviderConfig <span class="cov6" title="2">{
        return CachedProviderConfig{
                CacheTTL:           5 * time.Minute,
                EnableMockFallback: true,
                MaxRetries:         3,
                RetryDelay:         1 * time.Second,
                TimeoutDuration:    10 * time.Second,
        }
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package providers

import (
        "context"
        "fmt"
        "math/rand"
        "sync"
        "sync/atomic"
        "time"

        "stocksub/pkg/subscriber"
        "stocksub/pkg/testkit/core"
)

// MockProvider 智能Mock Provider实现
type MockProvider struct {
        mu           sync.RWMutex
        scenarios    map[string]*core.MockScenario
        currentScene string
        recorder     *CallRecorder
        mockData     map[string][]subscriber.StockData
        enabled      bool
        config       MockProviderConfig
        stats        MockProviderStats
        generator    *DataGenerator
}

// MockProviderConfig Mock Provider配置
type MockProviderConfig struct {
        EnableRecording bool          `yaml:"enable_recording"` // 是否启用调用记录
        EnablePlayback  bool          `yaml:"enable_playback"`  // 是否启用回放
        DefaultDelay    time.Duration `yaml:"default_delay"`    // 默认延迟
        RandomDelay     bool          `yaml:"random_delay"`     // 是否使用随机延迟
        MaxRandomDelay  time.Duration `yaml:"max_random_delay"` // 最大随机延迟
        EnableDataGen   bool          `yaml:"enable_data_gen"`  // 是否启用数据生成
        DataGenConfig   DataGenConfig `yaml:"data_gen_config"`  // 数据生成配置
}

// MockProviderStats Mock Provider统计
type MockProviderStats struct {
        TotalCalls       int64         `json:"total_calls"`
        SuccessfulCalls  int64         `json:"successful_calls"`
        FailedCalls      int64         `json:"failed_calls"`
        AverageDelay     time.Duration `json:"average_delay"`
        LastCall         time.Time     `json:"last_call"`
        CurrentScenario  string        `json:"current_scenario"`
        RecordingEnabled bool          `json:"recording_enabled"`
        PlaybackEnabled  bool          `json:"playback_enabled"`
}

// CallRecorder 调用记录器
type CallRecorder struct {
        mu      sync.RWMutex
        calls   []CallRecord
        enabled bool
        maxSize int
}

// CallRecord 调用记录
type CallRecord struct {
        ID        string                 `json:"id"`
        Timestamp time.Time              `json:"timestamp"`
        Symbols   []string               `json:"symbols"`
        Response  []subscriber.StockData `json:"response"`
        Error     error                  `json:"error"`
        Duration  time.Duration          `json:"duration"`
        Scenario  string                 `json:"scenario"`
}

// NewMockProvider 创建Mock Provider
func NewMockProvider(config MockProviderConfig) *MockProvider <span class="cov9" title="9">{
        mp := &amp;MockProvider{
                scenarios: make(map[string]*core.MockScenario),
                mockData:  make(map[string][]subscriber.StockData),
                enabled:   true,
                config:    config,
                stats:     MockProviderStats{},
                generator: NewDataGenerator(config.DataGenConfig),
        }

        if config.EnableRecording </span><span class="cov9" title="9">{
                mp.recorder = NewCallRecorder(1000) // 默认记录1000条调用
        }</span>

        // 加载默认场景
        <span class="cov9" title="9">mp.loadDefaultScenarios()

        return mp</span>
}

// NewCallRecorder 创建调用记录器
func NewCallRecorder(maxSize int) *CallRecorder <span class="cov10" title="10">{
        return &amp;CallRecorder{
                calls:   make([]CallRecord, 0, maxSize),
                enabled: true,
                maxSize: maxSize,
        }
}</span>

// Name returns the name of the provider.
func (mp *MockProvider) Name() string <span class="cov0" title="0">{
        return "mock"
}</span>

// GetRateLimit returns the rate limit of the provider.
func (mp *MockProvider) GetRateLimit() time.Duration <span class="cov0" title="0">{
        return 200 * time.Millisecond // A sensible default
}</span>

// IsSymbolSupported checks if a symbol is supported by the mock provider.
func (mp *MockProvider) IsSymbolSupported(symbol string) bool <span class="cov0" title="0">{
        // In mock provider, we can assume all symbols are supported.
        return true
}</span>

// FetchData 获取股票数据
func (mp *MockProvider) FetchData(ctx context.Context, symbols []string) ([]subscriber.StockData, error) <span class="cov9" title="8">{
        startTime := time.Now()
        atomic.AddInt64(&amp;mp.stats.TotalCalls, 1)
        mp.stats.LastCall = startTime

        // 应用延迟
        if err := mp.applyDelay(); err != nil </span><span class="cov0" title="0">{
                atomic.AddInt64(&amp;mp.stats.FailedCalls, 1)
                return nil, err
        }</span>

        <span class="cov9" title="8">mp.mu.RLock()
        currentScene := mp.currentScene
        scenarios := mp.scenarios
        mp.mu.RUnlock()

        var result []subscriber.StockData
        var err error

        // 优先检查SetMockData提供的数据
        result, err = mp.getMockData(symbols)
        if err == nil &amp;&amp; len(result) &gt; 0 </span><span class="cov3" title="2">{
                // 如果getMockData成功返回了所有请求的symbol的数据，则直接返回
                if len(result) == len(symbols) </span><span class="cov3" title="2">{
                        goto end</span>
                }
        }

        // 如果mockData不完整或不存在，则检查场景
        <span class="cov8" title="6">if currentScene != "" &amp;&amp; scenarios[currentScene] != nil </span><span class="cov8" title="6">{
                result, err = mp.executeScenario(symbols, scenarios[currentScene])
        }</span> else<span class="cov0" title="0"> if mp.config.EnableDataGen </span><span class="cov0" title="0">{
                result, err = mp.generator.GenerateStockData(symbols)
        }</span> else<span class="cov0" title="0"> {
                // 如果mockData为空，且没有场景，且没有数据生成器，则返回错误
                if len(mp.mockData) == 0 </span><span class="cov0" title="0">{
                        err = fmt.Errorf("未配置Mock数据、场景或数据生成器")
                }</span>
        }

end:
        <span class="cov9" title="8">duration := time.Since(startTime)

        // 记录调用
        if mp.recorder != nil &amp;&amp; mp.recorder.enabled </span><span class="cov9" title="8">{
                mp.recorder.RecordCall(CallRecord{
                        ID:        fmt.Sprintf("call_%d", time.Now().UnixNano()),
                        Timestamp: startTime,
                        Symbols:   symbols,
                        Response:  result,
                        Error:     err,
                        Duration:  duration,
                        Scenario:  currentScene,
                })
        }</span>

        <span class="cov9" title="8">if err != nil </span><span class="cov1" title="1">{
                atomic.AddInt64(&amp;mp.stats.FailedCalls, 1)
                return nil, err
        }</span>

        <span class="cov8" title="7">atomic.AddInt64(&amp;mp.stats.SuccessfulCalls, 1)
        mp.updateAverageDelay(duration)

        return result, nil</span>
}

// SetMockMode 设置Mock模式
func (mp *MockProvider) SetMockMode(enabled bool) <span class="cov1" title="1">{
        mp.mu.Lock()
        defer mp.mu.Unlock()

        mp.enabled = enabled
}</span>

// SetMockData 设置Mock数据
func (mp *MockProvider) SetMockData(symbols []string, data []subscriber.StockData) <span class="cov3" title="2">{
        mp.mu.Lock()
        defer mp.mu.Unlock()

        for i, symbol := range symbols </span><span class="cov3" title="2">{
                if i &lt; len(data) </span><span class="cov3" title="2">{
                        mp.mockData[symbol] = []subscriber.StockData{data[i]}
                }</span>
        }
}

// SetScenario 设置当前场景
func (mp *MockProvider) SetScenario(scenarioName string) error <span class="cov6" title="4">{
        mp.mu.Lock()
        defer mp.mu.Unlock()

        if _, exists := mp.scenarios[scenarioName]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("场景 %s 不存在", scenarioName)
        }</span>

        <span class="cov6" title="4">mp.currentScene = scenarioName
        mp.stats.CurrentScenario = scenarioName
        return nil</span>
}

// AddScenario 添加场景
func (mp *MockProvider) AddScenario(scenario *core.MockScenario) <span class="cov1" title="1">{
        mp.mu.Lock()
        defer mp.mu.Unlock()

        mp.scenarios[scenario.Name] = scenario
}</span>

// RemoveScenario 移除场景
func (mp *MockProvider) RemoveScenario(scenarioName string) <span class="cov0" title="0">{
        mp.mu.Lock()
        defer mp.mu.Unlock()

        delete(mp.scenarios, scenarioName)
        if mp.currentScene == scenarioName </span><span class="cov0" title="0">{
                mp.currentScene = ""
        }</span>
}

// GetScenarios 获取所有场景
func (mp *MockProvider) GetScenarios() map[string]*core.MockScenario <span class="cov0" title="0">{
        mp.mu.RLock()
        defer mp.mu.RUnlock()

        result := make(map[string]*core.MockScenario)
        for name, scenario := range mp.scenarios </span><span class="cov0" title="0">{
                result[name] = scenario
        }</span>
        <span class="cov0" title="0">return result</span>
}

// Close 关闭Provider
func (mp *MockProvider) Close() error <span class="cov9" title="9">{
        mp.mu.Lock()
        defer mp.mu.Unlock()

        // 检查是否已经关闭
        if !mp.enabled </span><span class="cov0" title="0">{
                return fmt.Errorf("provider already closed")
        }</span>

        <span class="cov9" title="9">mp.enabled = false
        mp.scenarios = make(map[string]*core.MockScenario)
        mp.mockData = make(map[string][]subscriber.StockData)

        return nil</span>
}

// GetStats 获取统计信息
func (mp *MockProvider) GetStats() MockProviderStats <span class="cov3" title="2">{
        mp.mu.RLock()
        defer mp.mu.RUnlock()

        stats := mp.stats
        stats.RecordingEnabled = mp.recorder != nil &amp;&amp; mp.recorder.enabled
        stats.PlaybackEnabled = mp.config.EnablePlayback

        return stats
}</span>

// executeScenario 执行场景
func (mp *MockProvider) executeScenario(symbols []string, scenario *core.MockScenario) ([]subscriber.StockData, error) <span class="cov8" title="6">{
        // 检查场景是否有通配符错误定义
        if err, exists := scenario.Errors["*"]; exists &amp;&amp; err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // 检查场景是否有特定错误定义
        <span class="cov7" title="5">for _, symbol := range symbols </span><span class="cov8" title="6">{
                if err, exists := scenario.Errors[symbol]; exists &amp;&amp; err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // 应用场景延迟（支持通配符）
        <span class="cov7" title="5">if delay, exists := scenario.Delays["*"]; exists &amp;&amp; delay &gt; 0 </span><span class="cov1" title="1">{
                time.Sleep(delay)
        }</span> else<span class="cov6" title="4"> {
                for _, symbol := range symbols </span><span class="cov7" title="5">{
                        if delay, exists := scenario.Delays[symbol]; exists &amp;&amp; delay &gt; 0 </span><span class="cov1" title="1">{
                                time.Sleep(delay)
                        }</span>
                }
        }

        // 获取响应数据
        <span class="cov7" title="5">result := make([]subscriber.StockData, 0, len(symbols))
        for _, symbol := range symbols </span><span class="cov8" title="6">{
                if response, exists := scenario.Responses[symbol]; exists </span><span class="cov1" title="1">{
                        result = append(result, response.Data...)
                }</span> else<span class="cov7" title="5"> {
                        // 如果场景中没有该股票的数据，生成默认数据
                        if mp.config.EnableDataGen </span><span class="cov7" title="5">{
                                data, err := mp.generator.GenerateStockData([]string{symbol})
                                if err == nil &amp;&amp; len(data) &gt; 0 </span><span class="cov7" title="5">{
                                        result = append(result, data[0])
                                }</span>
                        }
                }
        }

        <span class="cov7" title="5">return result, nil</span>
}

// getMockData 获取Mock数据
func (mp *MockProvider) getMockData(symbols []string) ([]subscriber.StockData, error) <span class="cov9" title="8">{
        mp.mu.RLock()
        defer mp.mu.RUnlock()

        // 如果没有mock数据，直接返回空切片
        if len(mp.mockData) == 0 </span><span class="cov8" title="6">{
                return []subscriber.StockData{}, nil
        }</span>

        <span class="cov3" title="2">result := make([]subscriber.StockData, 0, len(symbols))

        for _, symbol := range symbols </span><span class="cov3" title="2">{
                if data, exists := mp.mockData[symbol]; exists &amp;&amp; len(data) &gt; 0 </span><span class="cov3" title="2">{
                        result = append(result, data[0])
                }</span>
        }

        // 只有当所有请求的symbols都在mockData中找到时，才认为成功
        <span class="cov3" title="2">if len(result) == len(symbols) </span><span class="cov3" title="2">{
                return result, nil
        }</span>

        // 如果mockData不完整，返回一个空切片，让上层逻辑继续处理
        <span class="cov0" title="0">return []subscriber.StockData{}, nil</span>
}

// applyDelay 应用延迟
func (mp *MockProvider) applyDelay() error <span class="cov9" title="8">{
        delay := mp.config.DefaultDelay

        if mp.config.RandomDelay &amp;&amp; mp.config.MaxRandomDelay &gt; 0 </span><span class="cov9" title="8">{
                randomDelay := time.Duration(rand.Int63n(int64(mp.config.MaxRandomDelay)))
                delay += randomDelay
        }</span>

        <span class="cov9" title="8">if delay &gt; 0 </span><span class="cov9" title="8">{
                time.Sleep(delay)
        }</span>

        <span class="cov9" title="8">return nil</span>
}

// updateAverageDelay 更新平均延迟
func (mp *MockProvider) updateAverageDelay(duration time.Duration) <span class="cov8" title="7">{
        // 简单的移动平均计算
        if mp.stats.AverageDelay == 0 </span><span class="cov8" title="7">{
                mp.stats.AverageDelay = duration
        }</span> else<span class="cov0" title="0"> {
                mp.stats.AverageDelay = (mp.stats.AverageDelay + duration) / 2
        }</span>
}

// loadDefaultScenarios 加载默认场景
func (mp *MockProvider) loadDefaultScenarios() <span class="cov9" title="9">{
        // 正常场景
        normalScenario := &amp;core.MockScenario{
                Name:        "normal",
                Description: "正常数据返回场景",
                Responses:   make(map[string]core.MockResponse),
                Delays:      make(map[string]time.Duration),
                Errors:      make(map[string]error),
        }

        // 错误场景
        errorScenario := &amp;core.MockScenario{
                Name:        "error",
                Description: "API错误场景",
                Responses:   make(map[string]core.MockResponse),
                Delays:      make(map[string]time.Duration),
                Errors: map[string]error{
                        "*": fmt.Errorf("API服务暂时不可用"),
                },
        }

        // 延迟场景
        slowScenario := &amp;core.MockScenario{
                Name:        "slow",
                Description: "高延迟场景",
                Responses:   make(map[string]core.MockResponse),
                Delays: map[string]time.Duration{
                        "*": 2 * time.Second,
                },
                Errors: make(map[string]error),
        }

        mp.scenarios["normal"] = normalScenario
        mp.scenarios["error"] = errorScenario
        mp.scenarios["slow"] = slowScenario

        // 设置默认场景
        mp.currentScene = "normal"
}</span>

// RecordCall 记录调用
func (cr *CallRecorder) RecordCall(record CallRecord) <span class="cov10" title="10">{
        cr.mu.Lock()
        defer cr.mu.Unlock()

        if !cr.enabled </span><span class="cov0" title="0">{
                return
        }</span>

        // 如果达到最大容量，移除最旧的记录
        <span class="cov10" title="10">if len(cr.calls) &gt;= cr.maxSize </span><span class="cov0" title="0">{
                cr.calls = cr.calls[1:]
        }</span>

        <span class="cov10" title="10">cr.calls = append(cr.calls, record)</span>
}

// GetCalls 获取所有调用记录
func (cr *CallRecorder) GetCalls() []CallRecord <span class="cov3" title="2">{
        cr.mu.RLock()
        defer cr.mu.RUnlock()

        result := make([]CallRecord, len(cr.calls))
        copy(result, cr.calls)
        return result
}</span>

// GetCallsBySymbol 获取指定股票的调用记录
func (cr *CallRecorder) GetCallsBySymbol(symbol string) []CallRecord <span class="cov1" title="1">{
        cr.mu.RLock()
        defer cr.mu.RUnlock()

        result := make([]CallRecord, 0)
        for _, call := range cr.calls </span><span class="cov3" title="2">{
                for _, s := range call.Symbols </span><span class="cov3" title="2">{
                        if s == symbol </span><span class="cov1" title="1">{
                                result = append(result, call)
                                break</span>
                        }
                }
        }
        <span class="cov1" title="1">return result</span>
}

// Clear 清空记录
func (cr *CallRecorder) Clear() <span class="cov1" title="1">{
        cr.mu.Lock()
        defer cr.mu.Unlock()

        cr.calls = cr.calls[:0]
}</span>

// Enable 启用记录
func (cr *CallRecorder) Enable() <span class="cov0" title="0">{
        cr.mu.Lock()
        defer cr.mu.Unlock()

        cr.enabled = true
}</span>

// Disable 禁用记录
func (cr *CallRecorder) Disable() <span class="cov0" title="0">{
        cr.mu.Lock()
        defer cr.mu.Unlock()

        cr.enabled = false
}</span>

// DataGenerator 数据生成器
type DataGenerator struct {
        config DataGenConfig
        rand   *rand.Rand
}

// DataGenConfig 数据生成配置
type DataGenConfig struct {
        PriceRange      PriceRange  `yaml:"price_range"`
        VolumnRange     VolumeRange `yaml:"volume_range"`
        ChangeRange     ChangeRange `yaml:"change_range"`
        RandomSeed      int64       `yaml:"random_seed"`
        EnableRealistic bool        `yaml:"enable_realistic"` // 是否生成现实的数据
        MarketHours     bool        `yaml:"market_hours"`     // 是否模拟市场时间
}

// PriceRange 价格范围
type PriceRange struct {
        Min float64 `yaml:"min"`
        Max float64 `yaml:"max"`
}

// VolumeRange 成交量范围
type VolumeRange struct {
        Min int64 `yaml:"min"`
        Max int64 `yaml:"max"`
}

// ChangeRange 涨跌幅范围
type ChangeRange struct {
        Min float64 `yaml:"min"`
        Max float64 `yaml:"max"`
}

// NewDataGenerator 创建数据生成器
func NewDataGenerator(config DataGenConfig) *DataGenerator <span class="cov9" title="9">{
        seed := config.RandomSeed
        if seed == 0 </span><span class="cov9" title="9">{
                seed = time.Now().UnixNano()
        }</span>

        <span class="cov9" title="9">return &amp;DataGenerator{
                config: config,
                rand:   rand.New(rand.NewSource(seed)),
        }</span>
}

// GenerateStockData 生成股票数据
func (dg *DataGenerator) GenerateStockData(symbols []string) ([]subscriber.StockData, error) <span class="cov7" title="5">{
        result := make([]subscriber.StockData, 0, len(symbols))

        for _, symbol := range symbols </span><span class="cov7" title="5">{
                data := dg.generateSingleStock(symbol)
                result = append(result, data)
        }</span>

        <span class="cov7" title="5">return result, nil</span>
}

// generateSingleStock 生成单个股票数据
func (dg *DataGenerator) generateSingleStock(symbol string) subscriber.StockData <span class="cov7" title="5">{
        // 生成基础价格
        price := dg.generatePrice()
        change := dg.generateChange()
        changePercent := (change / price) * 100

        // 生成其他字段
        volume := dg.generateVolume()

        return subscriber.StockData{
                Symbol:        symbol,
                Name:          dg.generateStockName(symbol),
                Price:         price,
                Change:        change,
                ChangePercent: changePercent,
                Volume:        volume,
                High:          price + dg.rand.Float64()*2,
                Low:           price - dg.rand.Float64()*2,
                Open:          price + (dg.rand.Float64()-0.5)*1,
                PrevClose:     price - change,
                Timestamp:     time.Now(),
        }
}</span>

// generatePrice 生成价格
func (dg *DataGenerator) generatePrice() float64 <span class="cov7" title="5">{
        min := dg.config.PriceRange.Min
        max := dg.config.PriceRange.Max

        if min == 0 &amp;&amp; max == 0 </span><span class="cov0" title="0">{
                min = 1.0
                max = 100.0
        }</span>

        <span class="cov7" title="5">return min + dg.rand.Float64()*(max-min)</span>
}

// generateChange 生成涨跌额
func (dg *DataGenerator) generateChange() float64 <span class="cov7" title="5">{
        min := dg.config.ChangeRange.Min
        max := dg.config.ChangeRange.Max

        if min == 0 &amp;&amp; max == 0 </span><span class="cov0" title="0">{
                min = -10.0
                max = 10.0
        }</span>

        <span class="cov7" title="5">return min + dg.rand.Float64()*(max-min)</span>
}

// generateVolume 生成成交量
func (dg *DataGenerator) generateVolume() int64 <span class="cov7" title="5">{
        min := dg.config.VolumnRange.Min
        max := dg.config.VolumnRange.Max

        if min == 0 &amp;&amp; max == 0 </span><span class="cov0" title="0">{
                min = 1000
                max = 1000000
        }</span>

        <span class="cov7" title="5">return min + dg.rand.Int63n(max-min)</span>
}

// generateStockName 生成股票名称
func (dg *DataGenerator) generateStockName(symbol string) string <span class="cov7" title="5">{
        // 简单的名称生成逻辑
        prefixes := []string{"测试", "模拟", "样本", "示例"}
        suffixes := []string{"科技", "控股", "实业", "集团", "股份"}

        prefix := prefixes[dg.rand.Intn(len(prefixes))]
        suffix := suffixes[dg.rand.Intn(len(suffixes))]

        return fmt.Sprintf("%s%s%s", prefix, symbol, suffix)
}</span>

// DefaultMockProviderConfig 默认Mock Provider配置
func DefaultMockProviderConfig() MockProviderConfig <span class="cov9" title="9">{
        return MockProviderConfig{
                EnableRecording: true,
                EnablePlayback:  false,
                DefaultDelay:    100 * time.Millisecond,
                RandomDelay:     true,
                MaxRandomDelay:  500 * time.Millisecond,
                EnableDataGen:   true,
                DataGenConfig: DataGenConfig{
                        PriceRange:      PriceRange{Min: 1.0, Max: 100.0},
                        VolumnRange:     VolumeRange{Min: 1000, Max: 1000000},
                        ChangeRange:     ChangeRange{Min: -10.0, Max: 10.0},
                        RandomSeed:      0,
                        EnableRealistic: true,
                        MarketHours:     false,
                },
        }
}</span>

// DefaultDataGenConfig 默认数据生成配置
func DefaultDataGenConfig() DataGenConfig <span class="cov0" title="0">{
        return DataGenConfig{
                PriceRange:      PriceRange{Min: 1.0, Max: 100.0},
                VolumnRange:     VolumeRange{Min: 1000, Max: 1000000},
                ChangeRange:     ChangeRange{Min: -10.0, Max: 10.0},
                RandomSeed:      0,
                EnableRealistic: true,
                MarketHours:     false,
        }
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">// Package storage
// 提供了 testkit 的存储层实现，包括CSV文件存储、内存存储和批量写入等功能。
package storage

import (
        "context"
        "fmt"
        "sync"
        "time"

        "stocksub/pkg/subscriber"
        "stocksub/pkg/testkit/core"
)

// BatchWriter 封装了底层存储，提供批量写入功能以提高性能。
// 它会将写入操作缓存起来，直到达到预设的批次大小或刷新间隔，再一次性写入。
type BatchWriter struct {
        storage     core.Storage
        buffer      []interface{}
        bufferMu    sync.Mutex
        flushTicker *time.Ticker
        stopChan    chan struct{}
        config      BatchWriterConfig
        stats       BatchWriterStats
        // StructuredData 优化相关字段
        structuredDataBuffer map[string][]*subscriber.StructuredData // 按 schema 名称分组的缓存
        lastSchemaFlush      map[string]time.Time                    // 每个 schema 的上次刷新时间
}

// BatchWriterConfig 定义了 BatchWriter 的配置选项。
type BatchWriterConfig struct {
        BatchSize                 int           `yaml:"batch_size"`                   // 触发批量写入的批次大小。
        FlushInterval             time.Duration `yaml:"flush_interval"`               // 定期将缓冲区数据写入存储的时间间隔。
        MaxBufferSize             int           `yaml:"max_buffer_size"`              // 缓冲区中可容纳的最大记录数，防止内存无限增长。
        EnableAsync               bool          `yaml:"enable_async"`                 // 是否启用异步写入。如果为true，批量写入将在独立的goroutine中执行。
        EnableStructuredDataOptim bool          `yaml:"enable_structured_data_optim"` // 是否启用 StructuredData 优化
        StructuredDataBatchSize   int           `yaml:"structured_data_batch_size"`   // StructuredData 的特别批次大小
        StructuredDataFlushDelay  time.Duration `yaml:"structured_data_flush_delay"`  // StructuredData 刷新延迟（用于合并同类型数据）
}

// BatchWriterStats 包含了 BatchWriter 的运行统计信息。
type BatchWriterStats struct {
        TotalBatches             int64     `json:"total_batches"`               // 已成功写入的总批次数。
        TotalRecords             int64     `json:"total_records"`               // 已成功写入的总记录数。
        BufferSize               int       `json:"buffer_size"`                 // 当前缓冲区中的记录数。
        LastFlush                time.Time `json:"last_flush"`                  // 最后一次成功刷新的时间。
        FlushErrors              int64     `json:"flush_errors"`                // 刷新（写入）失败的次数。
        BufferOverflows          int64     `json:"buffer_overflows"`            // 因缓冲区满而导致强制刷新的次数。
        StructuredDataBatches    int64     `json:"structured_data_batches"`     // StructuredData 的批次数
        StructuredDataRecords    int64     `json:"structured_data_records"`     // StructuredData 的记录数
        StructuredDataBufferSize int       `json:"structured_data_buffer_size"` // StructuredData 缓冲区大小
        StructuredDataFlushes    int64     `json:"structured_data_flushes"`     // StructuredData 专用刷新次数
}

// NewBatchWriter 创建一个新的 BatchWriter 实例。
func NewBatchWriter(storage core.Storage, config BatchWriterConfig) *BatchWriter <span class="cov0" title="0">{
        bw := &amp;BatchWriter{
                storage:              storage,
                buffer:               make([]interface{}, 0, config.BatchSize),
                stopChan:             make(chan struct{}),
                config:               config,
                stats:                BatchWriterStats{},
                structuredDataBuffer: make(map[string][]*subscriber.StructuredData),
                lastSchemaFlush:      make(map[string]time.Time),
        }

        if config.FlushInterval &gt; 0 </span><span class="cov0" title="0">{
                bw.flushTicker = time.NewTicker(config.FlushInterval)
                go bw.startPeriodicFlush()
        }</span>

        <span class="cov0" title="0">return bw</span>
}

// Write 将一条数据记录添加到写入缓冲区。
// 当缓冲区大小达到 BatchSize 时，它会触发一次批量写入操作。
func (bw *BatchWriter) Write(ctx context.Context, data interface{}) error <span class="cov0" title="0">{
        bw.bufferMu.Lock()
        defer bw.bufferMu.Unlock()

        // 对 StructuredData 进行特殊处理
        if bw.config.EnableStructuredDataOptim </span><span class="cov0" title="0">{
                if structData, ok := data.(*subscriber.StructuredData); ok </span><span class="cov0" title="0">{
                        return bw.writeStructuredData(ctx, structData)
                }</span>
        }

        // 常规数据处理
        <span class="cov0" title="0">return bw.writeRegularData(ctx, data)</span>
}

// writeStructuredData 将 StructuredData 添加到专用缓冲区
func (bw *BatchWriter) writeStructuredData(ctx context.Context, data *subscriber.StructuredData) error <span class="cov0" title="0">{
        if data.Schema == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("StructuredData 缺少 schema 定义")
        }</span>

        <span class="cov0" title="0">schemaName := data.Schema.Name
        if _, exists := bw.structuredDataBuffer[schemaName]; !exists </span><span class="cov0" title="0">{
                bw.structuredDataBuffer[schemaName] = make([]*subscriber.StructuredData, 0)
                bw.lastSchemaFlush[schemaName] = time.Now()
        }</span>

        <span class="cov0" title="0">bw.structuredDataBuffer[schemaName] = append(bw.structuredDataBuffer[schemaName], data)

        // 检查是否需要刷新该 schema 的数据
        schemaBuffer := bw.structuredDataBuffer[schemaName]
        if len(schemaBuffer) &gt;= bw.config.StructuredDataBatchSize </span><span class="cov0" title="0">{
                return bw.flushStructuredDataSchema(ctx, schemaName)
        }</span>

        // 检查延迟刷新
        <span class="cov0" title="0">if time.Since(bw.lastSchemaFlush[schemaName]) &gt; bw.config.StructuredDataFlushDelay </span><span class="cov0" title="0">{
                return bw.flushStructuredDataSchema(ctx, schemaName)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// writeRegularData 处理常规数据
func (bw *BatchWriter) writeRegularData(ctx context.Context, data interface{}) error <span class="cov0" title="0">{
        if len(bw.buffer) &gt;= bw.config.MaxBufferSize </span><span class="cov0" title="0">{
                bw.stats.BufferOverflows++
                if err := bw.flushBuffer(ctx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("强制刷新缓冲区失败: %w", err)
                }</span>
        }

        <span class="cov0" title="0">bw.buffer = append(bw.buffer, data)

        if len(bw.buffer) &gt;= bw.config.BatchSize </span><span class="cov0" title="0">{
                if bw.config.EnableAsync </span><span class="cov0" title="0">{
                        go bw.asyncFlush(context.Background()) // 使用后台context
                }</span> else<span class="cov0" title="0"> {
                        return bw.flushBuffer(ctx)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Flush 手动触发一次将缓冲区所有数据写入底层存储的操作。
func (bw *BatchWriter) Flush() error <span class="cov0" title="0">{
        bw.bufferMu.Lock()
        defer bw.bufferMu.Unlock()

        // 刷新常规数据
        if err := bw.flushBuffer(context.Background()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 刷新所有 StructuredData 数据
        <span class="cov0" title="0">if bw.config.EnableStructuredDataOptim </span><span class="cov0" title="0">{
                for schemaName := range bw.structuredDataBuffer </span><span class="cov0" title="0">{
                        if err := bw.flushStructuredDataSchema(context.Background(), schemaName); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// flushStructuredDataSchema 刷新指定 schema 的 StructuredData
func (bw *BatchWriter) flushStructuredDataSchema(ctx context.Context, schemaName string) error <span class="cov0" title="0">{
        schemaBuffer, exists := bw.structuredDataBuffer[schemaName]
        if !exists || len(schemaBuffer) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 复制数据并清空缓冲区
        <span class="cov0" title="0">dataToFlush := make([]*subscriber.StructuredData, len(schemaBuffer))
        copy(dataToFlush, schemaBuffer)
        bw.structuredDataBuffer[schemaName] = bw.structuredDataBuffer[schemaName][:0]
        bw.lastSchemaFlush[schemaName] = time.Now()

        // 转换为 interface{} 类型的切片
        interfaceData := make([]interface{}, len(dataToFlush))
        for i, data := range dataToFlush </span><span class="cov0" title="0">{
                interfaceData[i] = data
        }</span>

        // 尝试使用 BatchSave
        <span class="cov0" title="0">if batchSaver, ok := bw.storage.(interface {
                BatchSave(context.Context, []interface{}) error
        }); ok </span><span class="cov0" title="0">{
                if err := batchSaver.BatchSave(ctx, interfaceData); err != nil </span><span class="cov0" title="0">{
                        bw.stats.FlushErrors++
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                // 回退到逐个保存
                for _, data := range dataToFlush </span><span class="cov0" title="0">{
                        if err := bw.storage.Save(ctx, data); err != nil </span><span class="cov0" title="0">{
                                bw.stats.FlushErrors++
                                fmt.Printf("BatchWriter StructuredData save error: %v\n", err)
                        }</span>
                }
        }

        // 更新统计
        <span class="cov0" title="0">bw.stats.StructuredDataBatches++
        bw.stats.StructuredDataRecords += int64(len(dataToFlush))
        bw.stats.StructuredDataFlushes++
        bw.stats.TotalRecords += int64(len(dataToFlush))
        bw.stats.LastFlush = time.Now()

        return nil</span>
}

// flushBuffer 是实际的刷新操作实现（需要在锁内调用）。
func (bw *BatchWriter) flushBuffer(ctx context.Context) error <span class="cov0" title="0">{
        if len(bw.buffer) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">dataToFlush := make([]interface{}, len(bw.buffer))
        copy(dataToFlush, bw.buffer)
        bw.buffer = bw.buffer[:0]

        if batchSaver, ok := bw.storage.(interface {
                BatchSave(context.Context, []interface{}) error
        }); ok </span><span class="cov0" title="0">{
                if err := batchSaver.BatchSave(ctx, dataToFlush); err != nil </span><span class="cov0" title="0">{
                        bw.stats.FlushErrors++
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                for _, item := range dataToFlush </span><span class="cov0" title="0">{
                        if err := bw.storage.Save(ctx, item); err != nil </span><span class="cov0" title="0">{
                                bw.stats.FlushErrors++
                                fmt.Printf("BatchWriter fallback save error: %v\n", err)
                        }</span>
                }
        }

        <span class="cov0" title="0">bw.stats.TotalBatches++
        bw.stats.TotalRecords += int64(len(dataToFlush))
        bw.stats.LastFlush = time.Now()

        return nil</span>
}

// asyncFlush 异步执行刷新操作。
func (bw *BatchWriter) asyncFlush(ctx context.Context) <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                bw.bufferMu.Lock()
                defer bw.bufferMu.Unlock()
                bw.flushBuffer(ctx)
        }</span>()
}

// startPeriodicFlush 启动一个 goroutine，按固定的时间间隔刷新缓冲区。
func (bw *BatchWriter) startPeriodicFlush() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-bw.flushTicker.C:<span class="cov0" title="0">
                        bw.Flush()</span>
                case &lt;-bw.stopChan:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// Close 优雅地关闭 BatchWriter，它会先刷新所有剩余在缓冲区中的数据，然后停止后台任务。
func (bw *BatchWriter) Close() error <span class="cov0" title="0">{
        if bw.flushTicker != nil </span><span class="cov0" title="0">{
                bw.flushTicker.Stop()
        }</span>
        <span class="cov0" title="0">close(bw.stopChan)

        return bw.Flush()</span>
}

// GetStats 返回当前的运行统计信息。
func (bw *BatchWriter) GetStats() BatchWriterStats <span class="cov0" title="0">{
        bw.bufferMu.Lock()
        defer bw.bufferMu.Unlock()

        stats := bw.stats
        stats.BufferSize = len(bw.buffer)

        // 计算 StructuredData 缓冲区大小
        if bw.config.EnableStructuredDataOptim </span><span class="cov0" title="0">{
                structuredDataBufferSize := 0
                for _, schemaBuffer := range bw.structuredDataBuffer </span><span class="cov0" title="0">{
                        structuredDataBufferSize += len(schemaBuffer)
                }</span>
                <span class="cov0" title="0">stats.StructuredDataBufferSize = structuredDataBufferSize</span>
        }

        <span class="cov0" title="0">return stats</span>
}

// DefaultBatchWriterConfig 返回一个默认的 BatchWriter 配置实例。
func DefaultBatchWriterConfig() BatchWriterConfig <span class="cov0" title="0">{
        return BatchWriterConfig{
                BatchSize:                 100,
                FlushInterval:             5 * time.Second,
                MaxBufferSize:             1000,
                EnableAsync:               true,
                EnableStructuredDataOptim: true,
                StructuredDataBatchSize:   50,              // 更小的批次大小用于更频繁的刷新
                StructuredDataFlushDelay:  2 * time.Second, // 更短的延迟时间
        }
}</span>

// OptimizedBatchWriterConfig 返回一个针对 StructuredData 优化的配置
func OptimizedBatchWriterConfig() BatchWriterConfig <span class="cov0" title="0">{
        return BatchWriterConfig{
                BatchSize:                 200,
                FlushInterval:             3 * time.Second,
                MaxBufferSize:             2000,
                EnableAsync:               true,
                EnableStructuredDataOptim: true,
                StructuredDataBatchSize:   100,
                StructuredDataFlushDelay:  1 * time.Second,
        }
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package storage

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "stocksub/pkg/subscriber"
        "stocksub/pkg/testkit/core"
        "stocksub/pkg/testkit/helpers"
)

// CSVStorage 实现了 core.Storage 接口，提供了将测试数据以CSV格式持久化到磁盘的功能。
// 它支持按日期和类型自动分割文件，并利用资源池来提高性能。
type CSVStorage struct {
        config      CSVStorageConfig
        resourceMgr *helpers.ResourceManager
        fileMgr     *helpers.FileManager
        writerCache map[string]*helpers.CSVWriterWrapper
        mu          sync.RWMutex
        serializer  core.Serializer
        stats       CSVStorageStats
}

// CSVStorageConfig 定义了 CSVStorage 的所有可配置选项。
type CSVStorageConfig struct {
        Directory      string                 `yaml:"directory"`       // CSV文件的存储目录。
        FilePrefix     string                 `yaml:"file_prefix"`     // CSV文件名的前缀。
        DateFormat     string                 `yaml:"date_format"`     // 用于生成每日文件名的时间格式。
        MaxFileSize    int64                  `yaml:"max_file_size"`   // 单个CSV文件的最大大小（字节）。
        RotateInterval time.Duration          `yaml:"rotate_interval"` // 文件轮转的时间间隔。
        EnableCompress bool                   `yaml:"enable_compress"` // 是否对归档的CSV文件启用压缩。
        BatchSize      int                    `yaml:"batch_size"`      // 批量写入的批次大小。
        FlushInterval  time.Duration          `yaml:"flush_interval"`  // 定期将缓冲区数据刷新到磁盘的间隔。
        ResourceConfig helpers.ResourceConfig `yaml:"resource_config"` // 底层资源管理器（如缓冲区、写入器）的配置。
}

// CSVStorageStats 包含了 CSVStorage 的运行统计信息。
type CSVStorageStats struct {
        TotalRecords  int64                 `json:"total_records"`  // 已写入的总记录数。
        TotalFiles    int64                 `json:"total_files"`    // 当前管理的总文件数。
        TotalSize     int64                 `json:"total_size"`     // 所有文件的总大小（字节）。
        WriteErrors   int64                 `json:"write_errors"`   // 写入失败的次数。
        BatchWrites   int64                 `json:"batch_writes"`   // 完成的批量写入操作次数。
        ResourceStats helpers.ResourceStats `json:"resource_stats"` // 底层资源的统计信息。
        LastWrite     time.Time             `json:"last_write"`     // 最后一次写入操作的时间。
        LastFlush     time.Time             `json:"last_flush"`     // 最后一次刷新到磁盘的时间。
}

// NewCSVStorage 创建并返回一个新的 CSVStorage 实例。
func NewCSVStorage(config CSVStorageConfig) (*CSVStorage, error) <span class="cov4" title="7">{
        if err := os.MkdirAll(config.Directory, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("创建存储目录失败: %w", err)
        }</span>

        <span class="cov4" title="7">resourceMgr := helpers.NewResourceManager(config.ResourceConfig)
        fileMgr := helpers.NewFileManager(resourceMgr)

        storage := &amp;CSVStorage{
                config:      config,
                resourceMgr: resourceMgr,
                fileMgr:     fileMgr,
                writerCache: make(map[string]*helpers.CSVWriterWrapper),
                serializer:  NewJSONSerializer(),
                stats:       CSVStorageStats{},
        }

        if config.FlushInterval &gt; 0 </span><span class="cov2" title="2">{
                go storage.startPeriodicFlush()
        }</span>

        <span class="cov4" title="7">return storage, nil</span>
}

// Save 将一条数据记录保存到对应的CSV文件中。
func (cs *CSVStorage) Save(ctx context.Context, data interface{}) error <span class="cov3" title="5">{
        record, err := cs.convertToRecord(data)
        if err != nil </span><span class="cov0" title="0">{
                cs.stats.WriteErrors++
                return fmt.Errorf("数据转换失败: %w", err)
        }</span>

        <span class="cov3" title="5">writer, err := cs.getOrCreateWriter(record.Type, record.Date)
        if err != nil </span><span class="cov0" title="0">{
                cs.stats.WriteErrors++
                return fmt.Errorf("获取写入器失败: %w", err)
        }</span>

        // 对于 StructuredData，检查是否需要写入表头
        <span class="cov3" title="5">if strings.HasPrefix(record.Type, "structured_") </span><span class="cov2" title="3">{
                if sd, ok := data.(*subscriber.StructuredData); ok </span><span class="cov2" title="3">{
                        if err := cs.ensureStructuredDataHeader(writer, record.Type, record.Date, sd.Schema); err != nil </span><span class="cov0" title="0">{
                                cs.stats.WriteErrors++
                                return fmt.Errorf("写入StructuredData表头失败: %w", err)
                        }</span>
                }
        }

        <span class="cov3" title="5">if err := writer.Write(record.Fields); err != nil </span><span class="cov0" title="0">{
                cs.stats.WriteErrors++
                return fmt.Errorf("写入记录失败: %w", err)
        }</span>

        <span class="cov3" title="5">cs.stats.TotalRecords++
        cs.stats.LastWrite = time.Now()

        return nil</span>
}

// BatchSave 将多条数据记录批量保存到对应的CSV文件中，以提高性能。
func (cs *CSVStorage) BatchSave(ctx context.Context, dataList []interface{}) error <span class="cov2" title="2">{
        if len(dataList) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov2" title="2">groups := make(map[string][][]string)
        structuredDataSchemas := make(map[string]*subscriber.DataSchema) // 存储每个组的schema

        for _, data := range dataList </span><span class="cov5" title="13">{
                record, err := cs.convertToRecord(data)
                if err != nil </span><span class="cov0" title="0">{
                        cs.stats.WriteErrors++
                        continue</span>
                }

                <span class="cov5" title="13">key := fmt.Sprintf("%s_%s", record.Type, record.Date)
                groups[key] = append(groups[key], record.Fields)

                // 如果是 StructuredData，保存其 schema
                if strings.HasPrefix(record.Type, "structured_") </span><span class="cov2" title="3">{
                        if sd, ok := data.(*subscriber.StructuredData); ok </span><span class="cov2" title="3">{
                                structuredDataSchemas[key] = sd.Schema
                        }</span>
                }
        }

        <span class="cov2" title="2">for key, records := range groups </span><span class="cov2" title="2">{
                // 找到最后一个下划线，分割记录类型和日期
                lastUnderscoreIndex := strings.LastIndex(key, "_")
                if lastUnderscoreIndex == -1 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov2" title="2">recordType := key[:lastUnderscoreIndex]
                date := key[lastUnderscoreIndex+1:]

                writer, err := cs.getOrCreateWriter(recordType, date)
                if err != nil </span><span class="cov0" title="0">{
                        cs.stats.WriteErrors++
                        continue</span>
                }

                // 对于 StructuredData，确保表头已写入
                <span class="cov2" title="2">if strings.HasPrefix(recordType, "structured_") </span><span class="cov1" title="1">{
                        if schema, exists := structuredDataSchemas[key]; exists </span><span class="cov1" title="1">{
                                if err := cs.ensureStructuredDataHeader(writer, recordType, date, schema); err != nil </span><span class="cov0" title="0">{
                                        cs.stats.WriteErrors++
                                        continue</span>
                                }
                        }
                }

                <span class="cov2" title="2">if err := writer.WriteAll(records); err != nil </span><span class="cov0" title="0">{
                        cs.stats.WriteErrors++
                        continue</span>
                }

                <span class="cov2" title="2">cs.stats.TotalRecords += int64(len(records))</span>
        }

        <span class="cov2" title="2">cs.stats.BatchWrites++
        cs.stats.LastWrite = time.Now()

        return nil</span>
}

// Load 根据查询条件从CSV文件加载数据。注意：此功能当前尚未实现。
func (cs *CSVStorage) Load(ctx context.Context, query core.Query) ([]interface{}, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("CSV加载功能待实现")
}</span>

// Delete 根据查询条件删除CSV文件中的数据。注意：此功能当前尚未实现。
func (cs *CSVStorage) Delete(ctx context.Context, query core.Query) error <span class="cov0" title="0">{
        return fmt.Errorf("CSV删除功能待实现")
}</span>

// Close 关闭所有打开的CSV文件和写入器，并释放相关资源。
func (cs *CSVStorage) Close() error <span class="cov4" title="7">{
        cs.mu.Lock()
        defer cs.mu.Unlock()

        for _, writer := range cs.writerCache </span><span class="cov4" title="7">{
                writer.Close()
        }</span>
        <span class="cov4" title="7">cs.writerCache = make(map[string]*helpers.CSVWriterWrapper)

        cs.fileMgr.CloseAll()

        return cs.resourceMgr.Close()</span>
}

// Flush 将所有内部缓冲区的数据刷新到底层的CSV文件。
func (cs *CSVStorage) Flush() error <span class="cov3" title="6">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()

        for _, writer := range cs.writerCache </span><span class="cov3" title="6">{
                if err := writer.Flush(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov3" title="6">cs.stats.LastFlush = time.Now()
        return nil</span>
}

// GetStats 返回当前存储实例的运行统计信息。
func (cs *CSVStorage) GetStats() CSVStorageStats <span class="cov2" title="2">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()

        stats := cs.stats
        stats.ResourceStats = cs.resourceMgr.GetStats()
        stats.TotalFiles = int64(len(cs.writerCache))

        return stats
}</span>

// convertToRecord 将任意数据转换为内部的 core.Record 格式，以便于存储。
func (cs *CSVStorage) convertToRecord(data interface{}) (*core.Record, error) <span class="cov5" title="18">{
        record := &amp;core.Record{
                Timestamp: time.Now(),
                Date:      time.Now().Format(cs.config.DateFormat),
                Data:      data,
        }

        switch v := data.(type) </span>{
        case *subscriber.StructuredData:<span class="cov3" title="6">
                // 处理 StructuredData 类型
                record.Type = "structured_" + v.Schema.Name
                record.Timestamp = v.Timestamp
                record.Date = v.Timestamp.Format(cs.config.DateFormat)

                // 从 StructuredData 中获取 symbol
                if symbolValue, err := v.GetField("symbol"); err == nil &amp;&amp; symbolValue != nil </span><span class="cov3" title="6">{
                        if symbol, ok := symbolValue.(string); ok </span><span class="cov3" title="6">{
                                record.Symbol = symbol
                        }</span>
                }

                // 直接生成CSV字段，不使用StructuredDataSerializer
                <span class="cov3" title="6">fields := cs.generateStructuredDataCSVRecord(v)
                record.Fields = fields
                return record, nil</span>

        case subscriber.StockData:<span class="cov5" title="12">
                record.Type = "stock_data"
                record.Symbol = v.Symbol
                record.Timestamp = v.Timestamp
                record.Date = v.Timestamp.Format(cs.config.DateFormat)</span>
        case map[string]interface{}:<span class="cov0" title="0">
                if recordType, ok := v["type"].(string); ok </span><span class="cov0" title="0">{
                        record.Type = recordType
                }</span> else<span class="cov0" title="0"> {
                        record.Type = "generic"
                }</span>
                <span class="cov0" title="0">if symbol, ok := v["symbol"].(string); ok </span><span class="cov0" title="0">{
                        record.Symbol = symbol
                }</span>
        default:<span class="cov0" title="0">
                record.Type = "unknown"
                record.Symbol = ""</span>
        }

        <span class="cov5" title="12">jsonData, err := cs.serializer.Serialize(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="12">record.Fields = []string{
                record.Timestamp.Format(time.RFC3339),
                record.Type,
                record.Symbol,
                string(jsonData),
        }

        return record, nil</span>
}

// getOrCreateWriter 根据记录类型和日期获取或创建一个新的CSV写入器。
func (cs *CSVStorage) getOrCreateWriter(recordType, date string) (*helpers.CSVWriterWrapper, error) <span class="cov4" title="7">{
        key := fmt.Sprintf("%s_%s", recordType, date)

        cs.mu.RLock()
        if writer, exists := cs.writerCache[key]; exists </span><span class="cov0" title="0">{
                cs.mu.RUnlock()
                return writer, nil
        }</span>
        <span class="cov4" title="7">cs.mu.RUnlock()

        cs.mu.Lock()
        defer cs.mu.Unlock()

        if writer, exists := cs.writerCache[key]; exists </span><span class="cov0" title="0">{
                return writer, nil
        }</span>

        <span class="cov4" title="7">filename := fmt.Sprintf("%s_%s_%s.csv", cs.config.FilePrefix, recordType, date)
        filepath := filepath.Join(cs.config.Directory, filename)

        file, err := cs.fileMgr.OpenFile(filepath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("打开文件失败: %w", err)
        }</span>

        <span class="cov4" title="7">writer := helpers.NewCSVWriterWrapper(file, cs.resourceMgr)

        if stat, err := file.Stat(); err == nil &amp;&amp; stat.Size() == 0 </span><span class="cov4" title="7">{
                // 检查是否是 StructuredData 类型，需要特殊处理表头
                if strings.HasPrefix(recordType, "structured_") </span>{<span class="cov3" title="4">
                        // 对于 StructuredData，表头将在第一次写入数据时处理
                        // 这里不写入表头，因为我们需要 schema 信息
                }</span> else<span class="cov2" title="3"> {
                        headers := cs.getCSVHeaders(recordType)
                        if len(headers) &gt; 0 </span><span class="cov2" title="3">{
                                if err := writer.Write(headers); err != nil </span><span class="cov0" title="0">{
                                        writer.Close()
                                        return nil, fmt.Errorf("写入头部失败: %w", err)
                                }</span>
                        }
                }
        }

        <span class="cov4" title="7">cs.writerCache[key] = writer
        return writer, nil</span>
}

// getCSVHeaders 返回所有CSV文件统一使用的表头。
func (cs *CSVStorage) getCSVHeaders(recordType string) []string <span class="cov2" title="3">{
        // 检查是否是 StructuredData 类型
        if strings.HasPrefix(recordType, "structured_") </span><span class="cov0" title="0">{
                // 对于 StructuredData，返回空切片，因为表头会在 writeStructuredDataHeader 中处理
                return []string{}
        }</span>
        <span class="cov2" title="3">return []string{"timestamp", "type", "symbol", "data"}</span>
}

// startPeriodicFlush 启动一个后台goroutine，按固定间隔自动刷新缓冲区。
func (cs *CSVStorage) startPeriodicFlush() <span class="cov2" title="2">{
        ticker := time.NewTicker(cs.config.FlushInterval)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov1" title="1">{
                cs.Flush()
        }</span>
}

// JSONSerializer 实现了 core.Serializer 接口，使用JSON进行序列化和反序列化。
type JSONSerializer struct{}

// NewJSONSerializer 创建一个新的 JSONSerializer 实例。
func NewJSONSerializer() *JSONSerializer <span class="cov4" title="7">{
        return &amp;JSONSerializer{}
}</span>

// Serialize 将任意对象序列化为JSON字节数组。
func (js *JSONSerializer) Serialize(data interface{}) ([]byte, error) <span class="cov5" title="12">{
        return json.Marshal(data)
}</span>

// Deserialize 将JSON字节数组反序列化到 target 对象中。
func (js *JSONSerializer) Deserialize(data []byte, target interface{}) error <span class="cov0" title="0">{
        return json.Unmarshal(data, target)
}</span>

// MimeType 返回 "application/json"。
func (js *JSONSerializer) MimeType() string <span class="cov0" title="0">{
        return "application/json"
}</span>

// DefaultCSVStorageConfig 返回一个默认的CSVStorage配置实例。
func DefaultCSVStorageConfig() CSVStorageConfig <span class="cov0" title="0">{
        return CSVStorageConfig{
                Directory:      "./testdata",
                FilePrefix:     "stocksub",
                DateFormat:     "2006-01-02",
                MaxFileSize:    100 * 1024 * 1024, // 100MB
                RotateInterval: 24 * time.Hour,
                EnableCompress: false,
                BatchSize:      100,
                FlushInterval:  10 * time.Second,
                ResourceConfig: helpers.DefaultResourceConfig(),
        }
}</span>

// getStructuredDataCSVHeaders 生成带描述的 StructuredData CSV 表头
func (cs *CSVStorage) getStructuredDataCSVHeaders(schema *subscriber.DataSchema) []string <span class="cov3" title="5">{
        headers := make([]string, len(schema.FieldOrder))

        for i, fieldName := range schema.FieldOrder </span><span class="cov9" title="215">{
                fieldDef, exists := schema.Fields[fieldName]
                if !exists </span><span class="cov0" title="0">{
                        headers[i] = fieldName
                        continue</span>
                }

                // 格式：中文描述(英文字段名)
                <span class="cov9" title="215">if fieldDef.Description != "" </span><span class="cov9" title="215">{
                        headers[i] = fmt.Sprintf("%s(%s)", fieldDef.Description, fieldName)
                }</span> else<span class="cov0" title="0"> {
                        headers[i] = fieldName
                }</span>
        }

        <span class="cov3" title="5">return headers</span>
}

// writeStructuredDataHeader 写入 StructuredData 的 CSV 表头
func (cs *CSVStorage) writeStructuredDataHeader(writer *helpers.CSVWriterWrapper, schema *subscriber.DataSchema) error <span class="cov3" title="4">{
        headers := cs.getStructuredDataCSVHeaders(schema)
        return writer.Write(headers)
}</span>

// ensureStructuredDataHeader 确保 StructuredData 文件有正确的表头
func (cs *CSVStorage) ensureStructuredDataHeader(writer *helpers.CSVWriterWrapper, recordType, date string, schema *subscriber.DataSchema) error <span class="cov3" title="4">{
        // 检查文件是否为空（需要写入表头）
        filename := fmt.Sprintf("%s_%s_%s.csv", cs.config.FilePrefix, recordType, date)
        filepath := filepath.Join(cs.config.Directory, filename)

        if stat, err := os.Stat(filepath); err == nil &amp;&amp; stat.Size() == 0 </span><span class="cov3" title="4">{
                // 文件为空，需要写入表头
                return cs.writeStructuredDataHeader(writer, schema)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// generateStructuredDataCSVRecord 生成 StructuredData 的 CSV 数据行
func (cs *CSVStorage) generateStructuredDataCSVRecord(sd *subscriber.StructuredData) []string <span class="cov3" title="6">{
        record := make([]string, len(sd.Schema.FieldOrder))

        // 设置上海时区
        shanghaiTZ, err := time.LoadLocation("Asia/Shanghai")
        if err != nil </span><span class="cov0" title="0">{
                // 如果加载失败，使用 UTC+8
                shanghaiTZ = time.FixedZone("CST", 8*3600)
        }</span>

        <span class="cov3" title="6">for i, fieldName := range sd.Schema.FieldOrder </span><span class="cov10" title="258">{
                value, err := sd.GetField(fieldName)
                if err != nil || value == nil </span><span class="cov9" title="231">{
                        record[i] = ""
                        continue</span>
                }

                <span class="cov6" title="27">fieldDef := sd.Schema.Fields[fieldName]
                record[i] = cs.formatStructuredDataValue(value, fieldDef.Type, shanghaiTZ)</span>
        }

        <span class="cov3" title="6">return record</span>
}

// formatStructuredDataValue 格式化 StructuredData 字段值
func (cs *CSVStorage) formatStructuredDataValue(value interface{}, fieldType subscriber.FieldType, timezone *time.Location) string <span class="cov6" title="27">{
        if value == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov6" title="27">switch fieldType </span>{
        case subscriber.FieldTypeString:<span class="cov5" title="12">
                if str, ok := value.(string); ok </span><span class="cov5" title="12">{
                        return str
                }</span>
        case subscriber.FieldTypeInt:<span class="cov1" title="1">
                switch v := value.(type) </span>{
                case int:<span class="cov0" title="0">
                        return fmt.Sprintf("%d", v)</span>
                case int32:<span class="cov0" title="0">
                        return fmt.Sprintf("%d", v)</span>
                case int64:<span class="cov1" title="1">
                        return fmt.Sprintf("%d", v)</span>
                }
        case subscriber.FieldTypeFloat64:<span class="cov4" title="8">
                switch v := value.(type) </span>{
                case float32:<span class="cov0" title="0">
                        return fmt.Sprintf("%.2f", v)</span>
                case float64:<span class="cov4" title="8">
                        return fmt.Sprintf("%.2f", v)</span>
                }
        case subscriber.FieldTypeBool:<span class="cov0" title="0">
                if b, ok := value.(bool); ok </span><span class="cov0" title="0">{
                        if b </span><span class="cov0" title="0">{
                                return "true"
                        }</span>
                        <span class="cov0" title="0">return "false"</span>
                }
        case subscriber.FieldTypeTime:<span class="cov3" title="6">
                if t, ok := value.(time.Time); ok </span><span class="cov3" title="6">{
                        // 使用上海时区格式化时间：YYYY-MM-DD HH:mm:ss
                        return t.In(timezone).Format("2006-01-02 15:04:05")
                }</span>
        }

        <span class="cov0" title="0">return fmt.Sprintf("%v", value)</span>
}

// 确保 CSVStorage 实现了 core.Storage 接口。
var _ core.Storage = (*CSVStorage)(nil)
</pre>
		
		<pre class="file" id="file25" style="display: none">// Package storage 提供了 testkit 的存储层实现，包括CSV文件存储、内存存储和批量写入等功能。
package storage

import (
        "context"
        "fmt"
        "strings"
        "sync"
        "time"

        "stocksub/pkg/subscriber"
        "stocksub/pkg/testkit/core"
)

// MemoryStorage 是一种完全在内存中实现的 core.Storage 接口。
// 它用于快速、无I/O的测试，所有数据在程序结束时会丢失。
type MemoryStorage struct {
        data    map[string][]interface{}
        mu      sync.RWMutex
        indexes map[string]*MemoryIndex
        config  MemoryStorageConfig
        stats   MemoryStorageStats
}

// MemoryStorageConfig 定义了 MemoryStorage 的配置选项。
type MemoryStorageConfig struct {
        MaxRecords      int           `yaml:"max_records"`      // 每个"表"中存储的最大记录数。
        EnableIndex     bool          `yaml:"enable_index"`     // 是否为数据启用索引以加速查询。
        TTL             time.Duration `yaml:"ttl"`              // 记录的生存时间。
        CleanupInterval time.Duration `yaml:"cleanup_interval"` // 清理过期记录的后台任务运行间隔。
}

// MemoryStorageStats 包含了 MemoryStorage 的运行统计信息。
type MemoryStorageStats struct {
        TotalRecords int64     `json:"total_records"` // 存储的总记录数。
        TotalTables  int       `json:"total_tables"`  // 内部"表"的数量。
        IndexCount   int       `json:"index_count"`   // 创建的索引数量。
        LastCleanup  time.Time `json:"last_cleanup"`  // 最后一次清理的时间。
}

// MemoryIndex 为内存中的数据表提供索引功能。
type MemoryIndex struct {
        fieldIndex map[string][]int // 字段值到记录索引的映射
        timeIndex  []TimeRecord     // 时间索引
        mu         sync.RWMutex
}

// TimeRecord 是用于时间索引的内部结构。
type TimeRecord struct {
        Index     int
        Timestamp time.Time
}

// NewMemoryStorage 创建一个新的 MemoryStorage 实例。
func NewMemoryStorage(config MemoryStorageConfig) *MemoryStorage <span class="cov4" title="10">{
        ms := &amp;MemoryStorage{
                data:    make(map[string][]interface{}),
                indexes: make(map[string]*MemoryIndex),
                config:  config,
                stats:   MemoryStorageStats{},
        }

        if config.CleanupInterval &gt; 0 </span><span class="cov4" title="9">{
                go ms.startPeriodicCleanup()
        }</span>

        <span class="cov4" title="10">return ms</span>
}

// Save 将数据保存到内存中。
func (ms *MemoryStorage) Save(ctx context.Context, data interface{}) error <span class="cov6" title="30">{
        ms.mu.Lock()
        defer ms.mu.Unlock()

        tableName := ms.getTableName(data)

        if len(ms.data[tableName]) &gt;= ms.config.MaxRecords </span><span class="cov3" title="6">{
                ms.data[tableName] = ms.data[tableName][1:]
        }</span>

        <span class="cov6" title="30">index := len(ms.data[tableName])
        ms.data[tableName] = append(ms.data[tableName], data)

        if ms.config.EnableIndex </span><span class="cov6" title="30">{
                ms.updateIndex(tableName, data, index)
        }</span>

        <span class="cov6" title="30">ms.stats.TotalRecords++
        return nil</span>
}

// Load 从内存中加载数据。
func (ms *MemoryStorage) Load(ctx context.Context, query core.Query) ([]interface{}, error) <span class="cov4" title="14">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()

        results := make([]interface{}, 0)

        for _, records := range ms.data </span><span class="cov5" title="18">{
                for _, record := range records </span><span class="cov6" title="35">{
                        if ms.matchesQuery(record, query) </span><span class="cov5" title="23">{
                                results = append(results, record)

                                if query.Limit &gt; 0 &amp;&amp; len(results) &gt;= query.Limit </span><span class="cov0" title="0">{
                                        return results, nil
                                }</span>
                        }
                }
        }

        <span class="cov4" title="14">return results, nil</span>
}

// Delete 从内存中删除数据。
func (ms *MemoryStorage) Delete(ctx context.Context, query core.Query) error <span class="cov0" title="0">{
        ms.mu.Lock()
        defer ms.mu.Unlock()

        for tableName, records := range ms.data </span><span class="cov0" title="0">{
                newRecords := make([]interface{}, 0, len(records))

                for _, record := range records </span><span class="cov0" title="0">{
                        if !ms.matchesQuery(record, query) </span><span class="cov0" title="0">{
                                newRecords = append(newRecords, record)
                        }</span>
                }

                <span class="cov0" title="0">ms.data[tableName] = newRecords</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Close 清空所有内存数据。
func (ms *MemoryStorage) Close() error <span class="cov4" title="10">{
        ms.mu.Lock()
        defer ms.mu.Unlock()

        ms.data = make(map[string][]interface{})
        ms.indexes = make(map[string]*MemoryIndex)

        return nil
}</span>

// BatchSave 批量保存数据到内存中（支持 StructuredData 优化）
func (ms *MemoryStorage) BatchSave(ctx context.Context, dataList []interface{}) error <span class="cov1" title="1">{
        if len(dataList) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="1">ms.mu.Lock()
        defer ms.mu.Unlock()

        // 按表名分组数据
        tableGroups := make(map[string][]interface{})
        for _, data := range dataList </span><span class="cov2" title="3">{
                tableName := ms.getTableName(data)
                tableGroups[tableName] = append(tableGroups[tableName], data)
        }</span>

        // 为每个表批量处理数据
        <span class="cov1" title="1">for tableName, tableData := range tableGroups </span><span class="cov1" title="1">{
                if err := ms.batchSaveToTable(tableName, tableData); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("batch save to table %s failed: %w", tableName, err)
                }</span>
        }

        <span class="cov1" title="1">ms.stats.TotalRecords += int64(len(dataList))
        return nil</span>
}

// batchSaveToTable 批量保存数据到指定表中
func (ms *MemoryStorage) batchSaveToTable(tableName string, tableData []interface{}) error <span class="cov1" title="1">{
        // 确保表存在
        if _, exists := ms.data[tableName]; !exists </span><span class="cov1" title="1">{
                ms.data[tableName] = make([]interface{}, 0)
        }</span>

        // 检查容量限制
        <span class="cov1" title="1">currentSize := len(ms.data[tableName])
        newDataSize := len(tableData)
        totalSize := currentSize + newDataSize

        // 如果总大小超过限制，移除旧数据
        if totalSize &gt; ms.config.MaxRecords </span><span class="cov0" title="0">{
                excessCount := totalSize - ms.config.MaxRecords
                if excessCount &gt;= currentSize </span><span class="cov0" title="0">{
                        // 新数据太多，只保留最新的
                        ms.data[tableName] = ms.data[tableName][:0]
                        keepCount := ms.config.MaxRecords
                        if keepCount &gt; newDataSize </span><span class="cov0" title="0">{
                                keepCount = newDataSize
                        }</span>
                        <span class="cov0" title="0">tableData = tableData[newDataSize-keepCount:]</span>
                } else<span class="cov0" title="0"> {
                        // 移除一些旧数据
                        ms.data[tableName] = ms.data[tableName][excessCount:]
                }</span>
        }

        // 批量添加数据并建立索引
        <span class="cov1" title="1">startIndex := len(ms.data[tableName])
        ms.data[tableName] = append(ms.data[tableName], tableData...)

        // 为新添加的数据建立索引
        if ms.config.EnableIndex </span><span class="cov1" title="1">{
                for i, data := range tableData </span><span class="cov2" title="3">{
                        ms.updateIndex(tableName, data, startIndex+i)
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

func (ms *MemoryStorage) getTableName(data interface{}) string <span class="cov6" title="33">{
        switch d := data.(type) </span>{
        case *subscriber.StructuredData:<span class="cov5" title="26">
                // 对于 StructuredData，使用 schema 名称作为表名
                if d.Schema != nil </span><span class="cov5" title="26">{
                        return fmt.Sprintf("table_structured_%s", d.Schema.Name)
                }</span>
                <span class="cov0" title="0">return "table_structured_unknown"</span>
        case map[string]interface{}:<span class="cov1" title="1">
                if m, ok := data.(map[string]interface{}); ok </span><span class="cov1" title="1">{
                        if t, exists := m["type"]; exists </span><span class="cov1" title="1">{
                                return fmt.Sprintf("table_%v", t)
                        }</span>
                }
                <span class="cov0" title="0">return "table_generic"</span>
        default:<span class="cov3" title="6">
                return fmt.Sprintf("table_%T", data)</span>
        }
}

func (ms *MemoryStorage) matchesQuery(record interface{}, query core.Query) bool <span class="cov6" title="35">{
        // 如果是 StructuredData，使用专门的查询逻辑
        if structData, ok := record.(*subscriber.StructuredData); ok </span><span class="cov5" title="27">{
                return ms.queryStructuredData(structData, query)
        }</span>

        // 对于其他类型，返回 true（保持原有行为）
        <span class="cov4" title="8">return true</span>
}

func (ms *MemoryStorage) updateIndex(tableName string, data interface{}, index int) <span class="cov6" title="33">{
        if _, exists := ms.indexes[tableName]; !exists </span><span class="cov4" title="12">{
                ms.indexes[tableName] = &amp;MemoryIndex{
                        fieldIndex: make(map[string][]int),
                        timeIndex:  make([]TimeRecord, 0),
                }
        }</span>

        <span class="cov6" title="33">idx := ms.indexes[tableName]

        // 处理 StructuredData 的特殊索引
        if structData, ok := data.(*subscriber.StructuredData); ok </span><span class="cov5" title="26">{
                ms.indexStructuredData(idx, structData, index)
                // 使用 StructuredData 的时间戳
                idx.timeIndex = append(idx.timeIndex, TimeRecord{
                        Index:     index,
                        Timestamp: structData.Timestamp,
                })
        }</span> else<span class="cov3" title="7"> {
                // 为非 StructuredData 使用当前时间
                idx.timeIndex = append(idx.timeIndex, TimeRecord{
                        Index:     index,
                        Timestamp: time.Now(),
                })
        }</span>
}

func (ms *MemoryStorage) startPeriodicCleanup() <span class="cov4" title="9">{
        ticker := time.NewTicker(ms.config.CleanupInterval)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov5" title="15">{
                ms.cleanup()
        }</span>
}

func (ms *MemoryStorage) cleanup() <span class="cov5" title="15">{
        if ms.config.TTL &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov5" title="15">ms.mu.Lock()
        defer ms.mu.Unlock()

        cutoff := time.Now().Add(-ms.config.TTL)

        for tableName, index := range ms.indexes </span><span class="cov4" title="14">{
                if index == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov4" title="14">validRecords := make([]TimeRecord, 0)
                invalidIndexes := make(map[int]bool)

                for _, timeRecord := range index.timeIndex </span><span class="cov4" title="10">{
                        if timeRecord.Timestamp.After(cutoff) </span><span class="cov4" title="9">{
                                validRecords = append(validRecords, timeRecord)
                        }</span> else<span class="cov1" title="1"> {
                                invalidIndexes[timeRecord.Index] = true
                        }</span>
                }

                <span class="cov4" title="14">index.timeIndex = validRecords

                if records, exists := ms.data[tableName]; exists </span><span class="cov4" title="14">{
                        validData := make([]interface{}, 0)
                        for i, record := range records </span><span class="cov4" title="10">{
                                if !invalidIndexes[i] </span><span class="cov4" title="9">{
                                        validData = append(validData, record)
                                }</span>
                        }
                        <span class="cov4" title="14">ms.data[tableName] = validData</span>
                }
        }

        <span class="cov5" title="15">ms.stats.LastCleanup = time.Now()</span>
}

// DefaultMemoryStorageConfig 返回一个默认的 MemoryStorage 配置实例。
func DefaultMemoryStorageConfig() MemoryStorageConfig <span class="cov3" title="7">{
        return MemoryStorageConfig{
                MaxRecords:      10000,
                EnableIndex:     true,
                TTL:             24 * time.Hour,
                CleanupInterval: 1 * time.Hour,
        }
}</span>

// 确保 MemoryStorage 实现了 core.Storage 接口。
var _ core.Storage = (*MemoryStorage)(nil)

// indexStructuredData 为 StructuredData 建立字段索引
func (ms *MemoryStorage) indexStructuredData(index *MemoryIndex, data *subscriber.StructuredData, recordIndex int) <span class="cov5" title="26">{
        index.mu.Lock()
        defer index.mu.Unlock()

        // 为每个字段值建立索引
        for fieldName, value := range data.Values </span><span class="cov7" title="104">{
                if value == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // 生成索引键：字段名:值
                <span class="cov7" title="104">indexKey := fmt.Sprintf("%s:%v", fieldName, value)
                if _, exists := index.fieldIndex[indexKey]; !exists </span><span class="cov7" title="103">{
                        index.fieldIndex[indexKey] = make([]int, 0)
                }</span>
                <span class="cov7" title="104">index.fieldIndex[indexKey] = append(index.fieldIndex[indexKey], recordIndex)

                // 为字符串类型建立前缀索引
                if strValue, ok := value.(string); ok </span><span class="cov6" title="52">{
                        // 建立前缀索引
                        for i := 1; i &lt;= len(strValue) &amp;&amp; i &lt;= 10; i++ </span><span class="cov10" title="413">{ // 限制前缀长度
                                prefixKey := fmt.Sprintf("%s:prefix:%s", fieldName, strValue[:i])
                                if _, exists := index.fieldIndex[prefixKey]; !exists </span><span class="cov8" title="172">{
                                        index.fieldIndex[prefixKey] = make([]int, 0)
                                }</span>
                                <span class="cov10" title="413">index.fieldIndex[prefixKey] = append(index.fieldIndex[prefixKey], recordIndex)</span>
                        }
                }
        }

        // 为 symbol 字段建立特殊索引（如果存在）
        <span class="cov5" title="26">if symbol, exists := data.Values["symbol"]; exists </span><span class="cov5" title="26">{
                if strSymbol, ok := symbol.(string); ok </span><span class="cov5" title="26">{
                        symbolKey := fmt.Sprintf("symbol_index:%s", strSymbol)
                        if _, exists := index.fieldIndex[symbolKey]; !exists </span><span class="cov5" title="25">{
                                index.fieldIndex[symbolKey] = make([]int, 0)
                        }</span>
                        <span class="cov5" title="26">index.fieldIndex[symbolKey] = append(index.fieldIndex[symbolKey], recordIndex)</span>
                }
        }
}

// queryStructuredData 查询 StructuredData 是否匹配给定的查询条件
func (ms *MemoryStorage) queryStructuredData(data *subscriber.StructuredData, query core.Query) bool <span class="cov5" title="27">{
        // 如果没有查询条件，匹配所有记录
        if len(query.Symbols) == 0 &amp;&amp; query.StartTime.IsZero() &amp;&amp; query.EndTime.IsZero() </span><span class="cov3" title="6">{
                return true
        }</span>

        // 检查股票代码匹配
        <span class="cov5" title="21">if len(query.Symbols) &gt; 0 </span><span class="cov5" title="21">{
                if symbol, exists := data.Values["symbol"]; exists </span><span class="cov5" title="21">{
                        if symbolStr, ok := symbol.(string); ok </span><span class="cov5" title="21">{
                                found := false
                                for _, targetSymbol := range query.Symbols </span><span class="cov5" title="21">{
                                        if symbolStr == targetSymbol </span><span class="cov4" title="9">{
                                                found = true
                                                break</span>
                                        }
                                }
                                <span class="cov5" title="21">if !found </span><span class="cov4" title="12">{
                                        return false
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return false
                        }</span>
                } else<span class="cov0" title="0"> {
                        return false
                }</span>
        }

        // 检查时间范围
        <span class="cov4" title="9">if !query.StartTime.IsZero() &amp;&amp; data.Timestamp.Before(query.StartTime) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov4" title="9">if !query.EndTime.IsZero() &amp;&amp; data.Timestamp.After(query.EndTime) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="9">return true</span>
}

// GetStats 返回 MemoryStorage 的统计信息
func (ms *MemoryStorage) GetStats() MemoryStorageStats <span class="cov2" title="2">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()

        stats := ms.stats
        stats.TotalTables = len(ms.data)
        stats.IndexCount = len(ms.indexes)

        return stats
}</span>

// QueryBySymbol 根据股票代码查询 StructuredData（便捷方法）
func (ms *MemoryStorage) QueryBySymbol(ctx context.Context, symbol string) ([]*subscriber.StructuredData, error) <span class="cov4" title="9">{
        query := core.Query{
                Symbols: []string{symbol},
        }

        results, err := ms.Load(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 过滤出 StructuredData 类型的结果
        <span class="cov4" title="9">var structuredResults []*subscriber.StructuredData
        for _, result := range results </span><span class="cov4" title="10">{
                if structData, ok := result.(*subscriber.StructuredData); ok </span><span class="cov4" title="8">{
                        structuredResults = append(structuredResults, structData)
                }</span>
        }

        <span class="cov4" title="9">return structuredResults, nil</span>
}

// QueryByTimeRange 根据时间范围查询 StructuredData
func (ms *MemoryStorage) QueryByTimeRange(ctx context.Context, startTime, endTime time.Time) ([]*subscriber.StructuredData, error) <span class="cov2" title="2">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()

        var results []*subscriber.StructuredData

        // 遍历所有表中的 StructuredData
        for tableName, records := range ms.data </span><span class="cov2" title="2">{
                if !strings.HasPrefix(tableName, "table_structured_") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov2" title="2">for _, record := range records </span><span class="cov4" title="8">{
                        if structData, ok := record.(*subscriber.StructuredData); ok </span><span class="cov4" title="8">{
                                // 检查时间范围
                                if (structData.Timestamp.Equal(startTime) || structData.Timestamp.After(startTime)) &amp;&amp;
                                        (structData.Timestamp.Equal(endTime) || structData.Timestamp.Before(endTime)) </span><span class="cov3" title="5">{
                                        results = append(results, structData)
                                }</span>
                        }
                }
        }

        <span class="cov2" title="2">return results, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Package testkit 提供了用于支持测试的工具集，包括数据模拟、缓存、持久化存储等功能。
// 它是项目测试框架的核心，旨在提供一个与生产环境隔离、可预测且高效的测试数据环境。
package testkit

import (
        "context"
        "fmt"

        "sync"
        "time"

        "stocksub/pkg/subscriber"
        "stocksub/pkg/testkit/cache"
        "stocksub/pkg/testkit/config"
        "stocksub/pkg/testkit/core"
        "stocksub/pkg/testkit/providers"
        "stocksub/pkg/testkit/storage"
)

// testDataManager 是 core.TestDataManager 接口的默认实现。
// 它整合了缓存、存储和数据提供者，为测试提供统一的数据访问入口。
type testDataManager struct {
        config       *config.Config
        cache        core.Cache
        storage      core.Storage
        provider     core.Provider
        cacheEnabled bool
        sessionID    string
        stats        *enhancedStats
        mu           sync.RWMutex
}

// enhancedStats 包含了 testDataManager 内部的详细统计信息。
type enhancedStats struct {
        cacheHits     int64
        cacheMisses   int64
        apiCalls      int64
        storageWrites int64
        storageReads  int64
        mockCalls     int64
        lastActivity  time.Time
        mutex         sync.RWMutex
}

// NewTestDataManager 是 testkit 的主要入口点，用于创建一个新的测试数据管理器实例。
// 它会根据传入的配置自动初始化多层缓存、持久化存储和数据提供者。
//
// 参数:
//   - cfg: 指向 config.Config 的指针，用于配置管理器的所有行为，
//     包括缓存策略、存储类型和目录等。
//
// 返回:
//   - 一个实现了 core.TestDataManager 接口的实例。
func NewTestDataManager(cfg *config.Config) core.TestDataManager <span class="cov0" title="0">{
        // 创建缓存层
        var cacheLayer core.Cache
        if cfg.Cache.Type == "layered" </span><span class="cov0" title="0">{
                layeredConfig := cache.DefaultLayeredCacheConfig()
                layeredCache, err := cache.NewLayeredCache(layeredConfig)
                if err != nil </span><span class="cov0" title="0">{
                        // 回退到简单内存缓存
                        memConfig := cache.MemoryCacheConfig{
                                MaxSize:         cfg.Cache.MaxSize,
                                DefaultTTL:      cfg.Cache.TTL,
                                CleanupInterval: 5 * time.Minute,
                        }
                        cacheLayer = cache.NewMemoryCache(memConfig)
                }</span> else<span class="cov0" title="0"> {
                        cacheLayer = layeredCache
                }</span>
        } else<span class="cov0" title="0"> {
                memConfig := cache.MemoryCacheConfig{
                        MaxSize:         cfg.Cache.MaxSize,
                        DefaultTTL:      cfg.Cache.TTL,
                        CleanupInterval: 5 * time.Minute,
                }
                cacheLayer = cache.NewMemoryCache(memConfig)
        }</span>

        // 创建存储层
        <span class="cov0" title="0">var storageLayer core.Storage
        if cfg.Storage.Type == "csv" </span><span class="cov0" title="0">{
                csvConfig := storage.DefaultCSVStorageConfig()
                csvConfig.Directory = cfg.Storage.Directory
                csvStorage, err := storage.NewCSVStorage(csvConfig)
                if err != nil </span><span class="cov0" title="0">{
                        // 回退到内存存储
                        memStorageConfig := storage.DefaultMemoryStorageConfig()
                        storageLayer = storage.NewMemoryStorage(memStorageConfig)
                }</span> else<span class="cov0" title="0"> {
                        storageLayer = csvStorage
                }</span>
        } else<span class="cov0" title="0"> {
                memStorageConfig := storage.DefaultMemoryStorageConfig()
                storageLayer = storage.NewMemoryStorage(memStorageConfig)
        }</span>

        // 创建Provider层
        <span class="cov0" title="0">providerFactory := providers.NewProviderFactory(cacheLayer)
        cachedProviderConfig := providers.DefaultCachedProviderConfig()
        providerLayer := providerFactory.CreateCachedProvider(cachedProviderConfig)

        return &amp;testDataManager{
                config:       cfg,
                cache:        cacheLayer,
                storage:      storageLayer,
                provider:     providerLayer,
                cacheEnabled: true,
                sessionID:    generateSessionID(),
                stats:        &amp;enhancedStats{lastActivity: time.Now()},
        }</span>
}

// GetStockData 实现了 core.TestDataManager 接口的 GetStockData 方法。
func (tdm *testDataManager) GetStockData(ctx context.Context, symbols []string) ([]subscriber.StockData, error) <span class="cov0" title="0">{
        startTime := time.Now()
        defer func() </span><span class="cov0" title="0">{
                tdm.stats.mutex.Lock()
                tdm.stats.lastActivity = time.Now()
                tdm.stats.mutex.Unlock()
        }</span>()

        // 1. 检查顶层缓存
        <span class="cov0" title="0">cacheKey := tdm.generateCacheKey(symbols)
        if tdm.cacheEnabled </span><span class="cov0" title="0">{
                if cachedData, err := tdm.cache.Get(ctx, cacheKey); err == nil </span><span class="cov0" title="0">{
                        tdm.updateCacheHit()
                        fmt.Printf("🎯 TestDataManager 缓存命中，股票: %v\n", symbols)
                        return cachedData.([]subscriber.StockData), nil
                }</span>
        }

        // 2. 缓存未命中，通过Provider获取
        <span class="cov0" title="0">tdm.updateCacheMiss()
        fmt.Printf("📡 通过Provider获取数据，股票: %v\n", symbols)
        data, err := tdm.provider.FetchData(ctx, symbols)
        if err != nil </span><span class="cov0" title="0">{
                return nil, core.WrapError(core.ErrProviderError, "获取数据失败", err)
        }</span>

        // 3. 获取成功后，异步更新缓存和存储
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                // 更新顶层缓存
                if tdm.cacheEnabled </span><span class="cov0" title="0">{
                        if err := tdm.cache.Set(ctx, cacheKey, data, tdm.config.Cache.TTL); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("⚠️ 顶层缓存存储失败: %v\n", err)
                        }</span>
                }
                // 保存到存储层
                <span class="cov0" title="0">if err := tdm.saveToStorage(context.Background(), data); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("⚠️ 存储数据失败: %v\n", err)
                }</span>
        }()

        <span class="cov0" title="0">tdm.stats.mutex.Lock()
        tdm.stats.apiCalls++
        tdm.stats.mutex.Unlock()

        fmt.Printf("✅ 数据获取完成，耗时: %v\n", time.Since(startTime))
        return data, nil</span>
}

// SetMockData 实现了 core.TestDataManager 接口的 SetMockData 方法。
func (tdm *testDataManager) SetMockData(symbols []string, data []subscriber.StockData) <span class="cov0" title="0">{
        tdm.provider.SetMockData(symbols, data)
}</span>

// EnableCache 实现了 core.TestDataManager 接口的 EnableCache 方法。
func (tdm *testDataManager) EnableCache(enabled bool) <span class="cov0" title="0">{
        tdm.mu.Lock()
        defer tdm.mu.Unlock()

        tdm.cacheEnabled = enabled
        if !enabled </span><span class="cov0" title="0">{
                // 清空缓存
                tdm.cache.Clear(context.Background())
        }</span>
}

// EnableMock 实现了 core.TestDataManager 接口的 EnableMock 方法。
func (tdm *testDataManager) EnableMock(enabled bool) <span class="cov0" title="0">{
        tdm.provider.SetMockMode(enabled)
}</span>

// Reset 实现了 core.TestDataManager 接口的 Reset 方法。
func (tdm *testDataManager) Reset() error <span class="cov0" title="0">{
        // 清空缓存
        if err := tdm.cache.Clear(context.Background()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("清空缓存失败: %w", err)
        }</span>

        // 重置统计信息
        <span class="cov0" title="0">tdm.stats.mutex.Lock()
        tdm.stats.cacheHits = 0
        tdm.stats.cacheMisses = 0
        tdm.stats.apiCalls = 0
        tdm.stats.storageWrites = 0
        tdm.stats.storageReads = 0
        tdm.stats.mockCalls = 0
        tdm.stats.lastActivity = time.Now()
        tdm.stats.mutex.Unlock()

        fmt.Printf("🔄 TestDataManager已重置\n")
        return nil</span>
}

// GetStats 实现了 core.TestDataManager 接口的 GetStats 方法。
func (tdm *testDataManager) GetStats() core.Stats <span class="cov0" title="0">{
        tdm.stats.mutex.RLock()
        defer tdm.stats.mutex.RUnlock()

        // 获取缓存统计
        cacheStats := tdm.cache.Stats()

        return core.Stats{
                CacheSize: cacheStats.Size,
                TTL:       tdm.config.Cache.TTL,
                Directory: tdm.config.Storage.Directory,

                CacheHits:   tdm.stats.cacheHits + cacheStats.HitCount,
                CacheMisses: tdm.stats.cacheMisses + cacheStats.MissCount,
        }
}</span>

// Close 实现了 core.TestDataManager 接口的 Close 方法。
func (tdm *testDataManager) Close() error <span class="cov0" title="0">{
        var errs []error

        // 关闭Provider
        if err := tdm.provider.Close(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("关闭Provider失败: %w", err))
        }</span>

        // 关闭存储
        <span class="cov0" title="0">if err := tdm.storage.Close(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("关闭存储失败: %w", err))
        }</span>

        // 关闭缓存
        <span class="cov0" title="0">if closer, ok := tdm.cache.(interface{ Close() error }); ok </span><span class="cov0" title="0">{
                if err := closer.Close(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("关闭缓存失败: %w", err))
                }</span>
        }

        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("关闭过程中发生错误: %v", errs)
        }</span>

        <span class="cov0" title="0">fmt.Printf("🔒 TestDataManager已关闭\n")
        return nil</span>
}

// --- 私有辅助方法 ---

func (tdm *testDataManager) generateCacheKey(symbols []string) string <span class="cov0" title="0">{
        // 使用简单的字符串连接作为缓存键
        return fmt.Sprintf("stocks:%v", symbols)
}</span>

func (tdm *testDataManager) updateCacheHit() <span class="cov0" title="0">{
        tdm.stats.mutex.Lock()
        tdm.stats.cacheHits++
        tdm.stats.mutex.Unlock()
}</span>

func (tdm *testDataManager) updateCacheMiss() <span class="cov0" title="0">{
        tdm.stats.mutex.Lock()
        tdm.stats.cacheMisses++
        tdm.stats.mutex.Unlock()
}</span>

func (tdm *testDataManager) saveToStorage(ctx context.Context, data []subscriber.StockData) error <span class="cov0" title="0">{
        for _, stockData := range data </span><span class="cov0" title="0">{
                if err := tdm.storage.Save(ctx, stockData); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("保存股票数据失败 %s: %w", stockData.Symbol, err)
                }</span>
        }

        <span class="cov0" title="0">tdm.stats.mutex.Lock()
        tdm.stats.storageWrites += int64(len(data))
        tdm.stats.mutex.Unlock()

        return nil</span>
}

// GetAdvancedStats 获取详细统计信息 (内部使用)。
func (tdm *testDataManager) GetAdvancedStats() map[string]interface{} <span class="cov0" title="0">{
        tdm.stats.mutex.RLock()
        defer tdm.stats.mutex.RUnlock()

        cacheStats := tdm.cache.Stats()

        return map[string]interface{}{
                "session_id":     tdm.sessionID,
                "cache_enabled":  tdm.cacheEnabled,
                "cache_stats":    cacheStats,
                "api_calls":      tdm.stats.apiCalls,
                "storage_writes": tdm.stats.storageWrites,
                "storage_reads":  tdm.stats.storageReads,
                "mock_calls":     tdm.stats.mockCalls,
                "last_activity":  tdm.stats.lastActivity,
        }
}</span>

// GetMockProvider 获取底层的Mock Provider（内部测试使用）。
func (tdm *testDataManager) GetMockProvider() interface{} <span class="cov0" title="0">{
        if cachedProvider, ok := tdm.provider.(*providers.CachedProvider); ok </span><span class="cov0" title="0">{
                return cachedProvider.GetMockProvider()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func generateSessionID() string <span class="cov0" title="0">{
        return fmt.Sprintf("enhanced_%d", time.Now().Unix())
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package timing

import (
        "time"
)

// TimeService 提供当前时间接口，用于mock测试
type TimeService interface {
        Now() time.Time
}

// SystemTimeService 使用系统实际时间
type SystemTimeService struct{}

func (s *SystemTimeService) Now() time.Time <span class="cov1" title="1">{
        return time.Now()
}</span>

// MarketTime 提供市场交易时间检测功能
type MarketTime struct {
        timeService TimeService
}

// NewMarketTime 创建新的市场时间检测器
func NewMarketTime(timeService TimeService) *MarketTime <span class="cov10" title="52">{
        return &amp;MarketTime{
                timeService: timeService,
        }
}</span>

// DefaultMarketTime 使用系统时间的默认市场时间检测器
func DefaultMarketTime() *MarketTime <span class="cov1" title="1">{
        return NewMarketTime(&amp;SystemTimeService{})
}</span>

// Now 返回当前时间
func (m *MarketTime) Now() time.Time <span class="cov0" title="0">{
        return m.timeService.Now()
}</span>

// IsTradingTime 判断当前是否在交易时段
func (m *MarketTime) IsTradingTime() bool <span class="cov8" title="24">{
        now := m.timeService.Now()

        // 周末不交易
        if !m.IsTradingDay(now) </span><span class="cov3" title="3">{
                return false
        }</span>

        // 上午交易时段: 09:13:30 - 11:30:10
        // 下午交易时段: 12:57:30 - 15:00:10
        <span class="cov7" title="21">currentTime := now.Format("15:04:05")

        morningStart := "09:13:30"
        morningEnd := "11:30:10"

        afternoonStart := "12:57:30"
        afternoonEnd := "15:00:10"

        return (currentTime &gt;= morningStart &amp;&amp; currentTime &lt;= morningEnd) ||
                (currentTime &gt;= afternoonStart &amp;&amp; currentTime &lt;= afternoonEnd)</span>
}

// IsTradingDay 判断是否是交易日（周一到周五）
func (m *MarketTime) IsTradingDay(t time.Time) bool <span class="cov9" title="44">{
        weekday := t.Weekday()
        return weekday &gt;= time.Monday &amp;&amp; weekday &lt;= time.Friday
}</span>

// GetNextTradingDayStart 获取下一个交易日的开始时间
func (m *MarketTime) GetNextTradingDayStart() time.Time <span class="cov4" title="5">{
        now := m.timeService.Now()
        todayMorning := time.Date(now.Year(), now.Month(), now.Day(), 9, 13, 30, 0, now.Location())

        // 如果是周末，跳到下周
        if !m.IsTradingDay(now) </span><span class="cov2" title="2">{
                daysUntilNext := 0
                switch now.Weekday() </span>{
                case time.Saturday:<span class="cov1" title="1">
                        daysUntilNext = 2</span>
                case time.Sunday:<span class="cov1" title="1">
                        daysUntilNext = 1</span>
                default:<span class="cov0" title="0">
                        daysUntilNext = 0</span>
                }
                <span class="cov2" title="2">return todayMorning.AddDate(0, 0, daysUntilNext)</span>
        }

        // 如果今天已经过了交易时间，跳到明天
        <span class="cov3" title="3">currentTime := now.Format("15:04:05")
        if currentTime &gt; "15:00:10" </span><span class="cov2" title="2">{
                // 如果今天是周五，跳到周一
                if now.Weekday() == time.Friday </span><span class="cov1" title="1">{
                        return todayMorning.AddDate(0, 0, 3)
                }</span>
                <span class="cov1" title="1">return todayMorning.AddDate(0, 0, 1)</span>
        }

        <span class="cov1" title="1">return todayMorning</span>
}

// GetTradingEndTime 获取当天交易结束时间
func (m *MarketTime) GetTradingEndTime() time.Time <span class="cov1" title="1">{
        now := m.timeService.Now()
        return time.Date(now.Year(), now.Month(), now.Day(), 15, 0, 10, 0, now.Location())
}</span>

// IsCloseToEnd 判断是否在收盘前5分钟内（预留方法，现已不用于数据一致性检测）
func (m *MarketTime) IsCloseToEnd() bool <span class="cov5" title="7">{
        now := m.timeService.Now()
        currentTime := now.Format("15:04:05")

        // 收盘前5分钟: 14:55:00 - 15:00:10
        return currentTime &gt;= "14:55:00" &amp;&amp; currentTime &lt;= "15:00:10"
}</span>

// IsAfterTradingEnd 判断是否在收盘后（用于数据一致性检测）
func (m *MarketTime) IsAfterTradingEnd() bool <span class="cov5" title="8">{
        now := m.timeService.Now()

        // 周末不交易，不需要检查
        if !m.IsTradingDay(now) </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov5" title="7">currentTime := now.Format("15:04:05")
        // 收盘后时段: 15:00:11 之后（给1秒缓冲时间）
        return currentTime &gt;= "15:00:11"</span>
}

// TimeUntilNextInterval 计算到下一个检查间隔的等待时间
func (m *MarketTime) TimeUntilNextInterval(minutes int) time.Duration <span class="cov0" title="0">{
        now := m.timeService.Now()
        nextInterval := now.Add(time.Duration(minutes) * time.Minute)
        return nextInterval.Sub(now)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
